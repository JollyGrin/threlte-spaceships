Directory structure:
└── docs/
    └── src/
        └── content/
            ├── authors/
            │   ├── Grischa Erbe.mdx
            │   └── Threlte Team.mdx
            ├── blog/
            │   └── Threlte 8.mdx
            ├── examples/
            │   ├── Examples.mdx
            │   ├── Misc/
            │   │   └── Gaussian Splatting.mdx
            │   ├── Tutorials/
            │   │   └── Animating a Spaceship.mdx
            │   ├── animation/
            │   │   ├── Animation Transitions.mdx
            │   │   └── Complex sprite scene.mdx
            │   ├── camera/
            │   │   └── camera-controls.mdx
            │   ├── games/
            │   │   └── Arcade machine.mdx
            │   ├── geometry/
            │   │   ├── Random Placement.mdx
            │   │   ├── Rendering Points.mdx
            │   │   ├── Terrain with 3D noise.mdx
            │   │   └── Terrain with Rapier physics.mdx
            │   ├── marching-cubes/
            │   │   └── LavaLamp.mdx
            │   ├── meshline/
            │   │   └── Cursor Lines.mdx
            │   ├── postprocessing/
            │   │   ├── Outlines.mdx
            │   │   └── ScreenQuad.mdx
            │   ├── renderers/
            │   │   └── CSS2DRenderer Overlay.mdx
            │   └── shaders/
            │       ├── Interactive shader.mdx
            │       └── Scope with zoom.mdx
            ├── learn/
            │   ├── advanced/
            │   │   ├── custom-abstractions.mdx
            │   │   ├── migration-guides.mdx
            │   │   ├── plugins.mdx
            │   │   └── webgpu.mdx
            │   ├── basics/
            │   │   ├── app-structure.mdx
            │   │   ├── disposing-objects.mdx
            │   │   ├── handling-events.mdx
            │   │   ├── loading-assets.mdx
            │   │   ├── render-modes.mdx
            │   │   └── scheduling-tasks.mdx
            │   ├── getting-started/
            │   │   ├── installation.mdx
            │   │   ├── introduction.mdx
            │   │   └── your-first-scene.mdx
            │   └── more/
            │       └── resources.mdx
            ├── reference/
            │   ├── core/
            │   │   ├── canvas.mdx
            │   │   ├── components.mdx
            │   │   ├── getting-started.mdx
            │   │   ├── helpers.mdx
            │   │   ├── hooks.mdx
            │   │   ├── plugins.mdx
            │   │   ├── t.mdx
            │   │   ├── use-loader.mdx
            │   │   ├── use-stage.mdx
            │   │   ├── use-task.mdx
            │   │   ├── use-threlte-user-context.mdx
            │   │   ├── use-threlte.mdx
            │   │   └── utilities.mdx
            │   ├── docs/
            │   │   └── docs.mdx
            │   ├── extras/
            │   │   ├── align.mdx
            │   │   ├── animated-sprite-material.mdx
            │   │   ├── ascii-renderer.mdx
            │   │   ├── audio-listener.mdx
            │   │   ├── audio.mdx
            │   │   ├── audioCategory.mdx
            │   │   ├── bake-shadows.mdx
            │   │   ├── billboard.mdx
            │   │   ├── contact-shadows.mdx
            │   │   ├── content.mdx
            │   │   ├── csm.mdx
            │   │   ├── cube-camera.mdx
            │   │   ├── cube-environment.mdx
            │   │   ├── detailed.mdx
            │   │   ├── discard-material.mdx
            │   │   ├── edges.mdx
            │   │   ├── environment.mdx
            │   │   ├── fake-glow-material.mdx
            │   │   ├── float.mdx
            │   │   ├── getting-started.mdx
            │   │   ├── gizmo.mdx
            │   │   ├── gltf.mdx
            │   │   ├── grid.mdx
            │   │   ├── html.mdx
            │   │   ├── hud.mdx
            │   │   ├── image-material.mdx
            │   │   ├── instance.mdx
            │   │   ├── instanced-mesh.mdx
            │   │   ├── instanced-meshes.mdx
            │   │   ├── instanced-sprite.mdx
            │   │   ├── interaction.mdx
            │   │   ├── interactivity.mdx
            │   │   ├── layers.mdx
            │   │   ├── linear-gradient-texture.mdx
            │   │   ├── loading.mdx
            │   │   ├── mask.mdx
            │   │   ├── mesh-bounds.mdx
            │   │   ├── mesh-refraction-material.mdx
            │   │   ├── meshline-geometry.mdx
            │   │   ├── meshline-material.mdx
            │   │   ├── misc.mdx
            │   │   ├── onReveal.mdx
            │   │   ├── onSuspend.mdx
            │   │   ├── orbit-controls.mdx
            │   │   ├── outlines.mdx
            │   │   ├── peformance.mdx
            │   │   ├── perf-monitor.mdx
            │   │   ├── portal-target.mdx
            │   │   ├── portal.mdx
            │   │   ├── positional-audio.mdx
            │   │   ├── radial-gradient-texture.mdx
            │   │   ├── resize.mdx
            │   │   ├── rounded-box-geometry.mdx
            │   │   ├── sky.mdx
            │   │   ├── soft-shadows.mdx
            │   │   ├── staging.mdx
            │   │   ├── stars.mdx
            │   │   ├── suspense.mdx
            │   │   ├── text-3d-geometry.mdx
            │   │   ├── text.mdx
            │   │   ├── trackball-controls.mdx
            │   │   ├── transform-controls.mdx
            │   │   ├── transitions.mdx
            │   │   ├── use-audio-listener.mdx
            │   │   ├── use-cursor.mdx
            │   │   ├── use-fbo.mdx
            │   │   ├── use-gamepad.mdx
            │   │   ├── use-gltf-animations.mdx
            │   │   ├── use-gltf.mdx
            │   │   ├── use-progress.mdx
            │   │   ├── use-suspense.mdx
            │   │   ├── use-texture.mdx
            │   │   ├── use-threlte-audio.mdx
            │   │   ├── use-viewport.mdx
            │   │   ├── view.mdx
            │   │   ├── virtual-environment.mdx
            │   │   └── visual-effects.mdx
            │   ├── flex/
            │   │   ├── box.mdx
            │   │   ├── components.mdx
            │   │   ├── create-class-parser.mdx
            │   │   ├── examples.mdx
            │   │   ├── flex.mdx
            │   │   ├── getting-started.mdx
            │   │   ├── hooks.mdx
            │   │   ├── tailwind-parser.mdx
            │   │   ├── use-dimensions.mdx
            │   │   ├── use-reflow.mdx
            │   │   └── utilities.mdx
            │   ├── gltf/
            │   │   └── getting-started.mdx
            │   ├── rapier/
            │   │   ├── about-joints.mdx
            │   │   ├── attractor.mdx
            │   │   ├── auto-colliders.mdx
            │   │   ├── collider.mdx
            │   │   ├── collision-groups.mdx
            │   │   ├── components.mdx
            │   │   ├── concepts.mdx
            │   │   ├── debug.mdx
            │   │   ├── framerate.mdx
            │   │   ├── getting-started.mdx
            │   │   ├── hooks.mdx
            │   │   ├── joints.mdx
            │   │   ├── rigid-body.mdx
            │   │   ├── use-collision-groups.mdx
            │   │   ├── use-fixed-joint.mdx
            │   │   ├── use-joint.mdx
            │   │   ├── use-physics-task.mdx
            │   │   ├── use-prismatic-joint.mdx
            │   │   ├── use-rapier.mdx
            │   │   ├── use-revolute-joint.mdx
            │   │   ├── use-rigid-body.mdx
            │   │   ├── use-rope-joint.mdx
            │   │   ├── use-spherical-joint.mdx
            │   │   └── world.mdx
            │   ├── studio/
            │   │   ├── advanced.mdx
            │   │   ├── authoring-extensions.mdx
            │   │   ├── components.mdx
            │   │   ├── deploying-to-production.mdx
            │   │   ├── extensions.mdx
            │   │   ├── getting-started.mdx
            │   │   ├── static-state.mdx
            │   │   ├── studio.mdx
            │   │   ├── use-object-selection.mdx
            │   │   ├── use-snapping.mdx
            │   │   ├── use-space.mdx
            │   │   ├── use-studio-objects-registry.mdx
            │   │   ├── use-transactions.mdx
            │   │   └── use-transform-controls.mdx
            │   ├── theatre/
            │   │   ├── actions.mdx
            │   │   ├── components.mdx
            │   │   ├── declare.mdx
            │   │   ├── getting-started.mdx
            │   │   ├── hooks.mdx
            │   │   ├── project.mdx
            │   │   ├── sequence.mdx
            │   │   ├── sheet-object-action.mdx
            │   │   ├── sheet-object-section.mdx
            │   │   ├── sheet-object.mdx
            │   │   ├── sheet.mdx
            │   │   ├── studio.mdx
            │   │   ├── sync.mdx
            │   │   ├── theatre.mdx
            │   │   ├── transform.mdx
            │   │   ├── use-sequence.mdx
            │   │   └── use-studio.mdx
            │   └── xr/
            │       ├── button-ar.mdx
            │       ├── button-vr.mdx
            │       ├── button-xr.mdx
            │       ├── components.mdx
            │       ├── controller.mdx
            │       ├── controls.mdx
            │       ├── getting-started.mdx
            │       ├── hand.mdx
            │       ├── headset.mdx
            │       ├── hooks.mdx
            │       ├── pointer-controls.mdx
            │       ├── teleport-controls.mdx
            │       ├── use-controller.mdx
            │       ├── use-hand-joint.mdx
            │       ├── use-hand.mdx
            │       ├── use-headset.mdx
            │       ├── use-hit-test.mdx
            │       ├── use-teleport.mdx
            │       ├── use-xr.mdx
            │       └── xr.mdx
            ├── showcase/
            │   ├── bridge copy 2.mdx
            │   ├── bridge copy 3.mdx
            │   ├── bridge copy 4.mdx
            │   ├── bridge copy 5.mdx
            │   ├── bridge copy 6.mdx
            │   ├── bridge copy.mdx
            │   ├── bridge.mdx
            │   ├── horse-carriage.mdx
            │   ├── street-art copy 2.mdx
            │   ├── street-art copy 3.mdx
            │   ├── street-art copy.mdx
            │   └── street-art.mdx
            └── testimonials/
                ├── amr.mdx
                ├── aria-minaei.mdx
                ├── matthias-stahl.mdx
                ├── rich-harris.mdx
                ├── shiva.mdx
                ├── shiyun.mdx
                └── vatroslav.mdx

================================================
File: apps/docs/src/content/blog/Threlte 8.mdx
================================================
---
date: '2025-01-20'
image: '/images/blog/threlte-8.png'
author: 'Threlte Team'
title: 'Threlte 8'
subtitle: 'The next major release of Threlte'
---

Today we are releasing **Threlte 8**, a significant milestone that marks a leap
forward in performance, flexibility, and developer experience. This release has
been cooking for the last 6 months. We're super excited about the potential it
unlocks for the next chapter of 3D graphics on the web.

The new features of **Svelte 5** are groundbreaking for us as developers and
embracing it was also an opportunity to refine the existing APIs. Furthermore, a
lot has been happening within the world of **Three.js**. We've carved the path
for Threlte to take advantage of those developments too.

## What's new in Threlte 8?

Threlte 8 is packed with enhancements in `@threlte/core` and updates in all our
other packages. Here are the highlights:

### All-new `<T>` component

The universal [`<T>` component](/docs/reference/core/t) has been **reduced in
complexity** all while **adding features and flexibility** that were just not
possible before.

- Props are now evaluated individually
- [`attach` got a lot more
  powerful](/docs/learn/advanced/migration-guides#attach-api--trait-components)
- [Automatic disposal is more
  transparent](docs/learn/advanced/migration-guides#automatic-disposal) and
- [Events have been algined with svelte 5](/docs/learn/advanced/migration-guides#events)

### New `@threlte/extras` components

We've added a lot of new things to play around with in `@threlte/extras` including:
[`<AsciiRenderer>`](/docs/reference/extras/ascii-renderer),
[`<CubeCamera>`](/docs/reference/extras/cube-camera),
[`<MeshDiscardMaterial>`](/docs/reference/extras/discard-material),
[`<RadialGradientTexture>`](/docs/reference/extras/radial-gradient-texture),
[`<LinearGradientTexture>`](/docs/reference/extras/linear-gradient-texture),
[`useViewport`](/docs/reference/extras/use-viewport),
[`<HUD>`](/docs/reference/extras/hud),
[`<Resize>`](/docs/reference/extras/resize),
[`<meshBounds>`](/docs/reference/extras/mesh-bounds),
[`<Detailed>`](/docs/reference/extras/detailed) and
[`<View>`](/docs/reference/extras/view).

### Custom type support for `<T>`

Plugins such as
[`interactivity`](/docs/reference/extras/interactivity#prop-types) now expose
types which can be added to your ambient type definitions for the `<T>`
component to pick up. Event handlers and custom `<T>` component objects are now
type-safe.

### Fixed frame physics

`@threlte/rapier` now supports [fixed frame
physics](/docs/reference/rapier/framerate) letting you craft simulations with
predictability and consistency.

### Threlte plugin API

The **Plugin API** got an update to [fully embrace Svelte 5's reactivity
model](/docs/learn/advanced/migration-guides#plugin-api). The doc page also
had an update to better introduce the API's capabilities.

### This is the _WebGPU_ way

Threlte 8 introduces a clear path for [using
WebGPU](/docs/learn/advanced/webgpu). Threlte requires minimal changes to
projects in order to start using three.js's new WebGPU renderer and we've also
outlined how to get started with [three's new shading
language](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language) -
TSL.

### A new package appears

An alpha release of [Threlte Studio](/docs/reference/studio/getting-started) is
part of this release 🎉 It's a step towards visual editing; letting you tweak
values in browser and then automatically having those changes written into your
code. Theres a guided tour to help you get started. We hope it helps get things
where you want them 🚀😀

## How to migrate to Threlte 8

There are breaking changes. Threlte 8 is not backward-compatible but we've
tried our best to cover the details within our [migration
guide](/docs/learn/advanced/migration-guides#threlte-8). For further help,
reach out to us on discord.

## Built with the community, for the community

<img
  width="200"
  src="/threlte-8-diff.png"
  alt="THrelte8Diff"
/>

This rewrite was a team effort with great contributions from the community.
Thank you to everyone who tested out any of our `@next` releases. We're immensely
grateful for the time, talent, and passion of our community. You guys rock 😃

## What's next?

We decided to deprecate the `npm create threlte` command. We're excited about
Svelte's new `sv` CLI to incorporate third party packages and we're going to
offer Threlte as a package to be installed with `sv` in the near future.

We'd love to hear about what everyone makes with Threlte 8! Take it for a spin,
explore the new documentation, and start building your next 3D application with
the super powers of Threlte 8 🎉

<div class="mt-12 flex justify-center">
  <a
    href="/docs/learn/getting-started/introduction"
    class="group flex w-fit flex-row gap-3 rounded-md bg-orange px-7 py-4 text-center glow-orange hover:bg-orange-400 hover:no-underline hover:glow-orange-400"
  >
    <p class="my-0 text-lg !text-white !no-underline">Start Building →</p>
  </a>
</div>


================================================
File: apps/docs/src/content/examples/Examples.mdx
================================================
There are a ton of different challenges and things to consider when creating a 3D project.
Here you will find recipes and inspiration to get started with Threlte.

<Tip
  type="note"
  title="Help Wanted"
>
  We'd love your help to make, add to and edit the examples. There lots of examples from
  [three.js](https://threejs.org/examples/#webgl_animation_keyframes) and
  [r3f](https://docs.pmnd.rs/react-three-fiber/getting-started/examples) that could serve as
  inspiration. Read through the [contributing
  guide](https://github.com/threlte/threlte/blob/main/CONTRIBUTING.md) and [Examples
  README](https://github.com/threlte/threlte/blob/main/apps/docs/src/examples/README.md) to get
  started.
</Tip>


================================================
File: apps/docs/src/content/examples/Misc/Gaussian Splatting.mdx
================================================
[3D Gaussian Splatting](https://huggingface.co/blog/gaussian-splatting) is a
rasterization technique that allows to render 3D objects with a high level of
detail. It's currently quickly gaining popularity because of the photorealistic
rendering of 3D scan data. This example shows how to implement 3D Gaussian
Splatting with the help of two libraries:

- [`@lumaai/luma-web`](https://lumalabs.ai/luma-web-library) by [Luma](https://lumalabs.ai/)
- [`@pmndrs/vanilla`](https://github.com/pmndrs/drei-vanilla)

<Tip type="experimental">
  The technology presented in this example is rapidly developing and therefore the components are
  not part of the [`@threlte/extras`](/docs/reference/extras/getting-started) package *as of now*.
  You may however copy and paste them into your project and use them as you wish.
</Tip>

<Example
  path="misc/gaussian-splatting"
  iframe
  showFile="Scene.svelte"
  expandCode
/>

<small>

    Models:

    - Scene: https://lumalabs.ai/capture/4c15c22e-8655-4423-aeac-b08f017dda22
    - Shoe: https://huggingface.co/cakewalk
    - Porsche: https://sketchfab.com/3d-models/porsche-959-0530aa8fa4b74427a71c961a5bdd7087

</small>


================================================
File: apps/docs/src/content/examples/Tutorials/Animating a Spaceship.mdx
================================================
This tutorial demonstrates how to load and animate a spaceship model, as well as using Threlte's InstancedMesh to efficiently animate hundreds of stars. We'll also cover raycaster intersections, post-processing effects, and dynamically generated reflection maps.

<Example
  path="tutorials/animating-a-spaceship"
  iframe
/>

## Part I

<div style="position: relative; padding-bottom: 56.25%; padding-top: 25px; height: 0;">
  <iframe
    width="560"
    height="315"
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
    src="https://www.youtube.com/embed/soa_KP8QfjM?si=GDsjj8VFm9Zfejtq"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen
  ></iframe>
</div>

## Part II

The second part of the tutorial focuses on applying a spring-based animation to the spaceship model by
leveraging `useFrame`, a Threlte 6 hook used to run a callback on every frame.
Threlte 7 improved the task scheduling API by introducing [useTask](/docs/reference/core/use-task),
as of Threlte 8 `useFrame` has been removed and should be replaced.

```ts title="Threlte 6"
useFrame(() => {
  ...
})
```

```ts title="Threlte 7"
useTask(() => {
  ...
})
```

<div style="position: relative; padding-bottom: 56.25%; padding-top: 25px; height: 0;">
  <iframe
    width="560"
    height="315"
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
    src="https://www.youtube.com/embed/wIW9HCHRyRw?si=yy8Qm7LeuGhins6G"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen
  ></iframe>
</div>

## Part III

In this last portion of the tutorial we'll introduce post-processing effects that
require control over the render loop, and similiarly to episode 2 the video relies
on `useRender`, a Threlte 6 hook used to manually render a scene.
The equivalent Threlte 7 logic adds a task to [Threlte's default `renderStage`](/docs/learn/basics/scheduling-tasks#default-stages)

```ts title="Threlte 6"
const { scene, camera, renderer } = useThrelte()

useRender(() => {
  // render here
})
```

```ts title="Threlte 7"
const { scene, camera, renderer, renderStage } = useThrelte()

useTask(
  () => {
    // render here
  },
  { stage: renderStage, autoInvalidate: false }
)
```

<div style="position: relative; padding-bottom: 56.25%; padding-top: 25px; height: 0;">
  <iframe
    width="560"
    height="315"
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
    src="https://www.youtube.com/embed/pcKVlKGWov4?si=mInLqfpZqE26RTPi"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen
  ></iframe>
</div>


================================================
File: apps/docs/src/content/examples/animation/Animation Transitions.mdx
================================================
Transition seamlessly between GLTF animations.

<Example path="animation/transitions" />

## Explanation

glTF is a comprehensive file format for 3D models, and it supports animations.
In this example, we extract the animations from the gltf file, play them, and crossfade between them.

### What is the code doing?

1. Extract the variables `gltf` and `actions`;

   `const { gltf, actions } = useGltfAnimations()`

2. Bind `gltf` to the `<GLTF>` component,

```
<GLTF
  bind:gltf={$gltf}
  url="https://threejs.org/examples/models/gltf/Xbot.glb"
/>
```

this causes `actions` to be populated with an array of the available animations in that gltf file

<Tip type="tip">
  run `console.log(Object.entries($actions))` to see the available action strings, and the shape of
  the animation object. By doing this, you'll discover that this example is only using 3 of the 7
  available animations attached to this gltf file.
</Tip>

3. selecting a different animation calls `transitionTo` function, which crossfades between the two animations


================================================
File: apps/docs/src/content/examples/animation/Complex sprite scene.mdx
================================================
This example demonstrates [`<InstancedSprites>`](/docs/reference/extras/instanced-sprite), showing
a few different approaches for instancing and updating large numbers of sprites in your scene.

<Example
  path="instancing/instanced-sprite-mania"
  iframe
/>

## How it works?

This covers step-by-step how you can configure `<InstancedSprite/>` component, starting from defining a spritesheet, then adding it to the scene and finally updating the instances in real time.

### Sprite metadata object

```svelte title=Flyer.svelte
<script lang="ts">
  import { InstancedSprite, buildSpritesheet } from '@threlte/extras'
  import UpdaterFlying from './UpdaterFlying.svelte'
  import type { SpritesheetMetadata } from '@threlte/extras'

  const demonSpriteMeta = [
    {
      url: '/textures/sprites/cacodaemon.png',
      type: 'rowColumn',
      width: 8,
      height: 4,
      animations: [
        { name: 'fly', frameRange: [0, 5] },
        { name: 'attack', frameRange: [8, 13] },
        { name: 'idle', frameRange: [16, 19] },
        { name: 'death', frameRange: [24, 31] }
      ]
    }
  ] as const satisfies SpritesheetMetadata

  const flyerSheetbuilder = buildSpritesheet.from<typeof demonSpriteMeta>(demonSpriteMeta)
</script>
```

In this example, there is a single sprite image containing 4 different animations. The metadata is contained within the
`demonSpriteMeta` object, which describes the layout and animation details of the spritesheet.

In this case, the spritesheet image is arranged in a grid of 4 rows and 8 columns, so the `type` is set to `'rowColumn'`,
`height` to `4` (indicating the number of rows), and `width` to `8` (representing the number of columns).
The `animations` property is an array, where each element represents a separate animation with a `name` and a `frameRange`.

For detailed information on defining animations and using frame ranges, refer to the [Spritesheet builder section](/docs/reference/extras/instanced-sprite#spritesheetmetadata)

### Adding component to the scene

```svelte title=Flyer.svelte
{#await flyerSheetbuilder.spritesheet then spritesheet}
  <InstancedSprite
    count={20000}
    {spritesheet}
  >
    <!-- User component for updating instances -->
    <UpdaterFlying /> /
    <!-- -->
  </InstancedSprite>
{/await}
```

We add `<InstancedSprite>` to the scene with a `count` `spritesheet` - the only required props. Spritesheet is a result of the promise from the previous step.

To add the `<InstancedSprite>` component to the scene, you need to specify at least two essential properties:
`count` and `spritesheet`. The `spritesheet` property is the object obtained as the result of awaiting the Promise of the `buildSpritesheet` function called earlier.

### Updating instances

In our example, the user made `<FlyingBehaviour>` component is responsible for updating sprites.
This component leverages the `useInstancedSprite()` hook, which makes it easy to access and
adjust sprite properties such as position and animation.

To update sprite instances, we utilize the `useTask` hook. Inside, a loop iterates over the IDs
of all instances, applying updates to their positions and assigning the fly animation to each.
This description is simplified for brevity, this is where you'd have your complex movement or game logic.
A working example, demonstrating basic random movement, is available in the source of the live example for this component
(UpdaterFlying.svelte, UpdaterWalking.svelte, UpdaterFlyingHook.svelte).

```svelte title=FlyingBehaviour.svelte
<script lang="ts">
  import { useTask } from '@threlte/core'
  import { useInstancedSprite } from '@threlte/extras'

  const { updatePosition, count, animationMap, sprite } = useInstancedSprite()

  useTask(() => {
    for (let i = 0; i < count; i++) {
      updatePosition(i, [0, 0, 0])
      sprite.animation.setAt(i, 'fly')
    }
  })
</script>
```

## Instancing approaches

This section goes over each component used in the scene and provides a short explanation of different approaches used with `<InstancedSprite/>` component.
Every component is designed differently, aimed to present varied approaches to updating instance properties, loading and defining spritesheets.

### From json

`DudeSprites.svelte` adds sprites with random walk to the scene. One of them is controlled by the player with the use of `WASD` keys.
This example uses an untyped `useInstancedSprite()` hook within the `WalkingBehaviour.svelte` component to update the sprites.

### One file, many animations

`FlyerSprites.svelte` is the sprite from the first section where we went over step by step how to work with the component.
Here, the spritesheet is constructed using the `buildSpritesheet.from` utility, defining multiple animations within a single sprite file.

Although this setup does not initially add TypeScript autocompletion of animation names, an alternative version found in
`FlyerSpritesTyped.svelte` addresses this.

### Multiple files, one animation per

`GoblinSprites.svelte` builds a spritesheet from multiple files, each of them containing a single animation. Similar to the
flyers, this example uses the `buildSpritesheet.from` utility.
Instances remain stationary but frequently change their animation. Direct updates to the animation are made through the `InstancedSpriteMesh`,
accessed via a `ref` binding.

### Static

The example in `TreeSpriteAtlas.svelte` demonstrates the setup of static sprites, as outlined in [Static sprites & Atlassing](/docs/reference/extras/instanced-sprite#static-sprites--atlassing).

Each frame is named and used as a different tree sprite, selected at random. Then, the playmode is set to "PAUSE," and auto-updates are disabled,
ensuring that each sprite remains fixed. In this case, the `<Instance/>` component is used for setting positions and frames.


================================================
File: apps/docs/src/content/examples/camera/camera-controls.mdx
================================================
You may have come up against limitations with Three.js's `<OrbitalControls/>`.
[Camera Controls](https://github.com/yomotsu/camera-controls) is a suitable alternative
which supports smooth transitions and a variety of additional features.

<Example path="camera/camera-controls" />

The `CameraControls` class in the example _extends_ the camera-controls library's
`CameraControls` class.

It automatically installs `camera-controls` if not already installed when a new instance is created and connects the instance to the `element` passed into its constructor.

## Updating the Controls

Updating the controls happens in a task in the `<Scene>` component.

The controls are disposed when the `<Scene>` component unmounts. This is an important step because it removes all the event listeners that are added when the CameraControls instance is created and connected to the dom.

You could put both of these actions in the constructor of the `CameraControls` class if you didn't want to do it in the component but be careful using threlte's [`useTask`](/docs/reference/core/use-task) since it accesses context set up by the [`<Canvas>`](/docs/reference/core/canvas) component.

### Prevent SSR Externalization

If you are using SvelteKit or Vite for building your app, you may need to externalize the `camera-controls` library.

To externalize the `camera-controls` library put the following in your `vite-config.js` or `vite-config.ts`.

```typescript {4-6}+
// vite-config.ts
export default defineConfig({
  plugins: [sveltekit()],
  ssr: {
    noExternal: ['camera-controls']
  }
})
```

<Tip type="info">
  The camera-controls package features include first-person, third-person, pointer-lock,
  fit-to-bounding-sphere and much more!
</Tip>


================================================
File: apps/docs/src/content/examples/games/Arcade machine.mdx
================================================
---
category: Games
title: Arcade Machine
---

The Arcade machine was introduced during a previous major revision of threlte.
It involes sounds, global state, custom rendering and basic scene transitions.
Give it a whirl, copy parts, remix it - have fun 😄

<Example path="core/three-arcade-game" />


================================================
File: apps/docs/src/content/examples/geometry/Random Placement.mdx
================================================
---
category: Geometry
title: Random Scenery
showInSidebar: false
---

This example explores several simple ways to automatically position objects in your scene. This is a great starting point if you want to procedurally generate terrain or other scenes. Taking these methods as a starting point, you'll hopefully be able to find the approach that suits your project.

<Tip type="note">
  Manually placing objects is also a good enough approach in many projects. A hybrid approach
  involves starting out with random scenery, and then saving all the object properties to create a
  static scene from it.
</Tip>

## Basic Random

The simplest starting point is using [Math.random](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random) as is. Every object will be independently placed, this is called a [uniform distribution](https://en.wikipedia.org/wiki/Continuous_uniform_distribution).
Starting with a plane, a couple of svelte's `{#each ... as ...}` blocks and some random numbers; you can position objects like in the simple scene below.

<Example path="geometry/random-placement/basic-random" />

## Preventing Object Overlap

There is a limitation in using _just_ `Math.random`: it does not prevent objects from overlapping. This means that sometimes you'll see a tree growing from a rock, or two bushes growing into each other.

In order to prevent this you can use [Poisson disk sampling](https://medium.com/@hemalatha.psna/implementation-of-poisson-disc-sampling-in-javascript-17665e406ce1). This algorithm guarantees a minimum distance between your objects.

<Example
  path="geometry/random-placement/poisson-random"

/>

If you reduce the minimum distance to something smaller than your objects size then there will _look_ like there's collisions. For the bushes in this example, even a distance of 1 still looks good.

## Different object sizes

In many scenes this approach works well. However, sometimes you'll want different spacing for different objects: a large tree needs more space than a small bush. Below is a variation of poisson disc sampling, but this time it allows for some different spacing, depending on the object type.

<Example
  path="geometry/random-placement/variable-poisson-random"

/>

<Tip type="info">
  An important parameter to play with when generating scenes with this last approach is the *window
  size*. It is inferred from the difference between the largest and smallest radius given. You'll
  need to play around with the details if your usecase starts running into performance issues
  because of this algorithm.
</Tip>


================================================
File: apps/docs/src/content/examples/geometry/Rendering Points.mdx
================================================
<Example path="geometry/points" />

### Using Points

<Tip type="tip">
  Points work in Threlte the same way they do in Three. Check three docs about
  [Points](https://threejs.org/docs/#api/en/objects/Points) and [Point
  Material](https://threejs.org/docs/?q=Point#api/en/materials/PointsMaterial) to learn more.
</Tip>

#### Ensuring Points Work Correctly with BufferGeometry

For your points to function correctly, it's essential that they have an associated
BufferGeometry with a specified attribute for point positions.
Here's a straightforward method using the default Threlte approach:

```svelte
<T.Points>
  <T.BufferGeometry>
    <T.BufferAttribute
      args={[positions, 3]}
      attach={({ parent, ref }) => {
        parent.setAttribute('position', ref)
        return () => {
          // cleanup function called when ref changes or the component unmounts
          // https://threlte.xyz/docs/reference/core/t#attach
        }
      }}
    />
  </T.BufferGeometry>
  <T.PointsMaterial size={0.25} />
</T.Points>
```

In the case of `<T.BufferAttribute>`, it is not enough to make it a child of `<T.BufferGeometry>`. To actually link it,
you must invoke the attach method. If you skip this step, the attribute
won't be associated with the geometry. [Learn more about how attach works.](/docs/reference/core/t#attach)

Alternatively, you can also define and manage BufferGeometry within `<script>` tags or
in an external file. Once done, the `<T>` component allows for direct attachment
to `<T.Points>`, like so:

```svelte
<T.Points>
  <T is={pointsBufferGeometry} />
  <T.PointsMaterial size={0.25} />
</T.Points>
```

Working code for this approach can be found in `SceneAlternative.svelte` file of this example.


================================================
File: apps/docs/src/content/examples/geometry/Terrain with 3D noise.mdx
================================================
Noise is often used in graphics and game development to create "smooth randomness".

Three.js has a SimplexNoise addon that can be used for this purpose. In the example below, it is used to generate a smooth random surface.

<Example path="geometry/terrain" />

## Setting the Height of Each Vertex

After the geometry is created, the z-value of each vertex's position is set with a value generated from the noise function.

```typescript
const noise = new SimplexNoise()

for (let i = 0; i < positions.count; i += 1) {
  const x = positions.getX(i) / flatness
  const y = positions.getY(i) / flatness
  positions.setZ(i, noise.noise(x, y))
}
```

The `flatness` variable scales down the `x` and `y` values that are passed to the noise function. A higher `flatness` value corresponds to smaller changes between noise values thus a flatter surface.

<Tip type="warning">
  When updating attributes of a geometry after the first render, you may have to set
  `attribute.needsUpdate` to `true`. It may also be necessary to recalculate the geometry's vertex
  normals using `geometry.computeVertexNormals()`.
</Tip>

## Rotating the Geometry

One important thing to note is that the plane geometry is created in the xy-plane. This is why the z-value is treated as the height of the vertex and the geometry is rotated 90 degrees. The Z-up coordinate system is very common to see especially in such areas as structural design and 3D-printing.

## Deterministic Noise Values

`SimplexNoise.noise` is deterministic. In other words, when given the same `x` and `y`, the output is always the same. If you want to produce different results, you can offset the `x` and `y` inputs by some amount.

```typescript {4}+ {6-7}
const noise = new SimplexNoise()

$effect(() => {
  const randomOffset = Math.random()
  for (let i = 0; i < positions.count; i += 1) {
    const x = positions.getX(i) / flatness + randomOffset
    const y = positions.getY(i) / flatness + randomOffset
    positions.setZ(i, noise.noise(x, y))
  }

  // ...
})
```


================================================
File: apps/docs/src/content/examples/geometry/Terrain with Rapier physics.mdx
================================================
This example shows how to include user-generated random terrain as a fixed [`<RigidBody>`](/docs/reference/rapier/rigid-body), within a Rapier world.

This is an adaption of Rapier's [own demo](https://rapier.rs/demos3d/index.html) (select "Demo: triangle mesh").

<Example path="geometry/physics-terrain" />

## How Does It Work

A heightmap is generated by looping over the vertices of a plane geometry. The height information is passed to a [`<Collider>`](/docs/reference/rapier/collider) and wrapped in a `<RigidBody>`.

```svelte
<RigidBody type="fixed">
  <Collider
    shape="heightfield"
    args={[nsubdivs, nsubdivs, heights, scale]}
  />
</RigidBody>
```

Giving the `<RigidBody>` a `"fixed"` type prevents it from being affected by gravity.

In the `<FallingShapes>` component, a bunch of random geometries are positioned above the plane and dropped. Each geometry is wrapped in a `<RigidBody>` with a type of `"dynamic"`. This will cause it to be affected by gravity.


================================================
File: apps/docs/src/content/examples/marching-cubes/LavaLamp.mdx
================================================
A small [MarchingCubes](https://en.wikipedia.org/wiki/Marching_cubes) example using [three.js's marching cubes addon](https://threejs.org/examples/webgl_marchingcubes.html).

<Example path="marching-cubes/lava-lamp" />

The addon is a little too limited to be ported into a component but this example shows how it might be incorporated into threlte.

## Placement

`MarchingCubes` defines a space from -1 to 1 for all 3 axes.

### MarchingPlane

The original example only allows for planes positioned at x = -1, y = -1, and z = -1.

### MarchingCube

`<MarchingCube>`s can be placed anywhere in the `MarchingCubes` space. If they are placed outside this range they may be cutoff or not show altogether.

<Tip type="info">
  Even though `MarchingCube` appears as a ball, it is called __Cube__ to be inline with [drei's
  MarchingCubes abstration](https://drei.docs.pmnd.rs/abstractions/marching-cubes).
</Tip>

## Materials

The example above utilizes vertex coloring but the original three.js example has support for any kind of material. Vertex coloring requires a little more memory since each vertex now carries a color with it. If you're not using vertex colors, you can leave `enableColors` turned off. The `<MarchingCubes>` component uses the same default material that `Three.Mesh`es do. Setting different materials is the same process as setting different materials for `<T.Mesh>`.

```svelte
<MarchingCubes>
  <T.MeshNormalMaterial />
  <T is={cube} />
</MarchingCubes>
```

If you're using a material with a texture, you will need to set `enableUvs` to true.

```svelte
<MarchingCubes enableUvs>
  <T.MeshNormalMaterial map={texture} />
  <MarchingCube />
</MarchingCubes>
```

Note that the example above enables both uvs and vertex coloring for demonstration purposes. You can set these to false in the constructor to save on space.

```svelte title="MarchingCubes.svelte" {5}
<script>
  // ...

  // don't allocate space for vertex colors nor uvs
  const marchingCubes = new MarchingCubes(resolution, material, false, false, 20_000)

  // ...
</script>
```


================================================
File: apps/docs/src/content/examples/meshline/Cursor Lines.mdx
================================================
This example was inspired by [OGL's Polyline example](https://oframe.github.io/ogl/examples/?src=polylines.html). It uses [`<MeshLineMaterial>`](/docs/reference/extras/meshline-material) and [`<MeshLineGeometry>`](/docs/reference/extras/meshline-geometry) to create a similar effect.

<Tip type="tip">
  This effect is probably better implemented as a fragment shader but the example highlights some
  interesting and effective techniques for various threlte components and functions.
</Tip>

<Example path="meshline/cursor-lines" />

## How Does it Work?

First we create a scene with an orthographic camera and a mesh. The mesh's only purpose is to capture pointer move events so it needs to be big enough to fill the entire screen. The mesh is placed in front of the camera. It doesn't really matter the exact position of the mesh because an orthographic camera has no perspective. All that really matters it is in fron of the camera and there is space inbetween the camera and the mesh - this is where the mesh lines will be drawn.

```svelte
<T.OrthographicCamera
  zoom={50}
  makeDefault
/>

<T.Mesh
  scale={100}
  visible={false}
  position.z={-10}
>
  <T.PlaneGeometry />
</T.Mesh>
```

The camera is positioned at the origin and the mesh is positioned down the z-axis.

### Getting the Cursor Position

To get the cursor position we use Threlte's [interactivity](/docs/reference/extras/interactivity) plugin. The event object that is passed to the `onpointermove` callback has a point property which tells you where the cursor position was when the event was triggered. The cursor position is updated and sent into the `<CursorLine>` component as a prop.

```svelte
<script lang="ts">
  const cursorPosition = new Spring<Vector3Tuple>([0, 0, 0])
  interactivity()
</script>

<T.Mesh
  onpointermove={(event) => {
    cursorPosition = event.point.toArray()
  }}
>
  <!-- ...  -->
</T.Mesh>
```

### Inside the CursorLine Component

The `<CursorLine>` component receives the current pointer position. To create the "trailing" effect two lists of `Vector3` points are created - a back and a front. Each frame, the back set of points is updated then swapped with the front set of points. This swap causes anything that reads from the front set of points to get updated.

#### Making Use of $state.raw

The reason that two sets of points are used is so that [`$state.raw`](https://svelte.dev/docs/svelte/$state#$state.raw) can be used. `$state.raw` is great when you have a large object such as an array and you don't want to make the object deeply reactive. In our case we know we're only ever going to be updating everything in the array all at once and nothing depends on updates to the individual objects in the array. In other words, we only care about when the entire array updates, specific when `front` updates. The back set of points doesn't need to be made reactive at all because nothing is listening to it.

#### Updating Points

Before the back and front points are swapped, the points are updated. The first point in the array is set to the current value of the spring.

```typescript
back[0].fromArray(spring.current)
```

Then each consecutive pair of points, `[first, secend]` is taken and the second point is interpolated to the first by a small amount. This update happens every frame and eventually all points are interpolated to the cursor position.

```typescript
useTask((delta) => {
  const alpha = 1e-6 ** delta
  for (let i = 1; i < count; i += 1) {
    const first = back[i - 1]
    const second = back[i]
    second?.lerp(first, alpha)
  }
  // ...
})
```

<Tip type="info">
  The value for `alpha` is a little arbitrary but certain values may look may appealing than others.
  For example, if `alpha` is > 1, the lerp will overshoot and you'll get very "jumpy" interpolations
  that won't ever settle. You also don't want the value to be too small because then it won't
  interpolate quickly enough to look "smooth". An value somewhere around `.8` gives a good look and
  feel.
</Tip>

Lastly the two point-lists are swapped which triggers anything reading `front` to update.

```typescript
useTask((delta) => {
  //...
  const temp = front
  front = back
  back = temp
})
```

In summary, we update the "back" set of points and swap it with the "front" once all points have been updated. This is very similar to a the double-buffering strategy used by many graphics software.

A "getter" for the points is available in the `children` snippet so that its current value can be used.

```svelte
<CursorLine>
  {#snippet children({ getPoints })}
    <MeshLineGeometry
      points={getPoints()}
      shape="taper"
    />
    <MeshLineMaterial attenuate={false} />
  {/snippet}
</CursorLine>
```


================================================
File: apps/docs/src/content/examples/postprocessing/Outlines.mdx
================================================
Implements the Outline postprocessing pass. [Vanilla threejs example here](https://threejs.org/examples/?q=outline#webgl_postprocessing_outline)

An outlined cube loops through a maze, with a different outline color when the object is hidden.

<Example path="postprocessing/outline" />

## How it Works

A mesh is created in `App.svelte` and passed into both `Scene.svelte` and `CustomRenderer.svelte`.

### Scene

The scene is responsible for setting up the walls, floor, and attaching a geometry and material to the mesh while the custom renderer adds the mesh to the outline effects selection set.

### CustomRenderer

Both passes that are added to the composer rely on the camera from the threlte context so they can are derived anytime the camera changes. When either of the passes updates, the composer's passes are reset and the updated passes are added to the composer.


================================================
File: apps/docs/src/content/examples/postprocessing/ScreenQuad.mdx
================================================
This example demonstrates a well-known technique for doing simple postprocessing utilizing a "screen-quad". Mouse around the canvas to see the effect.

<Example path="postprocessing/screen-quad" />

## Overview

The basic idea of postprocessing is to draw the scene to a frame-buffer that can then be sent into another shader. The output of this shader is used as the texture or material for a mesh that covers the screen. To do this we need two things:

1. a webgl render target
2. a separate scene from the one that threlte provides

The [`useFBO`](/docs/reference/extras/use-fbo) hook returns a render target. This will be what we render the main scene to every frame and pass into the fragment shader as a texture.

A separate scene is needed so that we can add the screen-quad mesh to it and render it. The idea is that the only thing in this scene will be the screen-quad mesh that has the post-processed scene as its material. This mesh can't be added to the main scene because it would cause a circular dependency.

So the steps are as follows:

1. render the "main" scene to the render target.
2. render the separate scene.

There are some sub-steps inbetween but these are the two important bits that happen in the `useTask` callback in the `<Scene>` component.

## ScreenQuadGeometry

This component creates a right triangle such that its right angle is positioned in the lower-left of the canvas. The size of the triangle is such that the hypotenuse only touches the top-right corner of the canvas. The triangle is in clip-space so we need a special vertex shader to use it.

The vertex shader string is exported from the `<ScreenQuadGeometry>` component to be used with either a `Three.RawShaderMaterial` or `Three.ShaderMaterial`.

## Scene

There are a few notable techniques in the `<Scene>` component.

Firstly, The screen-quad mesh is not frustrum culled. This is because the geometry is so simple that culling it would actually requare more work. If you culled its geometry, you'd actually be creating more vertices.

This `<T.Mesh>` uses threlte's `attach` prop to add it to the secondary scene instead of the default scene created by threlte.

Secondly, the render task that threlte automatically uses is disabled and a custom render task is used instead. This is explained on the [`useTask`](/docs/reference/core/use-task) page.

Lastly, the uvs are used in the fragment shader to use as an index into the scene texture. For this reason, the resolution of the canvas is sent into the shader as a uniform. An effect is ran to keep the uniform in sync with the current size of the canvas.


================================================
File: apps/docs/src/content/examples/renderers/CSS2DRenderer Overlay.mdx
================================================
---
title: CSS2DRenderer Overlay
---

This example shows how to run an additional Three.js renderer in parallel with
Threlte's `<Canvas>`, while still leveraging Threlte's built-in elements.
Specifically, we'll run
[CSS2DRenderer](https://threejs.org/docs/index.html#examples/en/renderers/CSS2DRenderer)
to add flat labels to objects in a three-dimensional scene.

This example can be easily adapted to use
[CSS3DRenderer](https://threejs.org/docs/index.html#examples/en/renderers/CSS3DRenderer)
instead, if you want the elements to live "inside" the scene, rather than flat
across the surface.

<Example path="renderers/CSS2DRenderer" />

## How does it work?

In this scene, we run two renderers - the default one provided by Threlte, and a
new CSS2DRenderer which we initialize manually. Threlte's renderer runs on a
canvas element as usual, while our new renderer runs in a `<div>` with absolute
positioning on top of it.

### The render loop

To integrate the a new renderer into svelte's loop, we call it inside a task
added right _after_ [Threlte's
`autoRenderTask`](/docs/learn/basics/scheduling-tasks#default-tasks). For
details on how to use the _Threlte Task Scheduling System_, see the
[documentation](/docs/learn/basics/scheduling-tasks).

By default, each renderer traverses the scene and updates every object. We can
set
[scene.matrixWorldAutoUpdate](https://threejs.org/docs/#api/en/core/Object3D.matrixAutoUpdate)
to false and manually call `scene.updateMatrixWorld()` each tick in order to
avoid duplicating the work, since we're running two renderers. To do that, we're
adding a task that runs right _before_ Threlte's `autoRenderTask`.

```svelte title="Scene.svelte"
<script>
  const { scene, size, autoRenderTask, camera } = useThrelte()

  // Set up the CSS2DRenderer to run in a div placed atop the <Canvas>
  const element = document.querySelector('#css-renderer-target') as HTMLElement
  const cssRenderer = new CSS2DRenderer({ element })
  $: cssRenderer.setSize($size.width, $size.height)

  // We are running two renderers, and don't want to run
  // updateMatrixWorld twice; tell the renderers that we'll handle
  // it manually.
  // https://threejs.org/docs/#api/en/core/Object3D.updateWorldMatrix
  scene.matrixWorldAutoUpdate = false

  // To update the matrices *once* per frame, we'll use a task that is added
  // right before the autoRenderTask. This way, we can be sure that the
  // matrices are updated before the renderers run.
  useTask(
    () => {
      scene.updateMatrixWorld()
    },
    { before: autoRenderTask }
  )

  // The CSS2DRenderer needs to be updated after the autoRenderTask, so we
  // add a task that runs after it.
  useTask(
    () => {
      // Update the DOM
      cssRenderer.render(scene, camera.current)
    },
    {
      after: autoRenderTask,
      autoInvalidate: false
    }
  )
</script>
```

### Setting up CssObject

The other integral part is a component that accepts DOM contents in the default
slot and places them in the scene and renders them with the ThreeJS
`CSS2DRenderer`:

```svelte title="CssObject.svelte"
<script>
  import { T } from '@threlte/core'
  import { CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer.js'

  export let pointerEvents = false

  let element
</script>

<div
  bind:this={element}
  style:pointer-events={pointerEvents ? 'auto' : 'none !important'}
  style:will-change="transform"
>
  <slot />
</div>

{#if element}
  <T
    {...$$restProps}
    is={CSS2DObject}
    args={[element]}
  />
{/if}
```

This component renders children into a div, and allows nested Threlte components
via the `three` slot. It passes all other properties through, letting us use it
like so:

```svelte
<CssObject
  position={[-1, 2, 1]}
  center={[-0.2, 0.5]}
>
  <CounterLabel label="Hello" />

  <T.Mesh slot="three">
    <T.SphereGeometry args={[0.25]} />
    <T.MeshStandardMaterial color="#4F6FF6" />
  </T.Mesh>
</CssObject>
```

where `<CounterLabel>` is a normal Svelte component outside Threlte's control,
but the mesh is a component inside the scene hooked in with `slot="three"`.


================================================
File: apps/docs/src/content/examples/shaders/Interactive shader.mdx
================================================
In this tutorial, we'll walk you through the process of configuring a shader-based material while leveraging Threlte's built-in interactivity plugin. Specifically, you'll learn how to dynamically adjust material uniforms based on user interactions—such as clicking on the mesh.

<Example path="shaders/interactiveShader" />

## How does it work?

We'll start this example by utilizing the mesh terrain established in one of our other examples, [Terrain with 3D noise](/docs/examples/geometry/terrain-with-3d-noise), as our foundational starting point.

### The Shader Material

To integrate the shader-based material into your terrain mesh, simply nest the `<T.ShaderMaterial/>` component as a child element. It's essential to supply both `fragmentShader` and `vertexShader` props, formatted as strings.

In our example, these shaders are isolated into individual files — `fragment.glsl` for the fragment shader and `vertex.glsl` for the vertex shader. These files are imported using Vite's `?raw` special query which imports them as raw strings. Although your build tool and setup might differ, this modular approach enhances code readability. Alternatively, you could provide these shaders directly as JavaScript strings.

```svelte title="Scene.svelte" {2-3}+ {10-13}+
<script>
  import fragmentShader from './fragment.glsl?raw'
  import vertexShader from './vertex.glsl?raw'
</script>

<T.Mesh
  {geometry}
  rotation.x={DEG2RAD * -90}

  <T.ShaderMaterial
    {fragmentShader}
    {vertexShader}
  />
</T.Mesh>
```

### Terrain Interactivity

In this step, we set up interactivity for the Terrain Mesh. The aim is to trigger a shader animation when the user clicks on the mesh, thereby updating its variables in real-time.

To accomplish this, we first import and initialize the [interactivity](/docs/reference/extras/interactivity) plugin from `@threlte/extras`. This extends the functionality of meshes by enabling `onclick` events, akin to the familiar HTML events in Svelte. For our animation, it's crucial to pinpoint the exact location where the user clicks on the mesh.
The event generated by the plugin conveniently provides us with a `point` variable to identify this location.

```svelte title="Scene.svelte" {2,3}+ {9-11}+
<script>
  import { interactivity } from '@threlte/extras'
  interactivity()
</script>

<T.Mesh
  {geometry}
  rotation.x={DEG2RAD * -90}
  onclick={({ point }) => {
    console.log('user clicked on', point)
  }}
>
  <T.ShaderMaterial
    {fragmentShader}
    {vertexShader}
  />
</T.Mesh>
```

### Shader Interactivity

With event listeners now active on our mesh, the next step is to capture these events into variables and forward them to the shader as uniforms.
Our shader will require two uniform variables: one for the click position (`pulsePosition` as a Vector3) and another for tracking the
animation timeline (`pulseTimer`).

To manage the timeline, we'll employ a Svelte store using the [Tween](https://svelte.dev/docs/svelte-motion#Tween) class.
Both `pulsePosition` and `pulseTimer` will be updated in the `onclick` event callback.

Configuring uniforms for our `ShaderMaterial` is straightforward and closely aligns with standard Three.js practices.
To update the `pulseTimer` and `pulsePosition` uniform value, we'll use a pierced property: `uniforms.pulseTimer.value={pulseTimer.current}`.

```svelte title="Scene.svelte" {2-8}+ {15-22}+ {28-37}+
<script>
  import { Tween } from 'svelte/motion'
  import { quadOut } from 'svelte/easing'

  const pulsePosition = new Vector3()
  const pulseTimer = new Tween(0, {
    easing: quadOut
  })
</script>

<T.Mesh
  {geometry}
  rotation.x={DEG2RAD * -90}
  onclick={({ point }) => {
    pulsePosition.copy(point)
    pulseTimer
      .set(0, {
        duration: 0
      })
      .then(() => {
        pulseTimer.set(1, { duration: 2000 })
      })
  }}
>
  <T.ShaderMaterial
    {fragmentShader}
    {vertexShader}
    uniforms={{
      pulseTimer: {
        value: 0
      },
      pulsePosition: {
        value: 0
      }
    }}
    uniforms.pulsePosition.value={pulsePosition}
    uniforms.pulseTimer.value={pulseTimer}
  />
</T.Mesh>
```

### How do the Fragment and Vertex shaders work?

While a deep dive into shader mechanics falls beyond the scope of this tutorial, let's take a moment for a brief conceptual overview:

1. **Vertex Shader**: At its core, we have a straightforward vertex shader that forwards the world position of the material to the fragment shader. This is achieved using a `varying vPosition` variable, along with UV coordinates transferred through a `varying vUv` variable.
2. **Fragment Shader and User Interaction**: Armed with knowledge of the material's world position, we can dynamically render a circle originating from the `pulsePosition` uniform, which is set by the user's click event. As time progresses, the circle's radius expands, controlled by the `pulseTimer` uniform.

If you want to learn more about how to write shaders, the [Book of Shaders](https://thebookofshaders.com/) is an excellent resource to start with.


================================================
File: apps/docs/src/content/examples/shaders/Scope with zoom.mdx
================================================
This example shows how to utilize useFBO hook to create a sniper scope zoom effect, complete
with lens distortion and crosshairs.

<Example path="shaders/useFboScope" />

## How does it work?

The hook is used to render a scene onto a texture, using
it in a shader. The [WebGLRenderTarget](https://threejs.org/docs/#api/en/renderers/WebGLRenderTarget) texture
from [useFBO](/docs/reference/extras/use-fbo) hook is used in the scope where a
vignette and lens distortion effects are applied and a reticle is added.

### Scene setup

The scene is constructed using two free models sourced from Sketchfab:
a piece of terrain and a scope model. These models are converted into Svelte components using the
[Threlte gltf CLI tool](/docs/reference/gltf/getting-started) tool.

The scope model is attached directly to the `<PerspectiveCamera>` so that both move in sync with
the user's mouse movements. A circular mesh is positioned as a child of the scope and serves as an eyepiece -
this is where the custom ShaderMaterial is used for simulating the view through the scope.

Control over the scope - activation, movement and pointer-lock toggling — is managed within a `Controls.svelte` file.

### Rendering the scene to a texture

The [useFBO](/docs/reference/extras/use-fbo) hook is used to prepare a render target for the scope's view texture.
Given that the scope's viewport occupies only a fraction of the full screen,
the texture's resolution is appropriately downscaled to conserve resources.

A `useTask` hook is used to render the scene onto this target:

```ts
const renderTarget = useFBO($size.width * 0.5, $size.height * 0.5, {
  samples: 8
})

let scope: Group

useTask(() => {
  if (!scope || !$scoping) return
  const cam = $camera as PerspectiveCamera

  scope.visible = false
  cam.fov = $zoomedFov
  cam.updateProjectionMatrix()
  cam.matrixWorldNeedsUpdate = true
  renderer.setRenderTarget(renderTarget)
  renderer.render(scene, cam)

  renderer.setRenderTarget(null)
  cam.fov = baseFov
  cam.updateProjectionMatrix()
  scope.visible = true
})
```

Here's what happens step by step:

1. The scope's visibility is set to `false` to prevent it from appearing in the texture capture.
2. The camera's field of view (`fov`) is adjusted, and its projection matrix is updated to apply current zoom level.
3. The renderer's target is switched to the one created by the useFBO hook.
4. The scene is rendered from the perspective of the adjusted camera.
5. The renderer's target is reset to `null` for rendering to the screen again, and the camera's FOV is restored to its
   original setting, with the scope becoming visible again.

### Scope shader

The shader for the scope's view employs two textures: the rendered scene texture and a reticle image.

Inside the shader:

- **UV adjustment**: To accommodate different screen sizes and the circular shape of the scope, UV coordinates are adjusted for proper mapping of the view texture onto the scope.
- **Cubic lens distortion**: The scene texture is distorted using a cubic lens effect to simulate the optical characteristics of a real scope.
- **Vignetting**: A vignette effect is applied to the distorted scene texture, darkening the edges around the scope.
- **Crosshair overlay**: The reticle texture is blended with the modified scene texture, adding the crosshair overlay to the scope's view.


================================================
File: apps/docs/src/content/learn/advanced/custom-abstractions.mdx
================================================
---
category: Advanced
title: Custom Abstractions
order: 1
---

A lot of the components you will find in the package
[@threlte/extras](/docs/reference/extras/getting-started) are abstractions on
top of the [`<T>` component](/docs/reference/core/t). These abstractions provide
extra functionality like automatically invalidating the frame or providing
default values or extra props.

A common use case for custom abstractions is to create a component that is a
fixed entity in your Threlte app which you want to reuse in multiple places or
which exposes a specific behavior. As an example, let's create a component that
is made up from multiple `<T>` components resembling a tile of some kind:

```svelte title="Tile.svelte"
<script>
  import { T } from '@threlte/threlte'
  import { MathUtils } from 'three'

  let { children } = $props()
</script>

<T.Group>
  <!-- 2x2 Tile -->
  <T.Mesh rotation.x={-90 * MathUtils.DEG2RAD}>
    <T.PlaneGeometry args={[2, 2]} />
    <T.MeshStandardMaterial />
  </T.Mesh>

  {@render children()}
</T.Group>
```

Let's see what implementing that component looks like:

```svelte title="Scene.svelte"
<script>
  import Tile from './Tile.svelte'
</script>

<Tile />
```

## Props

The `<Tile>` component is now available in the scene and can be reused as many
times as you want.

Now we'd like to assign a different `position` to every `<Tile>` in order to
position it in the scene. We can do that by passing a `position` prop to the
`<Tile>` component:

```svelte title="Scene.svelte"
<script>
  import Tile from './Tile.svelte'
</script>

<Tile position={[0, 0, 0]} />
<Tile position={[2, 0, 0]} />
<Tile position={[4, 0, 0]} />
```

That doesn't work _yet_. The component `<Tile>` internally needs to make use of
the `position` prop to set the position of its children. We can do that by
[spreading `props` on the `<T.Group>`](https://svelte.dev/tutorial/spread-props)
component at the root hierarchy of `<Tile>`:

```svelte title="Tile.svelte" {5}m
<script>
  import { T } from '@threlte/threlte'
  import { MathUtils } from 'three'

  let { children, ...props } = $props()
</script>

<T.Group {...props}>
  <!-- 2x2 Floor -->
  <T.Mesh rotation.x={-90 * MathUtils.DEG2RAD}>
    <T.PlaneGeometry args={[2, 2]} />
    <T.MeshStandardMaterial />
  </T.Mesh>

  {@render children()}
</T.Group>
```

## Types

<Tip type="info">The following section assumes you use TypeScript.</Tip>

The last thing we need to do is to add types to our custom abstraction so that
IDEs like VS Code can provide autocompletion and type checking. We will create a
`types.ts` file next to the `Tile.svelte` file and add the following content:

```ts title="types.ts"
import type { Props } from '@threlte/core'
import type { Group } from 'three'

export type TileProps = Props<Group>
```

<Tip type="tip">
  As of now it's necessary to declare the props in a separate file.
	If you declare them inside the `<script>` block, the Svelte compiler
	flattens the resulting type, removing JSDoc comments and possibly
	breaking it.
</Tip>

The generic type `Props<Type>` is a utility type that extracts all possible
props that a `<T>` component accepts – in this case `<T.Group>`. It also creates
a _bindable `ref` prop_ that can be used to bind to the group created by the
`<T.Group>` component.

We need to import the `TileProps` type in our `Tile.svelte` file and make use of
the `ref` prop. For that we:

- Add the `lang="ts"` attribute to the `<script>` block
- Import the `TileProps` type
- Add the bindable prop `ref` to the props
- Bind `ref` to the bindable prop `ref` of the root `<T.Group>` component
- Pass `ref` to the `children()` block

```svelte title="Tile.svelte" {4,11}+ {1,6,19}m
<script lang="ts">
  import { T } from '@threlte/threlte'
  import { MathUtils } from 'three'
  import type { TileProps } from './types'

  let { children, ref = $bindable(), ...props }: TileProps = $props()
</script>

<T.Group
  {...props}
  bind:ref
>
  <!-- 2x2 Floor -->
  <T.Mesh rotation.x={-90 * MathUtils.DEG2RAD}>
    <T.PlaneGeometry args={[2, 2]} />
    <T.MeshStandardMaterial />
  </T.Mesh>

  {@render children({ ref })}
</T.Group>
```

Now we can use the `<Tile>` component in our scene and get autocompletion and
type checking.

```svelte title="Scene.svelte"
<script>
  import Tile from './Tile.svelte'
  import { TransformControls } from '@threlte/extras'
</script>

<Tile position={[2, 0, 2]}>
  {#snippet children({ ref })}
    <TransformControls object={ref} />
  {/snippet}
</Tile>
```


================================================
File: apps/docs/src/content/learn/advanced/migration-guides.mdx
================================================
---
category: More
title: Migration Guides
order: 2
---

## Threlte 8

Threlte 8 adds Svelte 5 support and removes Svelte 4 support.

This upgrade contains bug fixes, better average performance, smaller bundle size, and an improved development experience.

There are a few notable breaking changes listed below.

### Automatic Disposal

[Automatic disposal](/docs/learn/basics/disposing-objects) has been improved to
only dispose of objects that are referenced by a `<T>` component. Objects are no
longer scanned recursively for disposable objects.

```svelte
<script>
  import { T } from '@threlte/core'
  import { useTexture } from '@threlte/extras'

  const map = useTexture('/some/texture.png')
</script>

{#if $map}
  <T.Mesh>
    <T.BoxGeometry />
    <T.MeshBasicMaterial map={$map} />
  </T.Mesh>
{/if}
```

In this example, Threlte 7 also disposed of the texture when the material
unmounted. This is no longer the case in Threlte 8. This change is introduced to
improve performance and to make the behavior of automatic disposal more
intuitive. When looking at simple examples like the one above, this might seem
like a regression, but with scale the previous approach of deeply recursive
automatic disposal was hard to reason about and a performance bottleneck.

### Plugin API

The plugin API has been changed to allow for greater granularity and a reactivity model that is in-line with Svelte 5.

#### `createPlugin` has been removed

Threlte 7 included a function called `createPlugin` that allowed to separate a
plugin declaration from its implementation. The recommended way to create
plugins is to export a function that invokes `injectPlugin`:

```ts
import { injectPlugin } from '@threlte/core'

export const createSomePlugin = (pluginArg: string) => {
  injectPlugin('some-plugin', () => {
    // ... Plugin Code
  })
}
```

This plugin can now be implemented like this:

```svelte title="Scene.svelte"
<script>
  import { createSomePlugin } from '$plugins'

  createSomePlugin('plugin-arg')
</script>
```

#### Plugin callbacks have been removed

In Threlte 7, plugins could return an object with several callback functions
that were invoked when:

- `ref` changed
- any prop changed (e.g. `makeDefault`, `dispose`, `attach`, etc.)
- any "rest" prop changed (e.g. `position`, `color`, etc.)

```ts title="Threlte 7"
injectPlugin('some-plugin', ({ ref, props }) => {
  return {
    onRefChange(newRef) {
      // ...
    },
    onPropsChange(props) {
      // ...
    },
    onRestPropsChange(restProps) {
      // ...
    }
  }
})
```

These callbacks have been removed. Instead, you can use the first argument of the plugin
callback, which is a reactive object containing all properties needed:

```ts title="Threlte 8"
injectPlugin('some-plugin', (args) => {
  args.ref
  args.makeDefault
  args.args
  args.attach
  args.manual
  args.makeDefault
  args.dispose
  args.props // All other props declared on the component
})
```

The `args` object is reactive and will update whenever any of the referenced values change.

<Tip type="info">
  A plugin may still return an object with `pluginProps` to specify which props
	the `<T>` component should not react to.
</Tip>

### Events

Events will no longer work, and have been replaced with callback props.

```svelte {2,3}m
<T.Mesh
  onclick={onClick}
  onpointerenter={onPointerEnter}
>
  <T.BoxGeometry />
  <T.MeshStandardMaterial />
</T.Mesh>
```

The signature of the `oncreate` callback prop has changed. Instead of receiving an object with a cleanup function,
you may now return a cleanup function that will run when the object is destroyed or its args change. This is more in-line with other apis in svelte 5 and threlte.

```svelte
<T.Mesh
  oncreate={(ref) => {
    return () => {
      console.log('cleanup')
    }
  }}
>
  <T.BoxGeometry />
  <T.MeshStandardMaterial />
</T.Mesh>
```

The `createRawEventDispatcher` and `forwardEventHandlers` exports will no longer work.

Instead of dispatching events with `createRawEventDispatcher`, invoke callback props.

```svelte
<script lang="ts">
  import { T } from '@threlte/core'
  import { OrbitControls } from '@threlte/extras'

  type Props = {
    onchange?: () => void
  }

  let { onchange }: Props = $props()

  onchange?.()
</script>

<T.PerspectiveCamera makeDefault>
  <OrbitControls {onchange} />
</T.PerspectiveCamera>
```

Instead of using `forwardEventHandlers`, pass rest props
to the component you wish to forward events to.

```svelte
<script>
  let { ...rest } = $props()
</script>

<T.Mesh {...rest}>
  <T.BoxGeometry />
  <T.MeshBasicMaterial />
</T.Mesh>
```

This will pass the new callback props mentioned in the previous section down the tree of components.

### Attach API & Trait Components

The signature and heuristic of the attach API of the `<T>` component has
changed. The trait components `<HierarchicalObject>` and `<SceneGraphObject>`
have been removed.

#### `attach` Function Signature

```svelte
<!-- Threlte 7 -->
<T.Mesh
  attach={(parent, self) => {
    console.log('attaching', parent, self)
    return () => {
      console.log('detaching', parent, self)
    }
  }}
/>

<!-- Threlte 8 -->
<T.Mesh
  attach={({ ref, parent, parentObject3D }) => {
    console.log('attaching', ref, parent, parentObject3D)
    return () => {
      console.log('detaching', ref, parent, parentObject3D)
    }
  }}
/>
```

#### `attach={false}`

If `false` is passed to the `attach` prop, the component will not be automatically attached to
the parent object. This is useful if you want to attach the component manually.

```svelte
<!-- "Dangling" component -->
<T
  is={mesh}
  attach={false}
/>
```

#### `attach={object3D}`

If an object3D instance is passed to the `attach` prop, the component will be attached to the instance, essentially acting as a portal.

<Tip type="warning">Be aware that the component still acts in the given context of the parent.</Tip>

```svelte
<!-- Attached to the provided object -->
<T
  is={mesh}
  attach={object3D}
/>
```

### Snippets

Slot props will no longer work, and must be replaced with snippets.
For example, the following components from Threlte 7 would need to be migrated from this:

```svelte
<T.PerspectiveCamera let:ref>
  <T.OrbitControls
    args={[ref, renderer.domElement]}
    on:change={invalidate}
  />
</T.PerspectiveCamera>
```

...to this:

```svelte
<T.PerspectiveCamera>
  {#snippet children({ ref })}
    <T.OrbitControls
      args={[ref, renderer.domElement]}
      onchange={invalidate}
    />
  {/snippet}
</T.PerspectiveCamera>
```

Any component that previously exposed a slot prop using the `let:` directive can follow this new pattern.

### Canvas component `size` prop

The `size` property on the `<Canvas>` component that allowed setting specific pixel dimensions has been removed.
To set a specific size of your `<Canvas>`, simply wrap it in an HTML element with your desired dimensions.

```svelte
<div style="width: 500px; height: 300px;">
  <Canvas>
    <Scene />
  </Canvas>
</div>
```

### Canvas component `rendererParameters` prop

The `renderParameters` canvas prop has been replaced with a more powerful `createRenderer` function.

If you need to manually set renderer parameters, call the function and return a renderer.

```svelte
<Canvas
  createRenderer={(canvas) => {
    return new WebGLRenderer({
      canvas,
      alpha: true,
      powerPreference: 'high-performance',
      antialias: false,
      depth: false,
      premultipliedAlpha: false
    })
  }}
>
  <Scene />
</Canvas>
```

Any Three renderer can be returned when calling `createRenderer`.

### Transitions

The transitions plugin currently does not work, we're working towards a new
transition system.

### `useGltf` and `<GLTF>`

`useGltf` and `<GLTF>` no longer contain a built-in `DracoLoader`, `KTX2Loader`, or `MeshoptDecoder`.
Instead, separate hooks can be imported and passed to these tools, improving their bundle size and flexibility.

```ts
import { useGltf, useDraco, useKtx2, useMeshopt } from '@threlte/extras'

const dracoLoader = useDraco()
const ktx2Loader = useKtx2()
const meshoptDecoder = useMeshopt()

const gltf = useGltf('./path/to/model.glb', {
  dracoLoader,
  ktx2Loader,
  meshoptDecoder
})
```

For more information, see the [`useGltf`](/docs/reference/extras/use-gltf) and [`GLTF`](/docs/reference/extras/gltf) docs.

### Rapier

#### Two Stage Physics

In order to enable fixed frame physics, the Rapier package is introducing two
[scheduler stages](/docs/learn/basics/scheduling-tasks#stages). So in the most
simple physics implementation:

```svelte
<Canvas>
  <World>
    <Scene />
  </World>
</Canvas>
```

The scheduler plan will look like this:

```txt
scheduler
├─ threlte-main-stage
├─ simulation
│  └─ simulation
├─ synchronization
│  └─ synchronization
└─ threlte-render-stage
```

[Tasks](/docs/learn/basics/scheduling-tasks#tasks) that are added to the
`simulation` stage will be executed according to the set
[framerate](/docs/reference/rapier/framerate), i.e. the delta provided in these
tasks corresponds to the delta time between physics frames. Tasks added to the
`synchronization` stage will be executed after all tasks of the `simulation`
stage have been executed, the delta is the regular `requestAnimationFrame` frame
delta. The stages and tasks are available as part of the `RapierContext` with the `useRapier` hook:

```ts
import { useTask } from '@threlte/core'
import { useRapier } from '@threlte/rapier'

const { simulationTask } = useRapier()

useTask(
  () => {
    // E.g. interact with the physics world here
  },
  {
    before: simulationStage
  }
)
```

#### BasicPlayerController has been removed

The `BasicPlayerController` component has been removed. If you need a player
controller, Rapier comes with a pre-made, easy to implement [Character
Controller](https://rapier.rs/docs/user_guides/javascript/character_controller).
It's more powerful and flexible than the old component.

The reason is stated in rapier's documentation as well:

> Despite the fact that this built-in character controller is designed to be
> generic enough to serve as a good starting point for many common use-cases,
> character-control (especially for the player's character itself) is often very
> game-specific. Therefore the builtin character controller may not work
> perfectly out-of-the-box for all game types.

#### `oncreate` event signature

The `oncreate` event signature available on `<RigidBody>`, `Collider` and
`<AutoColliders>` has been adapted to match the `oncreate` prop on `<T>`.

```svelte
<RigidBody
  oncreate={(ref) => {
    // ref is the created RigidBody instance
    return () => {
      // cleanup function
    }
  }}
>
  <!-- ... -->
</RigidBody>
```

## Threlte 7

Threlte 7 introduces a new _Task Scheduling System_ that allows you to easily
orchestrate the task execution order of your Threlte application. For details on
how to use it, see the [documentation](/docs/learn/basics/scheduling-tasks).
Before, you had the option to choose between `useFrame` and `useRender` to
orchestrate your rendering pipeline. These hooks are currently still available
but will be removed in the next major version of Threlte. This guide will help
you migrate your application to the new Task Scheduling System.

This update also slightly changes the signature of the `<Canvas>` component as
well as the Threlte context.

Also, to increase performance we're enforcing the use of constant prop types
on the `<T>` component.

### Constant prop types on `<T>`

The `<T>` component now enforces the use of _constant prop types_. This means
that the type of a certain prop value must not change in the lifetime of a
component. See this example:

```svelte title="Threlte 6"
<script>
  import { T } from '@threlte/core'

  let position = [0, 0, 0]

  const changePosition = () => {
    position = 1
  }
</script>

<T.Mesh {position} />
```

When `changePosition` is invoked, the prop type of the prop `position` changes
from an array of numbers to a number. This is not allowed anymore in Threlte 7.
Prop types must be constant. It's a highly unlikely scenario that rarely occurs
and a rather bad practice to start with, which allows us to optimize the
performance of the `<T>` component by enforcing this rule. This is how you would
migrate the above example:

```svelte title="Threlte 7" {7}m
<script>
  import { T } from '@threlte/core'

  let position = [0, 0, 0]

  const changePosition = () => {
    position = [1, 1, 1]
  }
</script>

<T.Mesh {position} />
```

### Threlte context

### `<Canvas>` props

#### `frameloop`

`frameloop` is now called `renderMode` as it only affects the rendering of your
Threlte application. It accepts nearly the same values as before:

```ts title="Threlte 6"
<Canvas frameloop="always" />
<Canvas frameloop="demand" />
<Canvas frameloop="never" />
```

```ts title="Threlte 7"
<Canvas renderMode="always" />
<Canvas renderMode="on-demand" />
<Canvas renderMode="manual" />
```

If the value is `always`, Threlte will render your scene on every frame. If the
value is `on-demand`, Threlte will only render your scene when a re-render is
needed. If the value is `manual`, Threlte will never render your scene
automatically and you have to trigger a re-render by calling `advance()` on the
Threlte context available via `useThrelte()`.

#### `autoRender`

When `autoRender` is `false`, Threlte will not render your scene automatically
and will enable you to implement a custom render pipeline using the hook
[`useTask`](/docs/reference/core/use-task). If adding a task to render the scene
to Threlte's
[`renderStage`](/docs/learn/basics/scheduling-tasks#default-stages), the task
will only be called in respect to the `renderMode` prop. Previously, this
behavior was inferred from the usage of the `useRender` hook, but we think being
explicit here is better.

### `useFrame`

The hook [`useTask`](/docs/reference/core/use-task) replaces `useFrame`. It has
a slightly different signature and allows you to to add a `task` to Threlte's
_Task Scheduling System_. A task may have dependencies to other tasks, which you
can think of as the big brother of the `order` option of `useFrame`.

#### Callback Arguments

The callback to `useTask` now only receives the delta time since the last frame.
The Threlte context previously available as the first argument to the callback
of `useFrame` should be retrieved using the hook
[`useThrelte`](/docs/reference/core/use-threlte).

```ts title="Threlte 6"
useFrame(({ camera, scene }, delta) => {
  // The Threlte context was previously available as the first
  // argument to the callback, followed by the delta time since the
  // last frame.
})
```

```ts title="Threlte 7"
const { camera, scene } = useThrelte()
useTask((delta) => {
  // The delta time since the last frame is the only
  // argument to the callback.
})
```

#### `autostart` and `invalidate`

The options of `useTask` have been renamed to better reflect their purpose. The
`autostart` option is now called `autoStart` (note the **capital 'S'**),
`invalidate` is now called `autoInvalidate`.

#### If you didn't use the `order` option

Replace `useFrame` with `useTask` and adapt accessing the Threlte context.

```ts title="Threlte 6"
useFrame(({ camera, scene }, delta) => {
  // ...
})
```

```ts title="Threlte 7"
const { camera, scene } = useThrelte()
useTask((delta) => {
  // ...
})
```

#### If you used the `order` option

Migrate to `useTask` by referencing the key of the task you want to depend on.

```ts title="Threlte 6"
useFrame(
  (_, delta) => {
    // This task will be executed first
  },
  { order: 0 }
)

useFrame(
  (_, delta) => {
    // This task will be executed second
  },
  { order: 1 }
)
```

```ts title="Threlte 7"
useTask('first', (delta) => {
  // ...
})

useTask(
  'second',
  (delta) => {
    // This task will be executed after the task with the
    // key 'first' has been executed.
  },
  { after: 'first' }
)
```

### `useRender`

The hook [`useTask`](/docs/reference/core/use-task) also replaces `useRender`.
Previously, `useRender` allowed you to define a callback that was invoked after
all `useFrame` callbacks have been invoked to render your scene with a custom
render pipeline. This is now possible with `useTask` as well. Threlte provides a
[`renderStage`](/docs/learn/basics/scheduling-tasks#default-stages) that only
ever executes its tasks when a re-render is needed. A task added to this stage
can be used to render your scene. Be sure to set the option `autoInvalidate` to
`false` to prevent Threlte from automatically invalidating the render stage.

```ts title="Threlte 6"
useRender(() => {
  // Render your scene here
})
```

```ts title="Threlte 7"
const { renderStage } = useThrelte()
useTask(
  'render',
  () => {
    // Render your scene here
  },
  { stage: renderStage, autoInvalidate: false }
)
```

#### Callback Arguments

The callback to `useTask` now only receives the delta time since the last frame.
The Threlte context previously available as the first argument to the callback
of `useRender` should be retrieved using the hook
[`useThrelte`](/docs/reference/core/use-threlte).

```ts title="Threlte 6"
useRender(({ camera, scene }, delta) => {
  // The Threlte context was previously available as the first
  // argument to the callback, followed by the delta time since the
  // last frame.
})
```

```ts title="Threlte 7"
const { camera, scene } = useThrelte()
useTask((delta) => {
  // The delta time since the last frame is the only
  // argument to the callback.
})
```

#### If you didn't use the `order` option

Replace `useFrame` with `useTask` and adapt accessing the Threlte context.

```ts title="Threlte 6"
useRender((_{ camera, scene }_, delta) => {
  // ...
})
```

```ts title="Threlte 7"
const { renderStage } = useThrelte()
useTask(
  (delta) => {
    // ...
  },
  { stage: renderStage, autoInvalidate: false }
)
```

#### If you used the `order` option

Migrate to `useTask` by referencing the key of the task you want to depend on.

```ts title="Threlte 6"
useRender(
  (_, delta) => {
    // This task will be executed first
  },
  { order: 0 }
)

useRender(
  (_, delta) => {
    // This task will be executed second
  },
  { order: 1 }
)
```

```ts title="Threlte 7"
const { renderStage } = useThrelte()

useTask(
  'first',
  (delta) => {
    // ...
  },
  { stage: renderStage, autoInvalidate: false }
)

useTask(
  'second',
  (delta) => {
    // This task will be executed after the task with the
    // key 'first' has been executed.
  },
  { after: 'first', stage: renderStage, autoInvalidate: false }
)
```

## Migrating from Threlte 5 to Threlte 6

Threlte 6 provides a much more mature and feature-rich API and developer experience than
its predecessor at the cost of a lot of breaking changes. This guide will help you migrate
your Threlte 5 project to Threlte v6.

### Preprocessing

Preprocessing is not needed anymore starting from Threlte 6. This means you
may remove the preprocessor `@threlte/preprocess` from your project as well as its
configuration in `svelte.config.js`. You can now use the [component `<T>`](/docs/reference/core/t) directly.

### `<Three>` is now `<T>`

Threlte 6 merges the `<Three>` and `<T>` components into a single component. The property `type` was renamed to `is`
to also properly reflect the fact that it can be used with already instantiated objects.

### `@threlte/core` is only about the `<T>` component

The `@threlte/core` package is now only about the `<T>` component. It does not provide any abstractions
that have been part of the core package before. _Some_ of these abstractions (`<TransformControls>`,
`<OrbitControls>`, audio components and several hooks) have been moved to `@threlte/extras` as this is the new
home for commonly used abstractions.

### Prop types

Threlte 6 heavily relies on prop types that Three.js naturally understands. As such, the prop types you may have
previously used to define for example the position of an object changed. Threlte v5 provided its own prop types
`Position` (e.g. `{ x, y, z }`), `Rotation` and others which are now removed or deprecated. While not yet all
abstractions fully make use of the new prop types, we're working on it. Your editor should be able to provide
you with the correct prop types for the components you're using.

### Interactivity

Interactivity is now handled by a plugin that's available at `@threlte/extras`. It's much more mature and flexible
in terms of event handling. For instance – as some of you requested – you may now define on what object the main
event listener is placed. Check out [its documentation](/docs/reference/extras/interactivity) to learn more.

### `useLoader` now returns a store

The hook [`useLoader`](/docs/reference/core/hooks#useloader) now returns a custom Svelte store called
[`AsyncWritable`](/docs/reference/core/utilities#asyncwritable). This store allows you to [await](https://svelte.dev/tutorial/await-blocks)
the loading of the resource while also implementing a regular Svelte store. It also now caches the results
of the loader function so that it's not called multiple times for the same resource. You will most likely
benefit from quite a performance boost in applications that rely heavily on external resources.

### `useThrelteRoot` has been removed

The hook `useThrelteRoot` has been removed and its properties have partially been merged into `useThrelte` as well as
a new internal context which is not exposed. All other contexts (which were used internally) have also been merged or removed.

### `<Pass>` and the default effects rendering are removed

In the effort of clear separation of concerns, the component `<Pass>` as well as the rendering with Three.js default
`EffectComposer` have been removed. Threlte 6 now provides a hook called [`useRender`](/docs/reference/core/hooks#userender) which
allows you to easily set up sophisticated rendering pipelines. As soon as a `useRender` hook is implemented, Threlte's
default render pipeline is disabled. `useRender` callbacks will be invoked _after_ all callback to `useFrame` have been
invoked. This means that you can use `useFrame` to update your objects and `useRender` to render it. `useRender` also has the option of
ordering callbacks to orchestrate the rendering pipeline across multiple components.

### Threlte's main context types

Thelte's main context contains Svelte stores. These stores are now a custom Threlte store called
[`CurrentWritable`](/docs/reference/core/utilities#currentwritable) which is a store that contains a `current` value with
a reference to the current value of the store. This means it does not need to be unwrapped manually (and expensively!) in
non-reactive places such as loops. For instance, let's have a look at its usage in the hook
[`useFrame`](/docs/reference/core/hooks#useframe) where the context is available as the first argument
to the callback:

```ts
useFrame(({ camera, colorSpace }) => {
  // instead of get(camera) we now can …
  camera.current // THREE.Camera
  colorSpace.current // THREE.ColorSpace
})
```

The full type definition is [currently listed here](/docs/reference/core/hooks#usethrelte).

### `useGltfAnimations` Signature

The signature of the hook `useGltfAnimations` has changed. It no longer provides a callback that is invoked
when the `gltf` store has been populated and the `actions` store has been set. This is because it with the option to set
a custom root for the `THREE.AnimationAction`, the callback could be triggered multiple times, leading to an
unpredictable behavior. You should reside to using the `actions` store returned from the hook instead.

```ts
const { actions } = useGltfAnimations(gltf)
// this animation will play when the gltf store has been populated
// and the actions store has been set, effectively replacing the
// callback.
$: $actions.Greet?.play()
```

Check out the [hooks documentation](/docs/reference/extras/use-gltf-animations) for more information.

### `@threlte/rapier`

#### Transform props

In an effort to clearly separate concerns, the components `<Collider>`, `<AutoColliders>` and `<RigidBody>` **no longer
offer transform props** (`position`, `rotation`, `scale` and `lookAt`). Instead, you should wrap these components
in for instance `<T.Group>` components and apply transforms on these.

```svelte title="Before.svelte" {2,3}-
<Collider
  position={[0, 1, 0]}
  rotation={[0, 45 * DEG2RAD, 0]}
>
  <T.Mesh>
    <T.BoxGeometry />
    <T.MeshStandardMaterial />
  </T.Mesh>
</Collider>
```

```svelte title="After.svelte" {1-4,11}+
<T.Group
  position={[0, 1, 0]}
  rotation={[0, 45 * DEG2RAD, 0]}
>
  <Collider>
    <T.Mesh>
      <T.BoxGeometry />
      <T.MeshStandardMaterial />
    </T.Mesh>
  </Collider>
</T.Group>
```


================================================
File: apps/docs/src/content/learn/advanced/plugins.mdx
================================================
---
title: Plugins
category: Advanced
order: 0
---

Plugins allow you to extend Threlte's [`<T>`](/docs/reference/core/t)
component. They can be used to add props, event handlers, custom logic and
customize the component instance. You can think of a plugin as code that
is injected into every child `<T>` component.

Plugins can be overridden in child components.

The [interactivity plugin in
`@threlte/extras`](/docs/reference/extras/interactivity) is an example of what a
plugins can do and there are a couple of other examples below.

## When to use a Plugin

A plugin has access to all props and the lifecycle of the `<T>` component.

Use it to:

- add custom props to the `<T>` component such as [`lookAt`](#lookat).

- add custom logic to the `<T>` component, such as automatically add helpers for
  certain objects in DEV mode.

- collect object references from child components for app-wide systems such as
  an ECS.

- build custom integrations for external libraries.

<Tip type="tip" title="When to use oncreate">

[`<T>`'s `oncreate`](/docs/reference/core/t#create-event) shares some
similarities to a plugin but only has access to the object referenced by the
`<T>` component. Also, it has to be defined on every `<T>` component
individually.

You can think of `oncreate` as a [Svelte
Action](https://svelte.dev/docs/svelte/use) for `<T>` components. Use it for
one-time setup logic that does not need access to the component's props.

</Tip>

## Injecting a Plugin

Plugins are _injected_ to a plugin context and are **accessible to all child
`<T>` components**.

```svelte title="Scene.svelte"
<script>
  import { injectPlugin } from '@threlte/core'
  import myPlugin from './myPlugin'
  import OtherComponent from './OtherComponent.svelte'

  injectPlugin('my-plugin', myPlugin)
</script>

<!--
This component is affected by the plugin 'my-plugin'
-->
<T.Mesh />

<!--
<T> components in this component are
also affected by the plugin 'my-plugin'
-->
<OtherComponent />
```

### What it looks like

Plugins open up the component `<T>` to external code that will be injected via
context into every child instance of a `<T>` component. The callback function
receives a **reactive `args` object** that contains the `ref` of the respective
`<T>` component, all base props (`makeDefault`, `args`, `attach`, `manual`,
`makeDefault` and `dispose`) and all props (anything else) passed to it.

```ts
import { injectPlugin } from '@threlte/core'

injectPlugin('plugin-name', (args) => {
  console.log(args.ref) // e.g. a Mesh
  console.log(args.props) // e.g. { position: [0, 10, 0] }
})
```

If a plugin decides via `args.ref` or `args.props` analysis that it doesn't need
to act in the context of a certain `<T>` component, it can return early.

```ts
import { injectPlugin, isInstanceOf } from '@threlte/core'

injectPlugin('raycast-plugin', (args) => {
  if (!isInstanceOf(args.ref, 'Object3D') || !('raycast' in args.props)) return
})
```

The code of a plugin **acts as if it would be part of the `<T>` component
itself** and has access to all properties. A plugin can run arbitrary code in
lifecycle functions such as `onMount`, `onDestroy` and effects.

```ts
import { injectPlugin } from '@threlte/core'
import { onMount } from 'svelte'

injectPlugin('plugin-name', (args) => {
  // Use lifecycle hooks as if it would run inside a <T> component.
  // This code runs when the `<T>` component this plugin is injected
  // into is mounted.
  onMount(() => {
    console.log('onMount')
  })

  // Use any prop that is defined on the <T> component, in this
  // example `count`: <T.Mesh count={10} />
  const count = $derived(args.props.count ?? 0)

  $effect(() => {
    // This code runs whenever count changes.
    console.log(count)
  })

  return {
    // Claiming the property "count" so that the <T> component
    // does not act on it.
    pluginProps: ['count']
  }
})
```

A Plugin can also _claim properties_ so that the component `<T>` does not act on it.

```ts
import { injectPlugin } from '@threlte/core'

injectPlugin('ecs', () => {
  return {
    // Without claiming the properties, <T> would apply the
    // property to the object.
    pluginProps: ['entity', 'health', 'velocity', 'position']
  }
})
```

Plugins are passed down by context and can be overridden to prevent the effects of a plugin for a certain tree.

```ts
import { injectPlugin } from '@threlte/core'

// this overrides the plugin with the name "plugin-name" for all child components.
injectPlugin('plugin-name', () => {})
```

### Creating a Plugin

Plugins can also be _created_ for external consumption. This creates a _named plugin_. The name is used to identify the plugin and to override it.

```ts
import { createPlugin } from '@threlte/core'

export const layersPlugin = createPlugin('layers', () => {
  // ... Plugin Code
})
```

```ts
// somewhere else, e.g. in a component

import { injectPlugin } from '@threlte/core'
import { layersPlugin } from '$plugins'

injectPlugin(layersPlugin)
```

## Examples

### `lookAt`

This is en example implementation that adds the property `lookAt` to all `<T>` components, so that `<T.Mesh lookAt={[0, 10, 0]} />` is possible:

<Example path="plugins/lookAt" />

### BVH Raycast Plugin

A Plugin that implements [BVH raycasting](https://github.com/gkjohnson/three-mesh-bvh) on all child meshes and geometries.

```ts title="bvhRaycasting.svelte.ts"
import { injectPlugin, isInstanceOf } from '@threlte/core'
import type { BufferGeometry, Mesh } from 'three'
import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh'

const bvhRaycasting = () => {
  injectPlugin('bvh-raycast', (args) => {
    $effect(() => {
      if (isInstanceOf(args.ref, 'BufferGeometry')) {
        args.ref.computeBoundsTree = computeBoundsTree
        args.ref.disposeBoundsTree = disposeBoundsTree
        args.ref.computeBoundsTree()
      }
      if (isInstanceOf(args.ref, 'Mesh')) {
        args.ref.raycast = acceleratedRaycast
      }
      return () => {
        if (isInstanceOf(args.ref, 'BufferGeometry')) {
          args.ref.disposeBoundsTree()
        }
      }
    })
  })
}
```

Implementing this plugin in your Scene:

```svelte title="Scene.svelte"
<script lang="ts">
  import { T } from '@threlte/core'
  import bvhRaycasting from './plugins/bvhRaycasting.svelte'

  bvhRaycasting()
</script>

<T.Mesh>
  <T.MeshBasicMaterial />
  <T.BoxGeometry />
</T.Mesh>
```

## TypeScript

Using TypeScript, we can achieve **end-to-end type safety for plugins**, from
the plugin implementation to the props of the `<T>` component. The example below
shows how to type the props of the [`lookAt` plugin](#lookat) so that the prop
`lookAt` is strictly typed on the `<T>` component as well as in the plugin
implementation.

### Typing a Plugin

The function `injectPlugin` accepts a type argument that you may use to type the
props passed to a plugin.

```ts
injectPlugin<{ lookAt?: [number, number, number] }>('lookAt', (args) => {
  // args.props.lookAt is now typed as [number, number, number] | undefined
})
```

### Typing the `<T>` Component Props

By default, the custom props of plugins are not present on the types of the
`<T>` component. You can however extend the types of the `<T>` component by
defining the `Threlte.UserProps` type in your ambient type definitions. In a
typical SvelteKit application, you can find these type definitions [in
`src/app.d.ts`](https://svelte.dev/docs/kit/types#app.d.ts).

```ts title="src/app.d.ts"
declare global {
  namespace App {
    // interface Error {}
    // interface Locals {}
    // interface PageData {}
    // interface PageState {}
    // interface Platform {}
  }

  namespace Threlte {
    interface UserProps {
      lookAt?: [number, number, number]
    }
  }
}

export {}
```

The prop `lookAt` is now available on the `<T>` component and is typed as
`[number, number, number] | undefined`.

```svelte title="Svelte.svelte"
<script lang="ts">
  import { T } from '@threlte/core'
</script>

<!-- This is now type safe -->
<T.Mesh lookAt={[0, 10, 0]} />

<!-- This will throw an error -->
<T.Mesh lookAt="this object please" />
```

<Tip type="tip">
  As soon as your app grows in size, you should consider moving these type these type definitions to
  a separate file and merge all available props to a single type definition. This type may then be
  used by `injectPlugin` as well as your ambient type defintions.
</Tip>


================================================
File: apps/docs/src/content/learn/advanced/webgpu.mdx
================================================
---
category: Advanced
title: WebGPU and TSL
order: 1
---

<Tip type="experimental">
  The WebGPU specification is still in active development. WebGPU support in Three.js is in an early
  stage and is subject to frequent breaking changes. As of now, we do not recommend using WebGPU in
  production.
</Tip>

<Tip type="warning">
  We highly recommend targeting [version r171](https://github.com/mrdoob/three.js/releases/tag/r171)
  onwards because of potential [duplication and configuration
  issues](https://github.com/mrdoob/three.js/pull/29404).
</Tip>

## WebGPU

To use Three.js's WebGPU renderer, import it and then initialize it within your
`<Canvas>`'s `createRenderer` prop.

```svelte title="App.svelte" {4}+ {8-14}+
<script>
  import Scene from './Scene.svelte'
  import { Canvas } from '@threlte/core'
  import { WebGPURenderer } from 'three/webgpu'
</script>

<Canvas
  createRenderer={(canvas) => {
    return new WebGPURenderer({
      canvas,
      antialias: true,
      forceWebGL: false
    })
  }}
>
  <Scene />
</Canvas>
```

<Tip type="note">
  WebGPU is still an experimental browser api and at the time of writing has [limited availability
  across major browsers](https://caniuse.com/?search=webgpu). For this reason, Three.js's webgpu
  renderer fallbacks to webgl when webgpu is not available.
</Tip>
<Tip type="tip">
  This same approach can be used to swap out the default renderer for any other custom renderer.
</Tip>

<Example path="renderers/WebGPU" />

<small>
  Adapted from [this Three.js
  example](https://threejs.org/examples/?q=webgpu#webgpu_performance_renderbundle).
</small>

The WebGPU renderer doesn't immediately render. If the renderer you provide needs to delay rendering, you
can defer rendering by initially setting the renderMode to `manual` like so:

```svelte title="App.svelte"
<script>
  import { Canvas, T } from '@threlte/core'
  import { WebGPURenderer } from 'three/webgpu'
  let renderMode = $state('manual')
</script>

<Canvas
  {renderMode}
  createRenderer={(canvas) => {
    const renderer = new WebGPURenderer({
      canvas,
      antialias: true,
      forceWebGL: false
    })
    renderer.init().then(() => {
      renderMode = 'on-demand'
    })
    return renderer
  }}
>
  <Scene />
</Canvas>
```

### Vite

WebGPU uses top-level async to determine WebGPU compatibility. Vite
will often throw an error when it detects this.

To circumvent this issue, the following can be added to your Vite config.

```js
// vite.config.js
optimizeDeps: {
  esbuildOptions: {
    target: 'esnext'
  }
},
build: {
  target: 'esnext'
}
```

Alternatively,
[`vite-plugin-top-level-await`](https://github.com/Menci/vite-plugin-top-level-await)
can be used, although less success has been reported with this method.

## TSL

A question that comes up often in Three.js development is "How do I extend Three.js's materials?".
External libraries such as [three-custom-shader-material](https://www.npmjs.com/package/three-custom-shader-material)
use a find and replace solution to get this job done. Three.js has identified
that it's not an ideal solution and recommends using the [Three.js Shading Language](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language) or TSL for short.

The example below is an adaptation of [this](https://threejs.org/examples/?q=tsl#webgpu_tsl_angular_slicing)
Three.js example. There are many more [TSL examples](https://threejs.org/examples/?q=tsl)
within Three.js that you can use or adapt for your project.

<Example path="shaders/slice/main" />

### Using the \<T> catalogue

The `<T>` component uses all the exports from `three`. It will error on things like
`<T.MeshPhysicalNodeMaterial />` because the `MeshPhysicalNodeMaterial` class is an
export of `three/webgpu` not `three`. You have a few options to work this out.

1. Extend `<T>` with all the definitions from `three/webgpu` by using the [`extend`](/docs/reference/core/t#extending-the-default-component-catalogue)
   function. Adding all of the definitions will increase the bundle size of your application because both `three` and `three/webgpu` will be imported in a non-tree-shakeable way.

```svelte title="App.svelte" {3-4}+ {6}+
<script>
  import Scene from './Scene.svelte'
  import { Canvas, extend } from '@threlte/core'
  import * as THREE from 'three/webgpu'

  extend(THREE)
</script>

<Canvas
  createRenderer={(canvas) => {
    return new THREE.WebGPURenderer({
      canvas,
      antialias: true,
      forceWebGL: false
    })
  }}
>
  <Scene />
</Canvas>
```

2. Use explicit imports for the objects, functions, and other classes that you use from `three/webgpu`.
   You can then use `<T>`'s [`is`](/docs/reference/core/t#property-is) prop with those imports from `three/webgpu`.

```svelte title="Scene.svelte" {3}+ {5}+ {10}+
<script>
  import { T } from '@threlte/core'
  import { MeshPhysicalNodeMaterial } from 'three/webgpu'

	const material = new MeshPhysicalNodeMaterial()
</script>

<T.Mesh>
	<T.BoxGeometry>
	<T is={material}>
</T.Mesh>
```

3. Same as option #2 but using [`extend`](/docs/reference/core/t#extending-the-default-component-catalogue) with the imports so that you can have `<T.MeshPhysicalNodeMaterial />` etc...

```svelte title="App.svelte" {3-4}+ {6}+
<script>
  import Scene from './Scene.svelte'
  import { Canvas, extend } from '@threlte/core'
  import { WebGPURenderer, MeshPhysicalNodeMaterial } from 'three/webgpu'

  extend({ MeshPhysicalNodeMaterial })
</script>

<Canvas
  createRenderer={(canvas) => {
    return new WebGPURenderer({
      canvas,
      antialias: true,
      forceWebGL: false
    })
  }}
>
  <Scene />
</Canvas>
```

```svelte title="Scene.svelte"
<script>
  import { T } from '@threlte/core'
</script>

<T.Mesh>
  <T.BoxGeometry />
  <T.MeshPhysicalNodeMaterial />
</T.Mesh>
```

Options 2 and 3 will keep the bundle size of your application small but you'll have to keep it updated as you go.

#### Careful! `three` and `three/webgpu` don't mix well

You will need to overwrite some of the default `<T>` catalogue if you use `three/webgpu`.
For example, if you're using a `MeshPhysicalNodeMaterial`, you need to update any lighing classes you use like so:

```svelte title="App.svelte"
<script>
  import { DirectionalLight, MeshPhysicalNodeMaterial } from 'three/webgpu'

  // tell <T.DirectionalLight> to use the definition from `three/webgpu`
  extend({ MeshPhysicalNodeMaterial, DirectionalLight })
</script>

<Canvas>
  <Scene />
</Canvas>
```

```svelte title="Scene.svelte"
<script>
  import { T } from '@threlte/core'
</script>

<T.DirectionalLight />

<T.Mesh>
  <T.BoxGeometry />
  <T.MeshPhysicalNodeMaterial />
</T.Mesh>
```

This is because the exports from `three/webgpu` are different than those in `three` and make use of the additional features that node materials have.

<Tip type="tip">
  An easy option for projects is to start with option #1 and then transition to the other options
  when bundle size becomes an issue or you need to ship to production.
</Tip>

### Nodes

The [nodes](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#nodematerial) can be directly assigned like any other prop on the `<T>` component.

```svelte
<T.MeshPhysicalNodeMaterial
  outputNode={Fn(([arg1, arg2]) => {
    /* ... */
  })(arg1, arg2)}
  shadowNode={Fn(([arg1, arg2]) => {
    /* ... */
  })(arg2, arg2)}
/>
```

Node materials give you the ability to modify three's builtin materials.
In the sliced gear example, two nodes are modified; the `outputNode` and the `shadowNode`.
The `outputNode` is set up in such a way that it discards any fragments that are
outside the permitted `startAngle` and `arcAngle`. If a fragment is not discarded and
it is not front-facing, it is assigned the color in the `color` uniform. The material
needs its `side` set to `THREE.DoubleSide` otherwise three.js will cull them out if they are facing away
from the camera,

Any fragment that is discarded in the shadowNode will not cast shadows.

### Updating Uniforms

If your node uses uniforms, they can be declared in the `script` tag of
the component and updated via `$effect` or a callback.

For example, if your material uses elapsed time in a uniform, you can update the
uniform inside a `useTask` callback.

The material in the example below demonstrates two ways to update uniforms. The `uTime` uniform
is updated in `useTask` whereas `uIntensity` is updated in an `$effect`.

<Example path="shaders/slice/updatingUniforms" />

<Tip type="info">
  Note that TSL has an
  [`oscSine`](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#oscillator) function
  that oscillates on time that could also be used in the example above.
</Tip>


================================================
File: apps/docs/src/content/learn/basics/app-structure.mdx
================================================
---
category: Basics
title: App Structure
order: -900
---

Threlte makes heavy use of [Svelte's Context
API](https://svelte.dev/tutorial/context-api) as a way to pass data through the
component tree without having to pass props down manually at every level:

```svelte title="SomeComponent.svelte"
<script>
  const { camera, renderer } = useThrelte()
</script>
```

To let Threlte do its magic, we recommend to follow our best practices for
structuring your app.

## Recommended App Structure

The [`<Canvas>`](/docs/reference/core/canvas) component provides all basic contexts in a Threlte application.
The recommended app structure is to have a single child component of `<Canvas>` (typically named "Scene.svelte" in examples) for
your Threlte app. This will allow contexts provided by `useThrelte` and other hooks to be used.

```svelte title="App.svelte"
<script>
  import { Canvas } from '@threlte/core'
  import Scene from './Scene.svelte'
</script>

<Canvas>
  <Scene />
</Canvas>
```

```svelte title="Scene.svelte"
<script>
  import { T, useTask } from '@threlte/core'
  import { interactivity } from '@threlte/extras'
  import Player from './Player.svelte'
  import World from './World.svelte'

  let rotation = 0

  // useTask is relying on a context provided
  // by <Canvas>. Because we are definitely *inside*
  // <Canvas>, we can safely use it.
  useTask((delta) => {
    rotation += delta
  })

  // This file is also typically the place to
  // inject plugins
  interactivity()
</script>

<T.Mesh rotation.y={rotation}>
  <T.BoxGeometry />
  <T.MeshBasicMaterial color="red" />
</T.Mesh>

<Player />
<World />
```

## Context Not Available

<Tip type="danger">
	The following app structure is deceiving. It looks like it should work, but **it
	will not**. The problem is that the `useTask` hook is called *outside* of the
	`<Canvas>` component, so the main Threlte context is not available. Usually hooks
	relying on some context will tell you with descriptive error messages when they
	are used outside of their context.
</Tip>

```svelte title="App.svelte"
<script>
  import { Canvas, useTask, T } from '@threlte/core'

  let rotation = 0

  // This won't work, we're not inside <Canvas>
  useTask((delta) => {
    rotation += delta
  })
</script>

<Canvas>
  <T.Mesh rotation.y={rotation} />
</Canvas>
```


================================================
File: apps/docs/src/content/learn/basics/disposing-objects.mdx
================================================
---
title: Disposing Objects
category: Basics
order: -400
---

Freeing resources is a [manual chore in
three.js](https://threejs.org/docs/index.html#manual/en/introduction/How-to-dispose-of-objects),
but Svelte is aware of component lifecycles, hence Threlte will attempt to free
resources for you by calling `dispose`, if present, on all unmounted objects
that are not being used anywhere else in your scene.

## Automatic Disposal

```svelte
<script>
  import { T } from '@threlte/core'
  import { useTexture } from '@threlte/extras'
</script>

<!--
	The geometry and the material will be disposed
	as soon as the <Mesh> component unmounts.
-->
<T.Mesh>
  <T.BoxGeometry />
  <T.MeshStandardMaterial />
</T.Mesh>
```

<Tip>
  Be aware that calling `dispose` on a three.js buffer, material or geometry is merely deallocating
  it from the GPU memory. If an object is used after it's disposed it will be allocated again,
  resulting in a performance drop for a single frame. It will **not produce a runtime error**.
</Tip>

## Manual Disposal

You can switch off automatic disposal by placing `dispose={false}` onto
components. This disables disposal for the entire subtree.

```svelte
<script>
  import { T, useTexture } from '@threlte/core'

  const map = useTexture('/some/texture')
  const material = new MeshStandardMaterial({ map })
</script>

<!-- will not be disposed -->
<T.Mesh dispose={false}>
  <!-- will not be disposed -->
  <T.BoxGeometry />
  <!-- will not be disposed -->
  <T.MeshStandardMaterial map={$map} />

  <!-- will be disposed -->
  <T.Mesh dispose>
    <!-- will be disposed -->
    <T.BoxGeometry />
    <!-- will be disposed -->
    <T.MeshStandardMaterial map={$map} />
  </T.Mesh>
</T.Mesh>
```

## Custom Disposal

You can use the return function of the `oncreate` prop to dispose of objects manually.

```svelte
<script>
  import { T } from '@threlte/core'
</script>

<T.MeshBasicMaterial
  oncreate={(ref) => {
    return () => {
      // Do your disposal here
    }
  }}
/>
```

## Automatic Disposal Limitations

Be aware that automatic disposal only happens on the objects that are referenced
by a `<T>` component.

```svelte
<script>
  import { T } from '@threlte/core'
  import { useTexture } from '@threlte/extras'

  const map = useTexture('/some/texture.png')
</script>

{#if $map}
  <T.Mesh>
    <T.BoxGeometry />
    <T.MeshBasicMaterial map={$map} />
  </T.Mesh>
{/if}
```

In this example, the texture will not be disposed when the material unmounts,
you will have to dispose of it manually.


================================================
File: apps/docs/src/content/learn/basics/handling-events.mdx
================================================
---
title: Handling Events
category: Basics
order: -700
---

Events come in three different flavours in Threlte. The DOM events you know from
HTML, some svelte [component props](https://svelte.dev/docs/svelte/basic-markup#Component-props)
and raycasting.

## DOM events

To get started, you'll need an HTML element. The [`useThrelte`](/docs/reference/core/use-threlte)
hook provides you with direct access to Threltes HTML div wrapper - the `dom`.
The `canvas` is also available if that is more appropriate for your events.

## Prop events

The `<T>` component has it's own [events](/docs/reference/core/t#events). It can even pickup
on events coming from the [underlying three.js objects](/docs/reference/core/t#object-events).

## Raycasting events

Casting rays can end up being a big part of your 3D application. They're required for
creating [`interactivity`](/docs/reference/extras/interactivity) (click, pointer
and wheel events) on your scene's meshes. Raycasting can struggle with complex shapes
or a high number of objects but this can be mitigated by either:

- Raycasting against an simplier, invisible object ([a sphere](/docs/reference/extras/mesh-bounds) for example)
- Or introducing a better raycasting algorithm such as Bounding Volume Hirerchies ([BVH](/docs/learn/advanced/plugins#bvh-raycast-plugin))

In general, Three.js's default raycaster works well enough.


================================================
File: apps/docs/src/content/learn/basics/loading-assets.mdx
================================================
---
category: Basics
title: Loading Assets
order: -750
---

There are a number of different asset types you might like to use in your Threlte application. Three.js has a [ton of different loaders](https://threejs.org/docs/index.html?q=loader) that Threlte integrates well with. You're recommended to use the [useLoader](/docs/reference/core/use-loader) hook which will cache any asset it loads and wrap the asset in an [asyncWritable](/docs/reference/core/utilities#asyncwritable) for convenience. Caching assets will reduce network requests, bandwidth, and memory usage, which will improve the performance of your application.

<Tip type="info">
  This section assumes you placed your assets in your public folder or in a place in your
  application where you can import them easily.
</Tip>

## Models

Models come in many different formats. For example, `.gltf`'s are mostly json files. You can use three's `GLTFLoader` to load a `.gltf` model.

```svelte
<script>
  import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'
  import { useLoader } from '@threlte/core'

  const gltf = useLoader(GLTFLoader).load('/assets/model.gltf')
</script>

{#if $gltf}
  <T is={$gltf.scene} />
{/if}
```

The [`<GLTF/>`](/docs/reference/extras/gltf) component is roughly equivalent to the example above.

### Convenient: useGltf

`@threlte/extras` provides a handy hook for loading `.gltf` models called [useGltf](/docs/reference/extras/use-gltf):

```svelte
<script>
  import { useGltf } from '@threlte/extras'
</script>

{#await useGltf('/assets/model.gltf') then gltf}
  <T is={gltf.scene} />
{/await}
```

### Adjusting Parts and Multiple Copies

There are some challenges you'll probably run into when working with models in Threlte:

- Your model may have multiple parts that you'd like to adjust individually but there's no easy way to declaritively achieve that with only one `<T/>` component.
- The model is cached which is great but you can't seem to place multiple copies in your scene.

To address both of these issues, you can use Threlte's CLI tool [@threlte/gltf](/docs/reference/gltf/getting-started) to generate a svelte component for your model. The generated component has `<T/>` components for all of your models parts. [Adjust the component](/docs/learn/advanced/custom-abstractions) to your liking, then import and reused it as much as you'd like.

### Animations

Three.js uses [AnimationMixer](https://threejs.org/docs/index.html#api/en/animation/AnimationMixer) to drive animations. Threlte provides a convenient [useGltfAnimations](/docs/reference/extras/use-gltf-animations) hook for gltf's. See the [three.js examples](https://threejs.org/examples/?q=animation) for how to setup a model for your animation needs.

Threlte has a few [animation examples](/docs/examples/animation/animation-transitions) to help you get started.

## Textures

The `TextureLoader` is another loader from three that is used for textures.

```svelte
<script>
  import { TextureLoader } from 'three'
  import { useLoader } from '@threlte/core'

  const texture = useLoader(TextureLoader).load('/assets/texture.png')
</script>

{#if $texture}
  <T.MeshStandardMaterial map={$texture} />
{/if}
```

### Convenient: useTexture

`@threlte/extras` provides a handy hook for loading textures called [useTexture](/docs/reference/extras/use-texture):

```svelte
<script>
  import { useTexture } from '@threlte/extras'
</script>

{#await useTexture('/assets/texture.png') then texture}
  <T.MeshStandardMaterial map={texture} />
{/await}
```

### Multiple textures

Sometimes you'll want your materials to be composed of multiple textures. `useLoader` provides a way to load multiple textures at once and [spread](https://learn.svelte.dev/tutorial/spread-props) the loaded textures on a material.

Loading two textures for the `map` and `normalMap` channels can be done like this:

```ts
const textures = useLoader(TextureLoader).load({
  map: '/assets/texture.png',
  normalMap: '/assets/normal.png'
})
```

or with the `useTexture` hook:

```ts
const textures = useTexture({
  map: '/assets/texture.png',
  normalMap: '/assets/normal.png'
})
```

Then spread on a material:

```svelte
{#if $textures}
  <T.MeshStandardMaterial {...$textures} />
{/if}
```

If multiple textures are given, the promise only resolves once all textures have loaded.

### Applying different textures to different faces

To declaratively apply two different textures to two different faces of a `BoxGeometry`, set the `attach` prop to a function.

```svelte
<T.Mesh>
  <T.BoxGeometry />
  <T.MeshStandardMaterial
    map={texture1}
    attach={({ parent, ref }) => {
      if (Array.isArray(parent.material)) parent.material = [...parent.material, ref]
      else parent.material = [ref]
    }}
  />
  <T.MeshStandardMaterial
    map={texture2}
    attach={({ parent, ref }) => {
      if (Array.isArray(parent.material)) parent.material = [...parent.material, ref]
      else parent.material = [ref]
    }}
  />
</T.Mesh>
```

Alternatively, mix declarative and normal three.js code like so for the same result:

```svelte
<script>
  // imports and other code
  const customMaterials = [
    new MeshStandardMaterial({ map: texture1 }),
    new MeshStandardMaterial({ map: texture2 })
  ]
</script>

<T.Mesh>
  <T.BoxGeometry />
  <T
    is={customMaterials}
    attach="material"
  />
</T.Mesh>
```

## Other Assets

Threlte provides many components to help get started with other assets (like [audio](/docs/reference/extras/audio)) but we don't have convenient components and hooks for all of them yet. Checkout [three.js examples](https://threejs.org/examples/) to see what models, techniques and effects you can acheive, then use those examples as a guide for your own [custom components](/docs/learn/advanced/custom-abstractions).

## Async Loading

The return value from [useLoader](/docs/reference/core/use-loader) is an `AsyncWritable` custom store. Its value will be `undefined` until the asset has loaded.

Since the underlying store's value is a promise, you can use it within svelte's await blocks:

```svelte
{#await $texture then value}
  <T.MeshStandardMaterial map={value} />
{/await}
```

These hooks can be used similarly to Svelte's `onMount` hook however assets can also be loaded after initialization by separating out the load call:

```svelte
<script>
  import { AudioLoader } from 'three'
  import { useLoader } from '@threlte/core'

  // Instantiate the loader at component initialization
  const loader = useLoader(AudioLoader)

  const onSomeEvent = async () => {
    // Load the asset when needed
    const audioBuffer = await loader.load('/assets/sound.mp3')
  }
</script>
```

Another set of tools to help orchestrate loading multiple assets before displaying something is the [suspense](/docs/reference/extras/suspense) component and hooks.

## Context Awareness

The `useLoader` hook, and other hooks like `useTexture`, use svelte contexts. The assets loaded with them are only available for child components of your `<Canvas>` component.


================================================
File: apps/docs/src/content/learn/basics/render-modes.mdx
================================================
---
category: Basics
title: Render Modes
order: -450
---

Threlte offers three different render modes to optimize the performance and
power usage of your Threlte app. Ideally, you only want to render the scene
when it is necessary, such as when the camera moves or when objects are added or
removed from the scene. The render mode determines how and when the scene is
rendered.

In the default [`'on-demand'`](#mode-on-demand) mode, Threlte is able to
determine when a re-render is necessary by observing components. When setting
the render mode to [`'manual'`](#mode-manual) you must manually trigger a
re-render. You can tell Threlte to continuously render the scene in the
[`'always'`](#mode-always) mode.

## Mode `'on-demand'`

<Example path="renderers/on-demand-rendering" />

In the mode `'on-demand'`, Threlte renders the scene only when the current frame
is **invalidated**. This may happen [automatically when changes are
detected](#automatic-invalidation) or the frame is [manually
invalidated](#manual-invalidation). This is the default mode and the recommended
way of working with Threlte.

### Automatic Invalidation

Threlte is able to automatically invalidate the current frame by observing
component props and the mounting and unmounting of components. This means that
when you e.g. change the position of a `<T.Mesh>` via component props, Threlte
will automatically invalidate the current frame and request a new frame.

```svelte
<script>
  import { T } from '@threlte/core'

  let x = 0

  const move = () => {
    x += 1
  }
</script>

<T.Mesh position.x={x} />
```

### Manual Invalidation

In some cases, you may want to manually invalidate the current frame because
Threlte is not able to detect changes. To do this, you can use the `invalidate`
function from the [`useThrelte`](/docs/reference/core/use-threlte) hook.

```svelte
<script>
  import { T, useThrelte } from '@threlte/core'
  import { Mesh } from 'three'

  const { invalidate } = useThrelte()

  const mesh = new Mesh()

  export const moveMesh = () => {
    // moving the mesh manually
    mesh.position.x = 1
    // invalidate the current frame
    invalidate()
  }
</script>

<T is={mesh} />
```

### `useTask`

The [`useTask`](/docs/reference/core/use-task) hook is by default configured to
automatically invalidate the current frame **on every frame**. This means that you
can use it to animate your scene without having to manually invalidate the
current frame.

```ts
import { useTask } from '@threlte/core'

useTask(() => {
  // useTask will automatically invalidate the current
  // frame, so you don't have to do it manually.
})
```

Sometimes you may want to manually invalidate the current frame from within a
task. To do this, you can use the `invalidate` function from the
[`useThrelte`](/docs/reference/core/use-threlte) hook and set the `autoInvalidate`
option to `false`:

```ts
import { useTask, useThrelte } from '@threlte/core'

const { invalidate } = useThrelte()

useTask(
  () => {
    // Because `autoInvalidate` is set to `false`, the current
    // frame will not be invalidated automatically and you can
    // conditionally invalidate the current frame.
    invalidate()
  },
  { autoInvalidate: false }
)
```

## Mode `'manual'`

In the manual mode, you must manually trigger a re-render:

```ts
const { advance } = useThrelte()
advance()
```

This mode is useful when you want to have full control over when the scene is
rendered. For example, you may want to render the scene only when the user
interacts with the scene.

## Mode `'always'`

In the `'always'` mode, Threlte continuously renders the scene. This mode is the
easiest to use, but it is also the most resource intensive and should only be
used when necessary.

## Setting the Render Mode

### `<Canvas>` Prop

You can set the render mode by setting the property `renderMode` on the
[`<Canvas>`](/docs/reference/core/canvas) component:

```svelte
<Canvas renderMode="on-demand" />
```

### `useThrelte` Hook

You can also set the render mode from anywhere within your Threlte app using the
[`useThrelte`](/docs/reference/core/use-threlte) hook:

```ts
const { renderMode } = useThrelte()
renderMode.set('on-demand')
```

<Tip type="tip">
  The renderMode property can be changed at any time, but it will only take effect on the next
  frame.
</Tip>

## Render Modes and Custom Rendering

By default, Threlte will automatically render the scene for you. In some cases,
you may want to render the scene yourself, for example when using [post
processing](/docs/examples/postprocessing/outlines).

1. Set `autoRender` to `false` on the [`<Canvas>`](/docs/reference/core/canvas)
   component. This will prevent Threlte from automatically rendering the scene
   and you can render the scene yourself.

```svelte
<Canvas autoRender={false} />
```

2. Set up a task that renders the scene. There are two ways to do this:

- Add a task to [Threlte's default
  `renderStage`](/docs/learn/basics/scheduling-tasks#default-stages). Tasks in
  that stage will be executed after tasks in Threlte's `mainStage` and only
  when a re-render is necessary based on the current render mode. This is the
  recommended approach.

```ts
import { useTask, useThrelte } from '@threlte/core'

const { renderStage } = useThrelte()

useTask(
  () => {
    // render here
  },
  { stage: renderStage, autoInvalidate: false }
)
```

- Use `shouldRender` from the hook
  [`useThrelte`](/docs/reference/core/use-threlte). This function will evaluate
  to `true` based on the current render mode. This allows for more fine-grained
  control over when to render and is useful when you want to render in a task
  that is not in [Threlte's default
  `renderStage`](/docs/learn/basics/scheduling-tasks#default-stages).

```ts
import { useThrelte, useTask } from '@threlte/core'

const { shouldRender } = useThrelte()

useTask(
  () => {
    if (shouldRender()) {
      // render here
    }
  },
  { autoInvalidate: false }
)
```


================================================
File: apps/docs/src/content/learn/basics/scheduling-tasks.mdx
================================================
---
title: Scheduling Tasks
category: Basics
order: -500
---

In 3D apps and games, a lot of work is done in functions that run on every frame.
Web-based apps rely on the browser's `requestAnimationFrame` that runs a callback
function when a new frame is rendered. When encapsulating logic into smaller
parts (i.e. _components_), we often need to run multiple
callbacks that may be dependent on each other. For instance, we
may want to update the position of an object based on user input and then render
the scene with the updated position.

In Threlte, these functions are called **tasks** and may or may not follow a
specific order. If an order is specified, the respective task has a
**dependency** to other tasks and vice versa. Tasks are grouped into **stages**
and follow the same logic: They may or may not have dependencies to other stages
to be executed in a specific order. A Threlte app is managed by a single
**scheduler**.

In this section, we will learn how to use the easy-to-use tools that the
**Threlte Task Scheduling System** provides to create and orchestrate stages
and tasks.

<img
  class="w-full max-md:hidden"
  src="/images/docs/learn/frame-handling.svg"
/>
<img
  class="mx-auto h-[85vh] w-auto md:hidden"
  src="/images/docs/learn/frame-handling_portrait.svg"
/>

<small>Figure: A schedule of multiple stages with tasks</small>

## Scheduler

Every Threlte app has a single scheduler. It is accessible via [`useThrelte()`](/docs/reference/core/use-threlte):

```ts
const { scheduler } = useThrelte()
```

<Tip type="info">
  Usually you won't need to interact with the scheduler directly. It is used internally by Threlte.
  However, you can use it to create stages and run tasks manually for more advanced use cases.
</Tip>

## Stages

Stages are **groups of tasks**. They are executed in a specific order.

### Default Stages

By default, Threlte will create two stages for you:

- **`mainStage`**: This stage holds all the tasks that are not assigned to any
  other stage.
- **`renderStage`**: This stage will be executed after the `mainStage`. It is
  used to render the scene and only ever executes its tasks when a re-render is
  needed.

These two stages are created automatically and are accessible via
[`useThrelte()`](/docs/reference/core/use-threlte):

```ts
const { mainStage, renderStage } = useThrelte()
```

### Creating a Stage

Sometimes, you may want to create your own stage, for instance to run tasks
after rendering. You can do so by using the hook `useStage`. The hook will
create a stage if it does not exist yet, or return the existing stage if it
does.

```ts
const { renderStage } = useThrelte()

const afterRenderStage = useStage('after-render', {
  after: renderStage
})
```

All tasks added to the stage `afterRenderStage` will be executed after the tasks
of the stage `renderStage`.

<Tip type="tip">Be aware that `useStage` never removes a stage as that's usually not needed.</Tip>

A stage decides **when and how its tasks are executed**. By default, a stage will
execute its tasks on every frame. You can change this behavior by passing a
`callback` option to `useStage`. This callback will be called every frame. The
first argument `delta` is the time elapsed since the last frame. The second
argument `runTasks` is a function that when invoked will run all the tasks of
the stage in their respective order. You can use it to run the tasks only when
needed (e.g. when a condition is met) or to run them multiple times. If a number
is passed as the first argument to runTasks, the tasks will receive that as the
delta.

```ts
const { renderStage } = useThrelte()

const conditionalStage = useStage('after-render', {
  after: renderStage,
  callback: (delta, runTasks) => {
    // This callback will be called every frame. The first argument is the time elapsed
    // since the last frame. The second argument is a function that will run all the
    // tasks of the stage. You can use it to run the tasks only when needed (e.g. when
    // a condition is met) or to run them multiple times. If a number is passed as the
    // first argument to runTasks, the tasks will receive that as the delta.
    if (condition) {
      runTasks()
    }
  }
})
```

### Removing a Stage

You can remove a stage by calling the `remove` method of the scheduler. The first
argument is the stage or the key of the stage to remove.

```ts
const { scheduler } = useThrelte()

scheduler.removeStage(afterRenderStage)
```

<Tip>
  Be aware that removing a stage will also remove all the tasks in that stage. Usually, you won't
  need to remove a stage.
</Tip>

## Tasks

Tasks are functions that are executed on every frame. They are grouped in
stages. You can add a task to a stage by using the hook `useTask`. The hook will
create a task and add it to a stage.

### Default Tasks

By default, Threlte will create a single task for you:

- **`autoRenderTask`**: This task is part of [Threlte's
  `renderStage`](#default-stages) and will render the scene if
  [`autoRender`](/docs/reference/core/canvas) is set to `true`.

This task is created automatically and is accessible via
[`useThrelte()`](/docs/reference/core/use-threlte):

```ts
const { autoRenderTask } = useThrelte()
```

### Creating an Anonymous Task

In its most basic form, `useTask` takes a function as its first argument. This
function will be executed on every frame, starting on the next frame and
receives the delta time representing the time since the last frame as its first
argument. By default, the created task is added to [Threlte's
`mainStage`](#default-stages) in an arbitrary order (i.e. without dependencies).

```ts
const { start, stop, started, task } = useTask((delta) => {
  // This function will be executed on every frame
})
```

It returns an object with the following properties:

- `start`: A function that starts the task. It will be executed on the next
  frame. Note that by default a task is started automatically.
- `stop`: A function that stops the task. It will not be executed on the next
  frame.
- `started`: A boolean Svelte `Readable` store indicating whether the task is
  started or not.
- `task`: The task itself. You can use it to indicate a dependency to this task
  on another task.

### Creating a Keyed Task

You can _key_ a task by passing it as the first argument to `useTask`. This
makes referencing this task easier across your app. The key can be any `string`
or `symbol` value that is unique across all tasks in the stage it is added to.

```ts
const {
  start,
  stop,
  started,
  task: someTask
} = useTask('some-task', (delta) => {
  // This function will be executed on every frame
})
```

### Creating a Task in a Stage

You can also pass a stage that the task should be added to as an option to
`useTask`:

```ts
useTask(
  (delta) => {
    // This function will be executed on every frame as a
    // task in the stage `afterRenderStage`.
  },
  { stage: afterRenderStage }
)
```

### Task Dependencies

A common use case for tasks is to run code after another task has been executed. Imagine
a game where an object is transformed by user input in one task and a camera follows that
object in another task. The camera task should be executed after the object has been
transformed.

To control the order in which tasks are executed in a stage, you can pass a
`before` and `after` option to `useTask`. The tasks passed to these options are
called **dependencies** and can be a task itself, the key of a task or an array
of tasks or keys. The referenced tasks must be in the same stage as the task you
are creating.

Task dependencies **do not need to be created yet** if they are passed by key.
The declared dependencies will be taken into account when they are created later
on.

#### Examples

```ts
// Execute a task after a single task passed by reference
useTask(
  (delta) => {
    // …
  },
  { after: someTask }
)
```

```ts
// Execute a task after a single task passed by key
useTask(
  (delta) => {
    // …
  },
  { after: 'some-task' }
)
```

```ts
// Execute a task after multiple tasks passed by reference
useTask(
  (delta) => {
    // …
  },
  { after: [someTask, someOtherTask] }
)
```

```ts
// Execute a task after a certain task but before another one
useTask(
  (delta) => {
    // …
  },
  { after: someTask, before: someOtherTask }
)
```

```ts
// Reference a task as a dependency that hasn't been created yet
useTask(
  (delta) => {
    // If a task with the key `some-task` is created later on,
    // this task will be executed after it.
  },
  { before: 'some-task' }
)

useTask('some-task', (delta) => {
  // …
})
```

<Tip type="warning">
  If a task is passed by reference to the `before` or `after` option, the task created by `useTask`
  will automatically be added to the same stage as the task it depends on. If you pass a key instead
  and the task you want to reference is **not** in [Threlte's `mainStage`](#default-stages), you
  will also need to pass the stage, either by value or key.
</Tip>

## Reviewing the schedule

To debug the execution order, you can use the `getSchedule` method of the scheduler at any
time.

```ts
const { scheduler } = useThrelte()

scheduler.getSchedule({
  tasks: true
})
```

```json title="Result"
{
  "stages": [
    {
      "key": "physics stage",
      "tasks": ["physics"]
    },
    {
      "key": "main stage",
      "tasks": ["move object", "move camera"]
    },
    {
      "key": "render stage",
      "tasks": ["render"]
    }
  ]
}
```

In this example, the effective task execution order is:

1. `physics`
2. `move object`
3. `move camera`
4. `render`

---

The design of the Threlte Task Scheduling System is a collaborative effort of
the Threlte team, [Kris Baumgarter](https://github.com/krispya) and [Akshay
Dhalwala](https://github.com/akdjr).


================================================
File: apps/docs/src/content/learn/getting-started/installation.mdx
================================================
---
category: Getting Started
title: Installation
---

import ManualInstallGuide from '$components/ManualInstallGuide/ManualInstallGuide.svelte'

To start using Threlte install the packages you want to use in your project.

Threlte consists of 7 packages which can be installed and used individually.
`@threlte/core` and Three.js itself are required for all projects while the
other packages are optional.
[`@threlte/gltf`](/docs/reference/gltf/getting-started) does not need to be
installed separately as it can be used with `npx`, the resulting Threlte
components however require `@threlte/extras` to be installed.

### Choose the packages you want to use

<ManualInstallGuide client:load />

<Tip type="tip">
  [See this comment](https://github.com/threlte/threlte/issues/8#issuecomment-1024085864) for tips
  on how to reduce bundle size when working with bundlers like vite and three.js.
</Tip>


================================================
File: apps/docs/src/content/learn/getting-started/introduction.mdx
================================================
---
category: Getting Started
title: Introduction
order: -999
---

<Tip type="tip">
  If you're looking for the documentation for Threlte 7, head to
  [v7.threlte.xyz](https://v7.threlte.xyz).
</Tip>

Threlte is a renderer and component library for using Three.js in a **declarative** and **state-driven** way in Svelte apps. It provides strictly typed components for deep **reactivity** and **interactivity** out-of-the-box.

Threlte is comprised of six distinct packages to allow you to import only what you need:

- [@threlte/core](/docs/reference/core/getting-started) is the heart of Threlte, providing simple transparent Svelte binding to Three.js:

  - [`<T>`](/docs/reference/core/t) is the **main building block** of any Threlte application. It is a thin wrapper around any Three.js
    object and provides a declarative API to build and render your Threlte app.

  - [Plugins](/docs/learn/advanced/plugins) make it easy to extend Threlte with custom code and logic. Whether you want to implement an ECS or add a single property to every instance of `<T>`, plugins are the way to go.

- [@threlte/extras](/docs/reference/extras/getting-started) is a collection of plugins and components that extend Threlte with additional functionality.

- [@threlte/gltf](/docs/reference/gltf/getting-started) is a command-line tool that turns GLTF assets into declarative and re-usable Threlte components.

- [@threlte/rapier](/docs/reference/rapier/getting-started) provides components to enable performant physics in your Threlte application through the [Rapier engine](https://rapier.rs/)

- [@threlte/theatre](/docs/reference/theatre/getting-started) provides components to enable animations in your Threlte application through the [Theatre.js animation library](https://www.theatrejs.com/)

- [@threlte/xr](/docs/reference/xr/getting-started) provides components for VR and AR.

- [@threlte/flex](/docs/reference/flex/getting-started) provides components to easily use the flex engine [`yoga-layout`](https://yogalayout.com/) with Threlte.


================================================
File: apps/docs/src/content/learn/getting-started/your-first-scene.mdx
================================================
---
category: Getting Started
title: Your First Scene
---

<Tip type="info">
  You should be versed in both Svelte and Three.js before rushing into Threlte. If you are unsure
  about Svelte, consult its [Tutorial](https://svelte.dev/tutorial) for a quick introduction. As for
  Threejs, make sure you at least glance over its [official documentation](https://threejs.org).
</Tip>

## Structuring Your App

As a first step we're creating a new Svelte file called `App.svelte` where we are importing the [`<Canvas>` component](/docs/reference/core/canvas).

```svelte title="App.svelte"
<script>
  import { Canvas } from '@threlte/core'
  import Scene from './Scene.svelte'
</script>

<Canvas>
  <Scene />
</Canvas>
```

The `<Canvas>` component is the root component of your Threlte application. It creates a
renderer and sets up some sensible defaults for you like antialiasing and color management.
It also creates a default camera and provides the context in which your Threlte application
will run. For improving access to this runtime context, it's <a href="/docs/learn/basics/app-structure">best practice</a>
to create a seperate component called `Scene.svelte` and including it in our `App.svelte` file.

## Creating Objects

At this point we're looking at a blank screen. Let's add a simple cube to it.

In `Scene.svelte`, we're importing the [`<T>` component](/docs/reference/core/t) which is
the **main building block** of your Threlte application. It's a **generic
component** that we use to render **any Three.js object**. In this case we're creating a
[`THREE.Mesh`](https://threejs.org/docs/index.html#api/en/objects/Mesh) which is made up from
a [`THREE.BoxGeometry`](https://threejs.org/docs/index.html#api/en/geometries/BoxGeometry) and
a [`THREE.MeshBasicMaterial`](https://threejs.org/docs/index.html#api/en/materials/MeshBasicMaterial).

We should now be looking at a white cube on a transparent background.

```svelte title="Scene.svelte" {1-8}+
<script>
  import { T } from '@threlte/core'
</script>

<T.Mesh>
  <T.BoxGeometry />
  <T.MeshBasicMaterial />
</T.Mesh>
```

<Example
  path="first-scene/step-1"
  hideCode
/>

<Tip type="info">
  #### attach

Behind the scenes we're using the property `attach` available on `<T>` to **attach an object to a property of
its parent**. Binding geometries to the property `geometry` and materials to the property `material` is a common
pattern so Threlte takes care of it for you.

  <details>
	<summary>
      Learn more
    </summary>

    We're using the property `attach` available on `<T>` to
    **attach an object to a property of its parent**. In our case we're **attaching** the underlying Three.js
    object of `<T.BoxGeometry>` to the property `geometry` of the `<T.Mesh>` component. We're also attaching
    the underlying Three.js object of `<T.MeshBasicMaterial>` to the property `material` of the `<T.Mesh>` component.

    ```svelte title="Scene.svelte"
    <script>
      import { T } from '@threlte/core'
    </script>

    <T.Mesh>
      <T.BoxGeometry attach="geometry" />
      <T.MeshBasicMaterial attach="material" />
    </T.Mesh>
    ```

    Binding geometries to the property `geometry` and materials to the property `material` is a common
    pattern so Threlte will take care of it. It checks for the properties `isMaterial` and `isGeometry` on
    the underlying Three.js object and attaches it to the correct property.

  </details>
</Tip>

<details>
	<summary>
		Three.js equivalent
	</summary>
  ```ts
  // creating the objects
  const geometry = new THREE.BoxGeometry()
  const material = new THREE.MeshBasicMaterial()
  const mesh = new THREE.Mesh()

// "attaching" the objects
mesh.geometry = geometry
mesh.material = material

````
</details>

## Modifying Objects


That cube is still a bit boring. Let's add some color to it, and make it a bit bigger! We also want to move it up a little to highlight it. We can do this by passing props to the
`<T>` component.

```svelte title="Scene.svelte" {5-7}m
<script>
import { T } from '@threlte/core'
</script>

<T.Mesh position.y={1}>
<T.BoxGeometry args={[1, 2, 1]} />
<T.MeshBasicMaterial color="hotpink" />
</T.Mesh>
````

<Example
  path="first-scene/step-2"
  hideCode
/>

Threlte automatically generates props for `<T>` based on the underlying Three.js object. This means you can easily guess most `<T>` props
based on the <a href="https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene">Three.js docs</a> for the class you are using.

<details>
  <summary>
    Three.js equivalent
  </summary>

```ts
const mesh = new THREE.Mesh()
const geometry = new THREE.BoxGeometry(1, 2, 1)
const material = new THREE.MeshBasicMaterial()
mesh.position.y = 1
material.color.set('hotpink')
```

</details>

The special **args** prop we use in `<T.BoxGeometry>` corresponds to the
object's constructor arguments. Props interpreted from the underlying Three.js
object are called **auto props**, like `color` in our `<T.MeshBasicMaterial>`.
Leveraging Threlte's **Pierced Props** you can directly assigned to attributes
of props like `position.y` in our `<T.Mesh>`.

<details>
	<summary>
		Learn more
	</summary>
	#### `args`

    In Three.js objects are classes that are instantiated. These classes can
    receive one-time constructor arguments (`new THREE.SphereGeometry(1, 32)`). In
    Threlte, constructor arguments are always passed as an array via the prop
    `args`. If `args` change later on, the object must naturally get reconstructed
    from scratch!

    #### Auto Props

    For all other props, Threlte tries to automatically interpret props passed to `<T>` component.

    **Step 1.** *Find Properties* - First, Threlte will try to find the **property
    on the underlying Three.js object** based on the **name of the prop**. In our
    example, [`color` is a property of
    `THREE.MeshBasicMaterial`](https://threejs.org/docs/index.html#api/en/materials/MeshBasicMaterial.color).

    **Step 2.** *Try `set` Methods* - Next, Threlte will look for a `set` method
    on that property and use it to set the new value. In our example it will call
    `material.color.set('hotpink')` to set the color of our material.

    **Step 3.** *Try setting the property directly* - If there's no `set` method,
    it will try to set the property directly. In our example, this equated to
    `mesh.position.y = 1`.

    **Step 4.** *Check for array values* - When setting a property that accepts
    more than one value (such as a `THREE.Vector3`: `vec3.set(1, 2, 3)`), we can
    pass an array as a prop.

    **Step 5.** *Keep the prop type constant for the lifetime of the component* -
    If the prop value changes, Threlte will try to set the property again. If the
    type of the prop value changes, Threlte won't be able to reliably do that. For
    instance the type of the value of a variable that is used as a prop should not
    change from a single number to an array of numbers.

    #### Pierced Props

    Because the property `position` of our `THREE.Mesh` is a `THREE.Vector3`, it
    also has `x`, `y` and `z` properties which we can set directly via
    dot-notation, we call this **Pierced Props**.

</details>

<Tip
  type="tip"
  title="Primitive Values"
>
  From a performance perspective, it's often better to use pierced props because
  [primitive](https://developer.mozilla.org/en-US/docs/Glossary/Primitive) prop values can safely be
  compared for equality. This means that if the value of a prop doesn't change, Threlte will skip
  any updates to the underlying Three.js object.
</Tip>

<Tip
  type="warning"
  title="Constant prop types"
>
  The type of an inferred prop (or "auto prop") must be constant. This means that the type of a prop
  must not change for the lifetime of the component. For instance you can't use a variable as a prop
  that is an array of numbers and then later on change the value of that variable to a single
  number. This is considered a type change and therefore not allowed.
</Tip>

## Pointing the Camera

We're still staring at the side of a cube, let's add a camera and offset it from the center:

```svelte title="Scene.svelte" {5-11}+
<script>
  import { T } from '@threlte/core'
</script>

<T.PerspectiveCamera
  makeDefault
  position={[10, 10, 10]}
  oncreate={(ref) => {
    ref.lookAt(0, 1, 0)
  }}
/>

<T.Mesh position.y={1}>
  <T.BoxGeometry args={[1, 2, 1]} />
  <T.MeshBasicMaterial color="hotpink" />
</T.Mesh>
```

<Example
  path="first-scene/step-3"
  hideCode
/>

We're again using the `<T>` component to create a [`THREE.PerspectiveCamera`](https://threejs.org/docs/index.html#api/en/cameras/PerspectiveCamera).
We're also passing a `makeDefault` prop which will make this camera the default camera of our application.
The renderer now uses this camera to render our scene.

<Tip type="info">
  #### Events

Threlte supports listening to certain <a href="/docs/reference/core/t#events">events on `<T/>` components</a>. Here, we use the `create`
event to get a reference to the underlying Three.js object as soon as it's created and use the method `lookAt` to look at the cube.

</Tip>

## Enabling Interactivity

Let's say we want to scale our cube as soon as we hover over it. We first have to import the
[plugin](/docs/learn/advanced/plugins) [`interactivity`](/docs/reference/extras/interactivity) from
[`@threlte/extras`](/docs/reference/extras/getting-started) and invoke it in our `Scene.svelte` file.

The `interactivity` allows us to add interaction event listeners to our `<T>` components. We will add `pointerenter` and
`pointerleave` event listeners to our cube. In the event handlers we'll update the value of a `Spring` from `svelte/motion`
and use its `.current` value to set the `scale` property of the `<T.Mesh>` component.

```svelte title="Scene.svelte" {3-4,6-7,20-22}+
<script>
  import { T } from '@threlte/core'
  import { interactivity } from '@threlte/extras'
  import { Spring } from 'svelte/motion'

  interactivity()

  const scale = new Spring(1)
</script>

<T.PerspectiveCamera
  makeDefault
  position={[10, 10, 10]}
  oncreate={(ref) => {
    ref.lookAt(0, 1, 0)
  }}
/>

<T.Mesh
  position.y={1}
  scale={scale.current}
  onpointerenter={() => {
    scale.target = 1.5
  }}
  onpointerleave={() => {
    scale.target = 1
  }}
>
  <T.BoxGeometry args={[1, 2, 1]} />
  <T.MeshBasicMaterial color="hotpink" />
</T.Mesh>
```

<Example
  path="first-scene/step-4"
  hideCode
/>

<Tip type="info" title="Automatic Vector & Scalar Detection">
  You might have noticed that we're only passing a single number to the prop `scale` on `<T.Mesh>`. Threlte automatically
  figures out whether you are passing an array or a number and uses the appropriate underlying Three.js method.

  <details>
    <summary>
      Learn more
    </summary>
    The component `<T>` will first look for a property `setScalar` on	the underlying Three.js object and use that method if
    only a single number is passed. This is equivalent to calling `scale.setScalar($scale)`.
  </details>
</Tip>

<Tip
  type="tip"
  title="Realtime Variables"
>
  When working with realtime apps where variables e.g. position and rotation change constantly, an
  easy way observe the values is with [live
  expressions](https://developer.chrome.com/docs/devtools/console/live-expressions/).
</Tip>

## Adding Animation

Let's add some motion to our cube. We will use Threlte's [`useTask`](/docs/reference/core/use-task) hook to tap
into Threlte's **unified frame loop** and run a function on every frame. We again use a Pierced Prop to let the
cube rotate around its y-axis.

```svelte title="Scene.svelte" {2}m {9-12,24}+
<script>
  import { T, useTask } from '@threlte/core'
  import { interactivity } from '@threlte/extras'
  import { Spring } from 'svelte/motion'

  interactivity()

  const scale = new Spring(1)

  let rotation = 0
  useTask((delta) => {
    rotation += delta
  })
</script>

<T.PerspectiveCamera
  makeDefault
  position={[10, 10, 10]}
  oncreate={(ref) => {
    ref.lookAt(0, 1, 0)
  }}
/>

<T.Mesh
  rotation.y={rotation}
  position.y={1}
  scale={scale.current}
  onpointerenter={() => {
    scale.target = 1.5
  }}
  onpointerleave={() => {
    scale.target = 1
  }}
>
  <T.BoxGeometry args={[1, 2, 1]} />
  <T.MeshBasicMaterial color="hotpink" />
</T.Mesh>
```

<Example
  path="first-scene/step-5"
  hideCode
/>

`useTask` registers a callback that will be invoked on every frame. The callback receives the time delta since the last frame as an argument. We use
the delta to update the rotation
[independent of the frame rate](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)
– the cube will rotate at the same speed regardless of the frame rate.

## Adjusting the Lighting

We're almost done. Let's add some shading to our cube and a light source. We'll use a
`THREE.MeshStandardMaterial` on our cube and a `THREE.DirectionalLight` to illuminate our scene.

```svelte title="Scene.svelte" {32}m {22}+
<script>
  import { T, useTask } from '@threlte/core'
  import { interactivity } from '@threlte/extras'
  import { Spring } from 'svelte/motion'

  interactivity()

  const scale = new Spring(1)

  let rotation = 0
  useTask((delta) => {
    rotation += delta
  })
</script>

<T.PerspectiveCamera
  makeDefault
  position={[10, 10, 10]}
  oncreate={(ref) => {
    ref.lookAt(0, 1, 0)
  }}
/>

<T.DirectionalLight position={[0, 10, 10]} />

<T.Mesh
  rotation.y={rotation}
  position.y={1}
  scale={scale.current}
  onpointerenter={() => {
    scale.target = 1.5
  }}
  onpointerleave={() => {
    scale.target = 1
  }}
>
  <T.BoxGeometry args={[1, 2, 1]} />
  <T.MeshStandardMaterial color="hotpink" />
</T.Mesh>
```

<Example
  path="first-scene/step-6"
  hideCode
/>

## Casting Shadows

We would like our cube to cast a shadow. To do so, we need a floor for it to cast a shadow _on_,
so we add a new `<T.Mesh>` but this time with `<T.CircleGeometry>`. To enable shadows, we need to
set `castShadow` on both the light and our cube, and set `receiveShadow` on our new floor:

```svelte title="Scene.svelte" {22}m {24,33,39-45}+
<script>
  import { T, useTask } from '@threlte/core'
  import { interactivity } from '@threlte/extras'
  import { Spring } from 'svelte/motion'

  interactivity()

  const scale = new Spring(1)

  let rotation = 0
  useTask((delta) => {
    rotation += delta
  })
</script>

<T.PerspectiveCamera
  makeDefault
  position={[10, 10, 10]}
  oncreate={(ref) => {
    ref.lookAt(0, 1, 0)
  }}
/>

<T.DirectionalLight
  position={[0, 10, 10]}
  castShadow
/>

<T.Mesh
  rotation.y={rotation}
  position.y={1}
  scale={scale.current}
  onpointerenter={() => {
    scale.target = 1.5
  }}
  onpointerleave={() => {
    scale.target = 1
  }}
  castShadow
>
  <T.BoxGeometry args={[1, 2, 1]} />
  <T.MeshStandardMaterial color="hotpink" />
</T.Mesh>

<T.Mesh
  rotation.x={-Math.PI / 2}
  receiveShadow
>
  <T.CircleGeometry args={[4, 40]} />
  <T.MeshStandardMaterial color="white" />
</T.Mesh>
```

<Example
  path="first-scene/step-7"
  hideCode
/>

## Conclusion

Congratulations, you've just created your first Three.js scene with Threlte! It includes important
Three.js and Threlte concepts and should give you a good starting point for your first Threlte project.


================================================
File: apps/docs/src/content/learn/more/resources.mdx
================================================
---
category: More
title: Resources
---

The three.js space is constantly evolving and expanding. Whether you are a beginner
looking to get started or an experienced developer seeking advanced knowledge,
there are resources in the wider community which offer a wealth of information
and technologies to help.

## Underlying Libraries

The following libraries are foundational to understanding Threlte's architecture, functionalities and packages:

### [Three.js](https://threejs.org/)

An excellent starting point for 3D graphics on the web. Three.js serves as the backbone for rendering and creating 3D scenes in Threlte.

### [Rapier](https://www.rapier.rs/)

An essential library for real-time physics simulations. Rapier helps bring your Threlte projects to life with dynamic interactions.

### [Theatre.js](https://www.theatrejs.com/)

Focuses on timeline-based animations and offers intricate control over complex animations, making it easier to manage complex state changes in Threlte.

## General

### [Threejs Resources](https://threejsresources.com/)

A hub for all things 3D. From tools to textures, lighting & more.

## Shaders

GLSL (Graphics Library Shader Language) is a critical part of shader programming, which is central to achieving high-quality visual effects in Threlte.

### [The Book of Shaders](https://thebookofshaders.com/)

This resource breaks down complex shader programming into bite-sized lessons. A great starting point for anyone new to shaders.

### [Learn OpenGL](https://learnopengl.com/)

An in-depth resource for learning OpenGL and GLSL, covering topics from beginner to advanced levels. Learn OpenGL offers tutorials that are easily applicable to Threlte's context.

We hope you find these resources valuable in your journey to mastering Threlte. Happy Learning!


================================================
File: apps/docs/src/content/reference/core/canvas.mdx
================================================
---
category: '@threlte/core'
name: '<Canvas>'
sourcePath: 'packages/core/src/lib/Canvas.svelte'
order: 0
type: 'component'
componentSignature:
  {
    props:
      [
        { name: 'dpr', type: 'number', default: 'window.devicePixelRatio', required: false },
        {
          name: 'toneMapping',
          type:
            {
              name: 'THREE.ToneMapping',
              url: 'https://threejs.org/docs/index.html#api/en/constants/Renderer'
            },
          default: 'THREE.AgXToneMapping',
          required: false,
          description: 'renderer.toneMapping'
        },
        {
          name: 'colorSpace',
          type:
            {
              name: 'THREE.ColorSpace',
              url: 'https://github.com/mrdoob/three.js/blob/705e47d035591cb5a2e9cc83aa3576e21a4bf2c0/src/constants.js#L149-L153'
            },
          default: 'srgb',
          required: false
        },
        {
          name: 'colorManagementEnabled',
          type:
            {
              name: 'boolean',
              url: 'https://threejs.org/docs/#manual/en/introduction/Color-management'
            },
          default: 'true',
          required: false
        },
        {
          name: 'renderMode',
          type: "'always' | 'on-demand' | 'manual'",
          default: "'on-demand'",
          required: false
        },
        {
          name: 'autoRender',
          type: 'boolean',
          default: 'true',
          required: false,
          description: 'Whether to automatically render the scene every frame. Set to `false` to implement custom render pipelines.'
        },
        {
          name: 'shadows',
          type: 'boolean | THREE.ShadowMapType',
          default: 'THREE.PCFSoftShadowMap',
          required: false
        },
        {
          name: 'createRenderer',
          type: '(canvas: HTMLCanvasElement) => THREE.Renderer',
          required: false,
          description: 'To set up a custom renderer, pass a function that returns a new renderer instance.'
        }
      ]
  }
---

The `<Canvas>` component is the root of your Threlte scene. It provides contexts
that all other components and many hooks depend on. This means they need to be
**child components** to the `<Canvas>` component.

<Tip
  type="tip"
  title="Structuring Your App"
>
  Check out our [guide on structuring your app](/docs/learn/basics/app-structure) for a fail-safe
  app architecture recipe.
</Tip>

## Size

By default, the `<canvas>` (the **DOM element** inside `<Canvas>`) that is being
rendered into takes up 100% of the width and height of its parent element and
reacts to changes in the parent element's size. This means that – simply put –
you define the size of the `<canvas>` element by layouting the parent element.

```svelte title="App.svelte"
<div style="width: 300px; height: 300px;">
  <!-- The canvas will take up 300px by 300px -->
  <Canvas>
    <Scene />
  </Canvas>
</div>
```

<Tip type="info">
  When taking the parent's size into account, [`offsetWidth` and
  `offsetHeight`](https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model/Determining_the_dimensions_of_elements#how_much_room_does_it_use_up)
  are used.
</Tip>

## DOM reference

The context provided by the `<Canvas>` component contains a `dom` element. It
refers to the DOM element that a particular view is rendered into. In the most
common case, this is the wrapper of the `canvas` element provided by Threlte.


================================================
File: apps/docs/src/content/reference/core/components.mdx
================================================
---
category: '@threlte/core'
name: Components
order: -0.5
isDivider: true
---


================================================
File: apps/docs/src/content/reference/core/getting-started.mdx
================================================
---
category: '@threlte/core'
name: Getting Started
order: -1
---

The package `@threlte/core` is the core package of the Threlte framework. It provides the basic
functionality of the framework, such as the `<Canvas>` and `<T>` components, and hooks to interact
with the Threlte state.

## Installation

```bash title="Terminal"
npm install @threlte/core three @types/three
```

## Usage

Every Threlte application must be wrapped in a [`<Canvas>` component](/docs/reference/core/canvas). This component is responsible
for creating `THREE.WebGLRenderer` and providing a state for every child component.

```svelte title="App.svelte"
<script lang="ts">
  import { Canvas } from '@threlte/core'
  import Scene from './Scene.svelte'
</script>

<Canvas>
  <Scene />
</Canvas>
```

The main building block of a Threlte application is the [`<T>` component](/docs/reference/core/t). Use this component to instantiate
any Three.js object available in the `THREE` namespace.

```svelte title="Scene.svelte"
<script lang="ts">
  import { T } from '@threlte/core'
</script>

<T.PerspectiveCamera
  position={[10, 10, 10]}
  oncreate={(ref) => {
    ref.lookAt(0, 0, 0)
  }}
/>

<T.Mesh>
  <T.BoxGeometry args={[1, 1, 1]} />
  <T.MeshBasicMaterial color="red" />
</T.Mesh>
```


================================================
File: apps/docs/src/content/reference/core/helpers.mdx
================================================
---
category: '@threlte/core'
name: Helpers
order: 6
isDivider: true
---


================================================
File: apps/docs/src/content/reference/core/hooks.mdx
================================================
---
category: '@threlte/core'
name: Hooks
order: 5
isDivider: true
---


================================================
File: apps/docs/src/content/reference/core/plugins.mdx
================================================
---
category: '@threlte/core'
name: Plugins
sourcePath: 'packages/core/src/lib/plugins'
order: 6.1
---

If you want to learn more about authoring plugins, see the [plugins section of the learn guide](/docs/learn/advanced/plugins).

## `injectPlugin`

The function `injectPlugin` adds a plugin to all descendant `<T>` components of the component that
invokes it. This means that you can add plugins to a specific part of your scene graph without
affecting the rest of the scene graph.

```ts
import { injectPlugin } from '@threlte/core'

injectPlugin('plugin-name', (args) => {
  // We are *inside* a `<T>` component instance

  // args is reactive and holds a reference to `ref`,
  // `makeDefault`, `args`, `attach`, `manual`,
  // `makeDefault`, `dispose` and all other props
  // declared on the `<T>` component.

  // Use effects to react to changes in args
  $effect(() => {
    console.log(args.ref)
  })

  // Use lifecycle functions
  onMount(() => {
    console.log('mounted')
  })

  return {
    // These props are reserved for this plugin, the
    // `<T>` component instance will not act on them.
    pluginProps: ['plugin-prop-a', 'plugin-prop-b']
  }
})
```

You may also override a plugin namespace further down the tree by calling `injectPlugin` again with the same plugin name.

<Tip type="tip">
	`injectPlugin` is relying on a context provided by your root `<Canvas>` component and can therefore only be used inside a `<Canvas>` component.
</Tip>


================================================
File: apps/docs/src/content/reference/core/t.mdx
================================================
---
category: '@threlte/core'
name: <T>
sourcePath: 'packages/core/src/lib/components/T'
order: 1
type: component
---

The component `<T>` provides the means to use **any three.js export** as a
Svelte component. It does this by leveraging the rigid three.js naming and
object property structure to add and remove objects to and from the scene graph,
attach objects to parent object properties or add event listeners.

<Tip type="info">
`<T>` is the main building block of any Threlte application. Components available in `'@threlte/extras'`
are built on top of `<T>` and may provide a more convenient API for specific three.js classes.
</Tip>

## Usage Types

<details>
<summary>
  Primer on Terminology
</summary>

```ts
// Class definition:
class Mesh extends THREE.Object3D {
  constructor(geometry, material) {
    /* … */
  }
}

// Creating a class instance:
const mesh = new Mesh()

// Creating a class instance with constructor arguments:
const mesh = new Mesh(geometry, material)
```

</details>

There are two ways to use `<T>`:

- Use dot-notation to use any three.js class available at Three.js' main
  namespace `'three'`:

```svelte
<script>
  import { T } from '@threlte/core'
</script>

<T.Mesh />
```

- Pass the property `is` to `<T>`:

```svelte
<script>
  import { T } from '@threlte/core'
  import { Mesh } from 'three'
</script>

<T is={Mesh} />
```

Both ways are **equivalent and can be used interchangeably**. The latter is more
explicit and allows you to use any class definition (even if it's not exported
from Three.js' main namespace `'three'`), object instance or virtually any other
value.

The next section will discuss both ways in more detail.

### Dot-Notation

Any three.js class available at Three.js' main namespace `'three'` can be used
as a component with full type-safety. The name of the import is the same as the
name of the component. For example, the class `THREE.Mesh` can be used with the
component `<T.Mesh>`. Let's take a look at a simple example:

```svelte
<script>
  import { T } from '@threlte/core'
</script>

<T.Mesh>
  <T.BoxGeometry />
  <T.MeshBasicMaterial />
</T.Mesh>
```

Let's break this down:

- The component `<T.Mesh>` creates an instance of
  [`THREE.Mesh`](https://threejs.org/docs/index.html?q=mesh#api/en/objects/Mesh)
  which is automatically added to the scene graph.
- The component `<T.BoxGeometry>` creates an instance of `THREE.BoxGeometry`
  which is automatically ["attached"](#attach) to the property `geometry` of the
  parent `THREE.Mesh`.
- The component `<T.MeshBasicMaterial>` creates an instance of
  `THREE.MeshBasicMaterial` which is automatically ["attached"](#attach) to the
  property `material` of the parent `THREE.Mesh`.

#### Extend the default component catalogue

If you want to use a class that is not available at Three.js' main namespace
`'three'` with dot-notation, you can extend the default component catalogue. Be
aware that components used this way do not offer type-safety. Once extended, the
updated catalogue is available to all components in your application.

```svelte title="Camera.svelte" {5-7}
<script>
  import { T, extend, useThrelte } from '@threlte/core'
  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'

  extend({
    OrbitControls
  })

  const { renderer } = useThrelte()
</script>

<T.PerspectiveCamera makeDefault>
  {#snippet children({ ref })}
    <T.OrbitControls args={[ref, renderer.domElement]} />
  {/snippet}
</T.PerspectiveCamera>
```

### Property `is`

To explicitly pass a class definition to the component `<T>`, use the property
`is`. Let's take a look at the same example as above but using the property
`is`:

```svelte
<script>
  import { T } from '@threlte/core'
  import { Mesh, BoxGeometry, MeshBasicMaterial } from 'three'
</script>

<T is={Mesh}>
  <T is={BoxGeometry} />
  <T is={MeshBasicMaterial} />
</T>
```

The two examples are **equivalent** and can be used interchangeably.

The "vanilla" Three.js equivalent of both examples would be:

```ts
import { Mesh, BoxGeometry, MeshBasicMaterial } from 'three'

const mesh = new THREE.Mesh(new THREE.BoxGeometry(), new THREE.MeshBasicMaterial())
scene.add(mesh)
```

Using the property `is` comes in handy when using classes that are not exported
from Three.js' main namespace `'three'`, such as the `OrbitControls` class:

```svelte
<script>
  import { T } from '@threlte/core'
  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'
</script>

<T is={OrbitControls} />
```

#### What's happening under the hood?

If a **class definition** such as `THREE.Mesh` is provided to the property `is`,
it creates an instance of that class which we call `ref` – the component's
reference to the three.js object:

```svelte
<T is={Mesh} />
```

If a **class instance** (such as `new THREE.Mesh()`) or **any other value** is
provided, the component uses this value as-is:

```svelte
<script>
  const mesh = new Mesh()
</script>

<T is={mesh} />
```

Depending on the `is` property value types, Threlte makes certain assumptions:

- If the value passed to `is` is extending `THREE.Object3D` it's added to the
  scene graph.
- If the value passed to `is` is a disposable, it's disposed `onDestroy` or
  whenever the `args` change and a new `ref` is created.
- If the value passed to `is` is has a property `addEventListener`, you can add
  [event callbacks](#events).
- If the value passed to `is` is extending `THREE.Camera`, certain
  [camera-related properties](#camera-props) are available.

## Props

The `<T>` component has a set of fixed props (namely `args`, `is`, `attach`,
`manual`, `makeDefault` and `dispose`) that are used to set up the Three.js
object. On top of that, you can use arbitrary props to reactively set any
property of the underlying Three.js object.

### Three.js object props

To understand how it works, let's have a look at a simple example. Let's say we
want to render a simple cube. We can do this by using the `<T>` component:

```svelte
<script>
  import { T } from '@threlte/core'
</script>

<T.Mesh>
  <T.BoxGeometry />
  <T.MeshBasicMaterial />
</T.Mesh>
```

Using automatic [**attach**](/docs/reference/core/t#attach), the geometry as
well as the material are assigned to the mesh. What if we want to change the
color of the material to `"red"`? We can do this by using the `color` prop:

```svelte {7}m
<script>
  import { T } from '@threlte/core'
</script>

<T.Mesh>
  <T.BoxGeometry />
  <T.MeshBasicMaterial color="red" />
</T.Mesh>
```

Keep in mind that this property is not _hard-wired_. We can use any property of
the underlying Three.js object as a prop on the `<T>` component. For example, we
can also set the `position` property of the `THREE.Mesh`:

```svelte {5}m
<script>
  import { T } from '@threlte/core'
</script>

<T.Mesh position={[0, 1, 0]}>
  <T.BoxGeometry />
  <T.MeshBasicMaterial color="red" />
</T.Mesh>
```

Because the property `position` of a `THREE.Mesh` is a `THREE.Vector3` the value
we have to provide is what is passed to the [`set`
function](https://threejs.org/docs/index.html?q=mesh#api/en/math/Vector3.set) of
the `THREE.Vector3` class. In this case, we pass an array of three numbers (`[x,
y, z]`). Using an editor like VS Code, you benefit from type hints and
auto-completion.

We only changed the `y` coordinate of the position, so we can use a **pierced
prop** to only change the `y` coordinate:

```svelte {5}m
<script>
  import { T } from '@threlte/core'
</script>

<T.Mesh position.y={1}>
  <T.BoxGeometry />
  <T.MeshBasicMaterial color="red" />
</T.Mesh>
```

This way, we get less updates of the underlying Three.js object because the
value of the prop is a primitive value which can easily be compared to the
previous value. Unfortunately with pierced props we miss out on the type hints
and auto-completion.

<Tip
  type="warning"
  title="Constant prop types"
>
  The type of an inferred prop (or "auto prop") must be constant. This means that the type of a prop
  must not change for the lifetime of the component. For instance you can't use a variable as a prop
  that is an array of numbers and then later on change the value of that variable to a single
  number. This is considered a type change and therefore not allowed.
</Tip>

### args

Three.js objects are **class instances**. When Instantiating these objects,
they can receive one-time constructor arguments (`new THREE.SphereGeometry(1,
32)`). In Threlte, constructor arguments are always passed as an array via the
property `args`. Changing `args` later on should be avoided as that will
reconstruct the class instance.

- If a **class definition** such as `THREE.BoxGeometry` is provided to the
  property `is`, the property `args` is used to instantiate the class: `<T
is={BoxGeometry} args={[1, 2, 1]}>` equals `new BoxGeometry(1, 2, 1)`.

### attach

Use `attach` to _attach_ objects to other objects.

The following attaches a material to the material property of a mesh and a
geometry to the geometry property:

```svelte
<T.Mesh>
  <T.MeshBasicMaterial attach="material" />
  <T.BoxGeometry attach="geometry" />
</T.Mesh>
```

<Tip type="tip">
  All materials receive `attach="material"`, and all geometries receive `attach="geometry"`
  automatically. You do not strictly have to type it out!
</Tip>

- The object referenced by the `<T>` component is "attached" to a parent objects
  property.

```svelte
<script>
  import { MeshStandardMaterial } from 'three'
  export let texture
</script>

<T is={MeshStandardMaterial}>
  <!-- Attaches the texture to the property "map" of the parent material -->
  <T
    is={texture}
    attach="map"
  />
</T>
```

- `attach` can be a dot-notated path to a nested parent property:

```svelte
<T.DirectionalLight>
  <!--
    Attaches an instance of a THREE.OrthographicCamera
    to the property camera of the property shadow of the
    parent THREE.DirectionalLight
  -->
  <T.OrthographicCamera
    args={[-1, 1, 1, -1, 0.1, 100]}
    attach="shadow.camera"
  />
</T.DirectionalLight>
```

- `attach` can also be a function which is called when the component is created.
  This function receives the parent, the closest upstream parent
  `THREE.Object3D` and the value inferred from the property `is` as arguments.
  It can return a function which is called whenever the component is destroyed
  or the `args` change and a new `ref` is created:

```svelte
<T.DirectionalLight>
  <!--
    Attaches an instance of a THREE.OrthographicCamera
    to the property camera of the property shadow of the
    parent THREE.DirectionalLight
  -->
  <T.OrthographicCamera
    args={[-1, 1, 1, -1, 0.1, 100]}
    attach={({ ref, parent, parentObject3D }) => {
      console.log('attaching', ref, parent, parentObject3D)
      parent.shadow.camera = ref
      return () => {
        parent.shadow.camera = null
      }
    }}
  />
</T.DirectionalLight>
```

- You may also pass an object3D instance to the `attach` prop. This allows you to
  attach the object to a specific parent object, essentially acting as a portal.

```svelte
<T
  is={Mesh}
  attach={otherObject}
/>
```

- To disable attaching, pass `false`. This is useful if you want to attach the
  object manually:

```svelte
<T
  is={Mesh}
  attach={false}
/>
```

### Camera Props

By default Threlte is responsive and will set up cameras properly on resize
(aspect ratio etc). Cameras can be controlled manually by setting `manual` to
`true`. This will opt out of projection matrix recalculation when the drawing
area resizes or other camera-related properties change.

```svelte
<T
  is={PerspectiveCamera}
  manual
/>
```

Use the property `makeDefault` to set a camera to the default rendering camera.

```svelte
<T
  is={PerspectiveCamera}
  makeDefault
/>
```

<Tip type="warning">
  A common mistake is to forget setting `makeDefault`. If you do not set a camera to be the default
  camera, the scene will not be rendered through this camera but through Threlte's default camera.
</Tip>

## Events

### Object Events

Adding an event listener to a component will also add the corresponding event
listener to the three.js class instance. The event will be forwarded and the
native payload is available as the first argument to the event listener.

This will listen to the "change" event on the `THREE.OrbitControls`:

```svelte
<T
  is={OrbitControls}
  onchange={(e) => console.log('change:', e)}
/>
```

### Create Event

All `<T>` components also emit the `create` event when the underlying three.js
class instance is created. This can be used to access the instance from the
parent component or do tasks on the objects upon creation. The event handler is
called with a reference to the object. You may return a cleanup callback. It
will be invoked when the component unmounts or when the object is
re-instantiated.

```svelte
<T.PerspectiveCamera
  oncreate={(ref) => {
    // Look at the center
    ref.lookAt(0, 0, 0)

    return () => {
      // Do something when the camera is disposed
    }
  }}
/>
```

### Interaction Events

By default, `<T>` doesn't have any click, pointer or wheel events; however,
pointer events can be enabled using the
[`interactivity`](/docs/reference/extras/interactivity) plugin.

## Snippet Props

The object referenced by the component is available as the snippet prop `ref`:

```svelte
<T.PerspectiveCamera>
  {#snippet children({ ref: camera })}
    <!--
      The prop "ref" is used to reference the
      camera and instantiate the OrbitControls
    -->
    <T
      is={OrbitControls}
      args={[camera, renderer.domElement]}
    />
  {/snippet}
</T.PerspectiveCamera>
```

## Bindings

The object referenced by the component is available as the binding `ref`:

```svelte
<script>
  let camera = $state()
  $effect(() => {
    console.log(camera) // THREE.PerspectiveCamera
  })
</script>

<T.PerspectiveCamera bind:ref={camera} />
```

## Extending the Default Component Catalogue

By default when using the dot-notation to access Three.js objects (e.g.
`<T.Mesh>`), Threlte will automatically import the corresponding class from the
namespance `'three'`. If you want to use a custom class or classes from Three.js
that are available elsewhere (like `OrbitControls`), you can **extend the default
catalogue** with the `extend` function:

```svelte
<script>
  import { extend, T } from '@threlte/core'
  import { CustomMesh } from './MyCustomMesh.ts'

  extend({
    CustomMesh
  })
</script>

<T.CustomMesh />
```

### Custom Component Catalogue Types

By default, TypeScript will not pick up custom custom items added to the
catalogue by using the `extend` function.

To extend the default catalogue types, define the `Threlte.UserCatalogue` type
in your ambient type definitions. In a typical SvelteKit application, you can
find these [in `src/app.d.ts`](https://svelte.dev/docs/kit/types#app.d.ts).

```ts title="src/app.d.ts"
import type { UserCatalogue } from '@threlte/core'

declare global {
  namespace App {
    // interface Error {}
    // interface Locals {}
    // interface PageData {}
    // interface PageState {}
    // interface Platform {}
  }

  namespace Threlte {
    interface UserCatalogue {
      CustomMesh: typeof CustomMesh
    }
  }
}

export {}
```

## Plugins

The component `<T>` can be extended in functionality with [Threlte
Plugins](/docs/reference/core/plugins).

### Custom Prop Types

Plugins may add custom props to the `<T>` component. By default, these props are
not picked up by TypeScript.

To extend the types of the `<T>` component and define custom prop types, define
the `Threlte.UserProps` type in your ambient type definitions. In a typical
SvelteKit application, you can find these type definitions [in
`src/app.d.ts`](https://svelte.dev/docs/kit/types#app.d.ts).

```ts title="src/app.d.ts"
declare global {
  namespace App {
    // interface Error {}
    // interface Locals {}
    // interface PageData {}
    // interface PageState {}
    // interface Platform {}
  }

  namespace Threlte {
    interface UserProps {
      myProp?: string
    }
  }
}

export {}
```

```svelte
<!-- The prop "myProp" is now available on the <T> component and strongly typed -->
<T myProp="foo" />
```


================================================
File: apps/docs/src/content/reference/core/use-loader.mdx
================================================
---
category: '@threlte/core'
name: useLoader
sourcePath: 'packages/core/src/lib/hooks/useLoader.ts'
order: 5.4
---

A hook to load data with an arbitrary `THREE` loader class. The result of `load`
is cached and subsequent calls with the same arguments will yield the same
return value (i.e. the same reference) across the entire Threlte app. The hook
can use async loaders (using `loader.loadAsync`) as well as sync/callback-based
loaders (using `loader.load`) and will default to the async version if
available.

```typescript
const loader = useLoader(AudioLoader)
const soundA = loader.load('audio/ambient_ocean.ogg')
// -> `soundA` is an AsyncWritable<AudioBuffer> that
// resolves/is populated once the asset is loaded.

// somewhere else …
const soundB = loader.load('audio/ambient_ocean.ogg')
// -> `soundB` is also an AsyncWritable<AudioBuffer>
// that resolves/is populated with the same reference
// as `soundA` once the asset is loaded.
```

### Instantiating A Loader

A loader must always be instantiated at the top level of a component. This is because the loader is depending on an application-wide cache:

```svelte
<script>
  import { useLoader } from '@threlte/core'
  import { TextureLoader } from 'three'

  const loader = useLoader(TextureLoader)
</script>
```

A loader can be **extended**, to add custom features:

```svelte
<script>
  import { useLoader } from '@threlte/core'
  import { TextureLoader } from 'three'

  const loader = useLoader(CustomTextureLoader, {
    extend: (loader) => {
      // do something with the loader, e.g. add DRACO support for
      // GLTFLoader or add custom headers for TextureLoader.
    }
  })
</script>
```

If the constructor of a particular loader accepts arguments, they must be passed
as an array to the option `args` of the second argument to `useLoader`:

```svelte
<script>
  import { useLoader, useThrelte } from '@threlte/core'
  import { SplatLoader } from '@pmndrs/vanilla'

  const { renderer } = useThrelte()

  const loader = useLoader(SplatLoader, {
    args: [renderer]
  })
  // This resembles the following:
  // const loader = new SplatLoader(renderer)
</script>
```

### Loading An Asset

```svelte
<script>
  import { useLoader } from '@threlte/core'
  import { TextureLoader } from 'three'

  const texture = useLoader(TextureLoader).load('path/to/texture.png')

  // A loader must always be instantiated at the top level of a component.
  const { load } = useLoader(TextureLoader)
  const onSomeEvent = () => {
    // To load an asset outside of the top level, use the `load` method.
    const texture = load('path/to/texture.png')
  }
</script>
```

The return type of `load` is a [custom Threlte store called
`AsyncWritable`](/docs/reference/core/utilities#asyncwritable) and can be used
as a regular Svelte store. Its initial value is `undefined` and will be updated
once the asset is loaded.

The store also exposes the underlying promise methods `then` and `catch` and can therefore be directly awaited:

```svelte
<script>
  import { useLoader, T } from '@threlte/core'
  import { TextureLoader } from 'three'

  const { load } = useLoader(TextureLoader)

  const onSomeEvent = async () => {
    // Load an asset and await the result.
    const texture = await load('path/to/texture.png')
  }
</script>

<!-- Or make use of Svelte's await block -->
{#await load('path/to/texture.png') then map}
  <T.MeshStandardMaterial {map} />
{/await}
```

### Loading Multiple Assets

The function `load` of `useLoader` also accepts an array of paths in which case the return value is an array of loaded assets:

```svelte
<script>
  import { useLoader } from '@threlte/core'
  import { TextureLoader } from 'three'

  const { load } = useLoader(TextureLoader)
  const textures = load(['texture1.png', 'texture2.png'])

  $inspect($textures) // eventually [Texture, Texture]
</script>
```

<Tip type="tip">
  Keep in mind that the store will be updated and the promise resolves once all assets are loaded.
</Tip>

You can also provide a map of paths to load multiple assets at once. In this case the return value is a map of the loaded assets:

```svelte
<script>
  import { useLoader } from '@threlte/core'
  import { TextureLoader } from 'three'

  const { load } = useLoader(TextureLoader)
  const textures = load({
    texture1: 'texture1.png',
    texture2: 'texture2.png'
  })

  $inspect($textures) // eventually { texture1: Texture, texture2: Texture }
</script>
```

### Transforming The Result

<Tip
  type="warning"
  title="Caching"
>
  The result of the transformation is cached and subsequent calls will return the same result.
</Tip>

The `load` method accepts an optional second argument to transform the result of the loader:

```svelte
<script>
  import { useLoader } from '@threlte/core'
  import { TextureLoader } from 'three'

  const { load } = useLoader(TextureLoader)
  const texture = load('path/to/texture.png', {
    transform: (texture) => {
      // do something with the texture
      return texture
    }
  })
</script>
```

The return type of the transformation is used to infer the return type of the `load` method.


================================================
File: apps/docs/src/content/reference/core/use-stage.mdx
================================================
---
category: '@threlte/core'
name: useStage
sourcePath: 'packages/core/src/lib/hooks/useStage.ts'
order: 5.2
---

<Tip type="info">
  Tasks are part of Threlte's *Task Scheduling System*. For details on how to use stages and tasks,
  see the [scheduling tasks](/docs/learn/basics/scheduling-tasks) page.
</Tip>

The hook `useStage` can be used to create or retrieve a stage.
Stages are **groups of tasks**. They are executed in a specific order.

## Creating a Stage

`useStage` will create a stage if it does not exist yet, or return the existing
stage if it does.

```ts
const { renderStage } = useThrelte()

// All tasks added to the stage `afterRenderStage`
// will be executed after the tasks of the stage `renderStage`.
const afterRenderStage = useStage('after-render', {
  after: renderStage
})
```

<Tip type="tip">
  Be aware that `useStage` never removes a stage as that's usually not needed. If a stage is created
  *once* in your Threlte app, it's available throughout the app's lifetime. If you want to remove a
  stage, you can do so by calling `removeStage` on the scheduler instance returned by `useThrelte`.
</Tip>

A stage decides **when and how its tasks are executed**. By default, a stage will
execute its tasks on every frame. You can change this behavior by passing a
`callback` option to `useStage`. This callback will be called every frame. The
first argument `delta` is the time elapsed since the last frame. The second
argument `runTasks` is a function that when invoked will run all the tasks of
the stage in their respective order. You can use it to run the tasks only when
needed (e.g. when a condition is met) or to run them multiple times. If a number
is passed as the first argument to runTasks, the tasks will receive that as the
delta.

```ts
const { renderStage } = useThrelte()

const conditionalStage = useStage('after-render', {
  after: renderStage,
  callback: (delta, runTasks) => {
    // This callback will be called every frame. The first argument is the time elapsed
    // since the last frame. The second argument is a function that will run all the
    // tasks of the stage. You can use it to run the tasks only when needed (e.g. when
    // a condition is met) or to run them multiple times. If a number is passed as the
    // first argument to runTasks, the tasks will receive that as the delta.
    if (condition) {
      runTasks()
    }
  }
})
```

## Examples

### Implement Performance Profiling

This component will implement
[three-perf](https://www.npmjs.com/package/three-perf). It expects you to call a
function `perf.begin()` before any frame callbacks are executed and `perf.end()`
after all frame callbacks have been executed, including rendering. Assuming our
app didn't add any other stages, we add a stage that runs before Threlte's
[`mainStage`](/docs/learn/basics/scheduling-tasks#default-stages) (making it the
first stage) and another stage that runs after Threlte's
[`renderStage`](/docs/learn/basics/scheduling-tasks#default-stages) (making it
the last stage). We then call `perf.begin()` in a task of the first stage and
`perf.end()` in a task of the second stage.

```svelte title="ThreePerf.svelte"
<script>
  import { useStage, useTask, useThrelte } from '@threlte/core'
  import { ThreePerf } from 'three-perf'

  const { renderer, mainStage, renderStage } = useThrelte()

  const perf = new ThreePerf({
    anchorX: 'left',
    anchorY: 'top',
    domElement: document.body,
    renderer
  })

  const beforeMainStage = useStage('three-perf-begin', {
    before: mainStage
  })

  useTask(
    () => {
      perf.begin()
    },
    { stage: beforeMainStage }
  )

  const afterRenderStage = useStage('three-perf-end', {
    after: renderStage
  })

  useTask(
    () => {
      perf.end()
    },
    { stage: afterRenderStage }
  )
</script>
```


================================================
File: apps/docs/src/content/reference/core/use-task.mdx
================================================
---
category: '@threlte/core'
name: useTask
sourcePath: 'packages/core/src/lib/hooks/useTask.ts'
order: 5.21
---

<Tip type="info">
  Tasks are part of Threlte's *Task Scheduling System*. For details on how to use stages and tasks,
  see the [scheduling tasks](/docs/learn/basics/scheduling-tasks) page.
</Tip>

The hook `useTask` is used to create a
[task](/docs/learn/basics/scheduling-tasks#tasks) that is used to run code on
every frame.

## Creating an Anonymous Task

In its most basic form, `useTask` takes a callback function as its argument. This
function will be executed on every frame, starting on the next frame. It receives a `delta`, representing the time since the last frame as its
argument. By default, the created task is added to [Threlte's
`mainStage`](#default-stages) in an arbitrary order (i.e. without dependencies).

```ts
const { start, stop, started, task } = useTask((delta) => {
  // This function will be executed on every frame
})
```

It returns an object with the following properties:

- `start`: A function that starts the task. It will be executed on the next
  frame. Note that by default a task is started automatically.
- `stop`: A function that stops the task. It will not be executed on the next
  frame.
- `started`: A boolean Svelte `Readable` store indicating whether the task is
  started or not.
- `task`: The task itself. You can use it to indicate a dependency to this task
  on another task.

## Creating a Keyed Task

You can _key_ a task by passing it as the first argument to `useTask`. This
makes referencing this task easier across your app. The key can be any `string`
or `symbol` value that is unique across all tasks in the stage it is added to.

```ts
const {
  start,
  stop,
  started,
  task: someTask
} = useTask('some-task', (delta) => {
  // This function will be executed on every frame
})
```

## Creating a Task in a Stage

You can pass a stage that the task should be added to as an option to `useTask`,
the stage can be passed by value or key. If no stage is passed, the task will be
added to [Threlte's
`mainStage`](/docs/learn/basics/scheduling-tasks#default-stages).

```ts
useTask(
  (delta) => {
    // This function will be executed on every frame as a
    // task in the stage `afterRenderStage`.
  },
  { stage: afterRenderStage }
)
```

## Task Dependencies

A common use case for tasks is to run code after another task has been executed. Imagine
a game where an object is transformed by user input in one task and a camera follows that
object in another task. The camera task should be executed after the object has been
transformed.

To control the order in which tasks are executed in a stage, you can pass a
`before` and `after` option to `useTask`. The tasks passed to these options are
called **dependencies** and can be a task itself, the key of a task or an array
of tasks or keys. The referenced tasks must be in the same stage as the task you
are creating.

Task dependencies **can be created in any order** if they are passed by key.
This means that you can declare a dependency (with `before` or `after`) on a
task that is created later in your code. The declared dependencies will be taken
into account when they are created later on.

<Tip type="warning">
  {' '}
  If a task is passed by reference to the `before` or `after` option, the task created by `useTask`
  will automatically be added to the same stage as the task it depends on. If you pass a key instead
  and the task you want to reference is **not** in [Threlte's
  `mainStage`](/docs/learn/basics/scheduling-tasks#default-stages), you will also need to pass the
  stage, either by value or key.{' '}
</Tip>

## Examples

### Starting and Stopping Tasks

By default, a task is started automatically. You can set it to not start
automatically by passing `autoStart: false` as an option to `useTask`. You can
then start and stop the task manually using the `start` and `stop` functions:

```ts
const { start, stop, started } = useTask(
  (delta) => {
    // do something
  },
  { autoStart: false }
)

// start the task
start()

// stop the task
stop()

// check if the task is started
$inspect($started)
```

### `useTask` and On-Demand Rendering

By default, `useTask` will automatically invalidate the current frame and
thereby request a re-render on the next frame. Most of the times, this is what
you want. However, if you want more control over when things are re-rendered,
you can pass `autoInvalidate: false` as an option to `useTask`. This will prevent
the task from automatically invalidating the current frame. You can then
invalidate the frame manually using the `invalidate` function returned by
`useThrelte`:

```ts
const { invalidate } = useThrelte()

const { start, stop, started } = useTask(
  (delta) => {
    // do something
    // invalidate the current frame
    if (someCondition) {
      invalidate()
    }
  },
  { autoInvalidate: false }
)
```

### Update Objects

To update objects in your scene, you can use the `useTask` hook to create a task
that is executed on every frame. The delta time is passed as the first argument
to make animations frame rate independent.

```svelte
<script>
  import { T, useTask } from '@threlte/core'
  import { Mesh } from 'svelte-three'

  let mesh

  useTask((delta) => {
    if (!mesh) return
    mesh.rotation.y += delta * 0.5
  })
</script>

<T.Mesh bind:ref={mesh}>
  <T.BoxGeometry />
</T.Mesh>
```

### Custom Render Pipeline

To create a custom render pipeline, add a task to Threlte's
[`renderStage`](/docs/learn/basics/scheduling-tasks#default-stages) which by
default only runs its tasks when a re-render is needed. Be sure to set the
property `autoRender` to `false` on the `<Canvas>` component **or inside the
`<Renderer>` component** to prevent Threlte from automatically rendering your
scene.

```svelte title="CustomRenderer.svelte"
<script>
  import { useTask, useThrelte } from '@threlte/core'
  import { onMount } from 'svelte'

  const { renderStage, autoRender } = useThrelte()

  // disable auto rendering
  onMount(() => {
    let before = autoRender.current
    autoRender.set(false)
    return () => autoRender.set(before)
  })

  useTask(
    (delta) => {
      // render your scene here
    },
    { stage: renderStage, autoInvalidate: false }
  )
</script>
```

### Post Processing

This example demonstrates how to use `useTask` to implement post processing
effects using the library
[`postprocessing`](https://github.com/pmndrs/postprocessing).

1. Create a `<Renderer>` component. Be sure to set the option `autoInvalidate`
   of `useTask` to `false` to prevent Threlte from automatically invalidating the
   render stage.

```svelte title="Renderer.svelte"
<script>
  import { useThrelte, useTask } from '@threlte/core'
  import { onMount } from 'svelte'
  import {
    EffectComposer,
    EffectPass,
    RenderPass,
    SMAAEffect,
    SMAAPreset,
    BloomEffect,
    KernelSize
  } from 'postprocessing'

  const { scene, renderer, camera, size } = useThrelte()

  // Adapt the default WebGLRenderer: https://github.com/pmndrs/postprocessing#usage
  const composer = new EffectComposer(renderer)

  const setupEffectComposer = (camera) => {
    composer.removeAllPasses()
    composer.addPass(new RenderPass(scene, camera))
    composer.addPass(
      new EffectPass(
        camera,
        new BloomEffect({
          intensity: 1,
          luminanceThreshold: 0.15,
          height: 512,
          width: 512,
          luminanceSmoothing: 0.08,
          mipmapBlur: true,
          kernelSize: KernelSize.MEDIUM
        })
      )
    )
    composer.addPass(
      new EffectPass(
        camera,
        new SMAAEffect({
          preset: SMAAPreset.LOW
        })
      )
    )
  }

  // We need to set up the passes according to the camera in use
  $effect(() => {
    setupEffectComposer($camera)
  })
  $effect(() => {
    composer.setSize($size.width, $size.height)
  })

  const { renderStage, autoRender } = useThrelte()

  // We need to disable auto rendering as soon as this component is
  // mounted and restore the previous state when it is unmounted.
  onMount(() => {
    let before = autoRender.current
    autoRender.set(false)
    return () => autoRender.set(before)
  })

  useTask(
    (delta) => {
      composer.render(delta)
    },
    { stage: renderStage, autoInvalidate: false }
  )
</script>
```

2. Use the `<Renderer>` component in your app. To disable automatic rendering of
   your scene, Set `autoRender` to `false` on the `<Canvas>` component.

```svelte title="App.svelte"
<script>
  import { Canvas } from '@threlte/svelte'
  import Renderer from './Renderer.svelte'
</script>

<Canvas>
  <Renderer />
</Canvas>
```

<Tip type="warning">
  When using SvelteKit (or more broadly, SSR) be sure to add `ssr: { noExternal: ['postprocessing' ]}` to your `vite.config.js`.
</Tip>


================================================
File: apps/docs/src/content/reference/core/use-threlte-user-context.mdx
================================================
---
category: '@threlte/core'
name: useThrelteUserContext
sourcePath: 'packages/core/src/lib/hooks/useThrelteUserContext.ts'
order: 5.5
---

The `UserContext` is a store scoped to the context of your root `<Canvas>` component and can be used to
store and retrieve arbitrary data from anywhere in the Threlte app.
The `UserContext` contains `UserContextEntries`, which are arbitrary objects in a certain `namespace`.
Because it's scoped, it's especially interesting for authoring reusable components and inter-component communication.
In fact, the components [`<OrbitControls>`](/docs/reference/extras/orbit-controls) and
[`<TransformControls>`](/docs/reference/extras/transform-controls) from `'@threlte/extras'` use this method
to communicate with each other.

`useThrelteUserContext` can set and get the user context store at the same time.

### Get the user context store

If no `namespace` is provided, the whole user context store is returned.

```svelte
<script>
  import { useThrelteUserContext } from '@threlte/core'

  const userCtx = useThrelteUserContext()
  console.log($userCtx) // -> { 'some-context': { foo: 'bar' } }
</script>
```

If a `namespace` is provided, the hook returns a derived store.

```svelte
<script>
  import { useThrelteUserContext } from '@threlte/core'

  const ctx = useThrelteUserContext('some-context')
  console.log($ctx) // -> { foo: 'bar' }
</script>
```

### Set the user context store

- If a `UserContextEntry` is passed to the hook, and the `namespace` is not set, the `UserContextEntry` is set at the namespace and the `UserContextEntry` is returned.
- If a `UserContextEntry` is passed to the hook, and the `namespace` is set, by default the `UserContextEntry` is **not set** and the existing `UserContextEntry` is returned.

```svelte
<script>
  import { useThrelteUserContext } from '@threlte/core'

  const getCtx = () => {
    return {
      foo: 'bar'
    }
  }

  const ctx = useThrelteUserContext('some-context', getCtx)
  console.log(ctx) // -> { foo: 'bar' }
</script>
```

By default, when a context is set at a given namespace, setting it again will be ignored.
You can override this behaviour:

```svelte
<script>
  import { useThrelteUserContext } from '@threlte/core'

  const getCtx = () => {
    return {
      foo: 'bar'
    }
  }

  const ctx = useThrelteUserContext('some-context', getCtx, { exising: 'merge' })
  console.log(ctx) // -> { foo: 'bar' }
</script>
```


================================================
File: apps/docs/src/content/reference/core/use-threlte.mdx
================================================
---
category: '@threlte/core'
name: useThrelte
sourcePath: 'packages/core/src/lib/hooks/useThrelte.ts'
order: 5.1
---

This hook lets you consume the main Threlte context (`ThrelteContext`) of your application (scoped to the root `<Canvas>`) which contains the renderer, camera, scene and other properties.

Use this hook to manually invalidate the current frame …

```ts
const { invalidate } = useThrelte()
invalidate()
```

… access the renderer or the currently active camera …

```ts
const { renderer, camera } = useThrelte()
console.log(renderer, $camera)
```

… or update render properties:

```ts
const { toneMapping } = useThrelte()
toneMapping.set(THREE.LinearToneMapping)
```

### Usage

<Tip type="info">
  This hook relies on context passed down by the [`<Canvas>`](/docs/reference/core/canvas) component and can only be used in a child of that component.
</Tip>

```ts
const {
  dom, // HTMLElement
  size, // Readable<DOMRect>
  canvas, // HTMLCanvasElement
  camera, // CurrentWritable<Camera>
  scene, // Scene
  dpr, // CurrentWritable<number>
  renderer, // WebGLRenderer
  renderMode, // CurrentWritable<'always' | 'on-demand' | 'manual'>
  autoRender, // CurrentWritable<boolean>
  invalidate, // () => void
  advance, // () => void
  scheduler, // Scheduler
  mainStage, // Stage
  renderStage, // Stage
  autoRenderTask, // Task
  shouldRender, // () => boolean
  colorManagementEnabled, // CurrentWritable<boolean>
  colorSpace, // CurrentWritable<ColorSpace>
  toneMapping, // CurrentWritable<ToneMapping>
  shadows // CurrentWritable<boolean | ShadowMapType>
} = useThrelte()
```

### `renderMode`

If the [renderMode is set to `'on-demand'`](/docs/reference/core/canvas) and you are manually editing objects or materials, be sure to invalidate the current frame to request a rerender:

```ts
const { invalidate } = useThrelte()

invalidate()
```

If the [renderMode is set to `'manual'`](/docs/reference/core/canvas) you must manually trigger a re-render:

```ts
const { advance } = useThrelte()

advance()
```

The property can be changed at any time, but it will only take effect on the next frame.


================================================
File: apps/docs/src/content/reference/core/utilities.mdx
================================================
---
category: '@threlte/core'
name: Utilities
sourcePath: 'packages/core/src/lib/lib/storeUtils.ts'
order: 6.2
---

Threlte comes with a few utilities that are catered towards the use in a Threlte
application but can also be used in other projects.

## `watch`

Watch a single store or multiple stores and call a callback when they change to
trigger side effects. The callback will be called immediately with the current
value of the store.

```ts
const store = writable(0)

watch(store, (value) => {
  console.log(value) // 0
})
```

<Tip type="info">This utility function needs to be called during component initialization.</Tip>

You can also watch multiple stores:

```ts
const store1 = writable(0)
const store2 = writable(1)

watch([store1, store2], ([value1, value2]) => {
  console.log(value1, value2) // 0 1
})
```

The callback can return a cleanup function that will be called when the stores change again.

```ts
const store = writable(0)

watch(store, (value) => {
  console.log(value) // 0
  return () => {
    console.log('cleanup')
  }
})
```

---

## `observe`

Watch a single or multiple reactive values or stores and call a callback when
they change. This is the runes-equivalent to [`watch`](#watch) and supports both
stores and reactive values. It does however serve a different purpose: As
opposed to `watch`, the provided callback is not called synchronously when
stores or reactive values change but in the next microtask. This utility uses
[Svelte's `$effect`](https://svelte.dev/docs/svelte/$effect) under the hood.

```ts
let count = $state(0)
let name = $state('John')
const iteration = writable(0)

observe(
  () => [count, iteration],
  ([count, iteration]) => {
    // This callback is only called when `count` or `iteration` changes
    // and not when `name` changes.
    console.log(count, iteration, name)
  }
)
```

---

## `observe.pre`

This is the same as [`observe`](#observe) but it uses
[`$effect.pre`](https://svelte.dev/docs/svelte/$effect#$effect.pre) instead of
`$effect`.

---

## `asyncWritable`

Creates a writable store that is initialized with a promise. The store also directly
implements the `then` and `catch` methods of the promise so that it can be
used in `await` expressions and `{#await}` blocks of Svelte.

```svelte
<script>
  import { asyncWritable } from '@threlte/core'

  const asyncOperation = async () => {
    // Do something async
  }
  const store = asyncWritable(asyncOperation())
  $inspect($store)
</script>

<h1>
  {#await store then data}
    // Do something with the data
  {/await}
</h1>
```

This type of store is the return type of the [`load` function of `useLoader`](/docs/reference/core/use-loader#loading-an-asset).

If an error occurs in the promise, the error will be logged to the console
and the error can be accessed via the `error` property of the store which is also a store.

```svelte
<script>
  import { asyncWritable } from '@threlte/core'

  const asyncOp = async () => {
    throw new Error('Something went wrong')
  }

  const store = asyncWritable(asyncOp())
  const error = store.error

  $inspect($store, $error)
</script>
```

---

## `currentWritable`

A writable store that also has a `current` property that is updated synchronously.
For use in non-reactive contexts e.g. loops where unwrapping a store every frame
(with Svelte's `get` method) is expensive.

```ts
const store = currentWritable(0)

useTask(() => {
  console.log(store.current) // 0
})
```

---

## `isInstanceOf`

Check if an object is an instance of a given THREE class. This function can be
used as a type guard and as an alternative to
[`instanceof`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof)
which is prone to error and [slower](https://jsperf.app/jazula). This function
uses the `isFoo` property that THREE classes have to determine if an object is
of a particular class.

```ts
const obj = new Object3D()

// Later, in an unknown context
if (isInstanceOf(obj, 'Object3D')) {
  obj.position.x = 5
}
```


================================================
File: apps/docs/src/content/reference/docs/docs.mdx
================================================
---
category: 'Documentation'
name: Writing Documentation
---

## Code Blocks

Code blocks are written in .mdx files using the three-backtick syntax. The language is added after the first set of backticks.

{/* prettier-ignore-start */}
<pre>
  <code>\```svelte
		\<T.Mesh position=\{5\} />
		\```</code>
</pre>
{/* prettier-ignore-end */}

renders as:

```svelte
<T.Mesh position=\{5\} />
```

### Highlighting Lines

You can highlight lines by adding an attribute to the code block.

**Highlight a single line**

{/* prettier-ignore-start */}
<pre>
  <code>\```svelte \{2\}
		\<T.Mesh position=\{5\}\>
		\<T.Mesh position=\{10\}\>
		\<T.Mesh position=\{20\}\>
		\```</code>
</pre>
{/* prettier-ignore-end */}

```svelte {2}
<T.Mesh position={5}>
<T.Mesh position={10}>
<T.Mesh position={20}>
```

**Highlight multiple lines**

{/* prettier-ignore-start */}
<pre>
  <code>\```svelte \{2\,3}
		\<T.Mesh position=\{5\}\>
		\<T.Mesh position=\{10\}\>
		\<T.Mesh position=\{20\}\>
		\```</code>
</pre>
{/* prettier-ignore-end */}

```svelte {2,3}
<T.Mesh position={5}>
<T.Mesh position={10}>
<T.Mesh position={20}>
```

**Highlight a range**

{/* prettier-ignore-start */}
<pre>
  <code>\```svelte \{1-3}
		\<T.Mesh position=\{5\}\>
		\<T.Mesh position=\{10\}\>
		\<T.Mesh position=\{20\}\>
		\```</code>
</pre>
{/* prettier-ignore-end */}

```svelte {1-3}
<T.Mesh position={5}>
<T.Mesh position={10}>
<T.Mesh position={20}>
```

**Highlight as added, removed or modified line**

{/* prettier-ignore-start */}
<pre>
  <code>\```svelte \{1}+ \{2}- \{3}m
		\<T.Mesh position=\{5\}\>
		\<T.Mesh position=\{10\}\>
		\<T.Mesh position=\{20\}\>
		\```</code>
</pre>
{/* prettier-ignore-end */}

```svelte {1}+ {2}- {3}m
<T.Mesh position={5}>
<T.Mesh position={10}>
<T.Mesh position={20}>
```

**Add a title**

{/* prettier-ignore-start */}
<pre>
  <code>\```svelte title="App.svelte"
		\<T.Mesh position=\{5\}\>
		\<T.Mesh position=\{10\}\>
		\<T.Mesh position=\{20\}\>
		\```</code>
</pre>
{/* prettier-ignore-end */}

```svelte title="App.svelte"
<T.Mesh position={5}>
<T.Mesh position={10}>
<T.Mesh position={20}>
```

**Add custom css classes**

{/* prettier-ignore-start */}
<pre>
  <code>\```svelte class="glow-blue/50"
		\<T.Mesh position=\{5\}\>
		\<T.Mesh position=\{10\}\>
		\<T.Mesh position=\{20\}\>
		\```</code>
</pre>
{/* prettier-ignore-end */}

```svelte class="glow-blue/50"
<T.Mesh position={5}>
<T.Mesh position={10}>
<T.Mesh position={20}>
```

## Auto-imported components

These components can be used in .mdx files without importing them.

### `<Tip>`

A tip component.

```mdx title="example.mdx"
<Tip color="orange">orange</Tip>
```

Available styles:

<Tip color="orange">`color="orange`</Tip>
<Tip color="blue">`color="blue">`</Tip>
<Tip color="dark">`color="dark">`</Tip>
<Tip color="green">`color="green"`</Tip>
<Tip type="info">`type="info"`</Tip>
<Tip type="warning">`type="warning"`</Tip>
<Tip type="danger">`type="danger"`</Tip>
<Tip type="experimental">`type="experimental"`</Tip>
<Tip type="note">`type="note"`</Tip>
<Tip type="tip">`type="tip"`</Tip>
<Tip
  type="tip"
  title="Tip with Title"
>
  `title="Tip with Title"`
</Tip>

#### Glowing Tips

Add glow to tips by adding the `glow` attribute.

<Tip
  glow
  color="orange"
>
  `color="orange"` `glow`
</Tip>

### `<Example>`

The component `<Example>` renders an example that is defined in the `src/examples` folder.

```mdx title="example.mdx"
<Example path="core/use-frame" />
```

renders as:

<Example path="core/use-frame" />

Hide the code:

```mdx title="example.mdx"
<Example
  path="core/use-frame"
  hideCode
/>
```

Hide the preview:

```mdx title="example.mdx"
<Example
  path="core/use-frame"
  hidePreview
/>
```

Expand the code section by default:

```mdx title="example.mdx"
<Example
  path="core/use-frame"
  expandCode
/>
```

Show a specific file by default:

```mdx title="example.mdx"
<Example
  path="core/use-frame"
  showFile="directory/file.ts"
/>
```

Embed the example preview as an , which helps when third party UI libraries are used that overlay the whole page like Theatre.js Studio:

```mdx title="example.mdx"
<Example
  path="core/use-frame"

/>
```


================================================
File: apps/docs/src/content/reference/extras/align.mdx
================================================
---
order: 4.11
category: '@threlte/extras'
name: '<Align>'
sourcePath: 'packages/extras/src/lib/components/Align/Align.svelte'
type: 'component'
componentSignature:
  {
    extends: { type: 'Group', url: 'https://threejs.org/docs/index.html#api/en/objects/Group' },
    props:
      [
        {
          name: 'x',
          type: 'number | false',
          default: '0',
          description: 'Align child objects on the x-axis. If a number between -1 and 1 is provided, it will be used as the alignment on the x-axis. If `false` is provided, this axis will be ignored.',
          required: false
        },
        {
          name: 'y',
          type: 'number | false',
          default: '0',
          description: 'Align child objects on the y-axis. If a number between -1 and 1 is provided, it will be used as the alignment on the y-axis. If `false` is provided, this axis will be ignored.',
          required: false
        },
        {
          name: 'z',
          type: 'number | false',
          default: '0',
          description: 'Align child objects on the z-axis. If a number between -1 and 1 is provided, it will be used as the alignment on the z-axis. If `false` is provided, this axis will be ignored.',
          required: false
        },
        {
          name: 'precise',
          type: 'boolean',
          default: 'false',
          description: 'See [setFromObject](https://threejs.org/docs/index.html?q=box3#api/en/math/Box3.setFromObject)',
          required: false
        },
        {
          name: 'auto',
          type: 'boolean',
          default: 'false',
          description: 'Injects a plugin in all child `<T>` components to automatically align whenever a component mounts or unmounts.',
          required: false
        },
        {
          name: 'stage',
          type: 'Stage',
          default: 'useStage("<Align>", { before: renderStage })',
          description: 'Bring your own stage to control when aligning occurs. If not provided, aligning will occur before the main render stage.',
          required: false
        }
      ],
    events:
      [
        {
          name: 'align',
          description: 'Fires when the child objects have been aligned.',
          payload: '{ container: Object3D, width: number, height: number, depth: number, boundingBox: Box3, boundingSphere: Sphere, align: Vector3, verticalAlignment: number, horizontalAlignment: number, depthAlignment: number }'
        }
      ],
    exports: [{ name: 'align', type: '() => void', description: 'Manually trigger an alignment.' }]
  }
---

This component will calculate a boundary box and align its children accordingly.

<Example
  path="extras/align"
  showFile="Scene.svelte"
/>

The grouped objects will be aligned on the x, y, and z axes by default.

```svelte
<script>
  import { T } from '@threlte/core'
  import { Align } from '@threlte/extras'
</script>

<Align>
  <T.Mesh position={[-1, 0, 0]}>
    <T.BoxGeometry />
    <T.MeshBasicMaterial />
  </T.Mesh>

  <T.Mesh position={[1, 0, -2]}>
    <T.BoxGeometry args={[1, 5, 2]} />
    <T.MeshBasicMaterial />
  </T.Mesh>
</Align>
```

### `x`, `y`, `z`

You can also specify a number between -1 and 1 to align the objects on a respective axis. For example, providing `x={1}` will align the objects to the left (with respect to the default camera), `x={0}` will center the children, and `x={1}` will align them to the right whereas `x={false}` will ignore that axis completely.

```svelte
<script>
  import { T } from '@threlte/core'
  import { Align } from '@threlte/extras'
</script>

<!-- Align left on the x-axis, ignore the y- and z-axes -->
<Align x={-1} y={false} z={false}>
  <T.Mesh position={[-1, 0, 0]}>
    <T.BoxGeometry />
    <T.MeshBasicMaterial />

  <T.Mesh position={[1, 0, -2]}>
    <T.BoxGeometry args={[1, 5, 2]} />
    <T.MeshBasicMaterial />
  </T.Mesh>
</Align>
```

### `auto`

By default, the component `<Align>` will calculate the bounding box and align its children when the component mounts or any relevant props change. To account for child objects being mounted or unmounted, use the property `auto`.

```svelte
<script>
  import { T } from '@threlte/core'
  import { Align } from '@threlte/extras'

  export let showOtherCube = true
</script>

<Align auto>
  <T.Mesh position={[-1, 0, 0]}>
    <T.BoxGeometry />
    <T.MeshBasicMaterial />

  {#if showOtherCube}
    <T.Mesh position={[1, 0, -2]}>
      <T.BoxGeometry args={[1, 5, 2]} />
      <T.MeshBasicMaterial />
    </T.Mesh>
  {/if}
</Align>
```

### Events

The component `<Align>` provides an event `align` which fires when the child objects have been aligned. The event payload contains the following properties:

```ts
type AlignEventData = {
  /** The outmost container group of the <Align> component */
  container: Object3D
  /** The width of the bounding box */
  width: number
  /** The height of the bounding box */
  height: number
  /** The depth of the bounding box */
  depth: number
  boundingBox: Box3
  boundingSphere: Sphere
  center: Vector3
  verticalAlignment: number
  horizontalAlignment: number
  depthAlignment: number
}
```

```svelte
<Align
  onalign={({ width }) => {
    console.log('The width of the bounding box is', width)
  }}
>
  <T.Mesh position={[-1, 0, 0]}>
    <T.BoxGeometry />
    <T.MeshBasicMaterial />
  </T.Mesh>
</Align>
```

### Snippet Props

The component `<Align>` provides a snippet prop called `align` to schedule
aligning all child objects. Be aware that this will not immediately align the
objects, but rather schedule the alignment to happen exactly _once per frame_.
It's a manual alternative to [`auto`](#auto).

```svelte
<Align>
  {#snippet children({ align })}
    {#if showOtherCube}
      <T.Mesh oncreate={align}>
        <T.BoxGeometry />
        <T.MeshBasicMaterial />
      </T.Mesh>
    {/if}
  {/snippet}
</Align>
```


================================================
File: apps/docs/src/content/reference/extras/animated-sprite-material.mdx
================================================
---
order: 5.1
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/components/AnimatedSpriteMaterial/AnimatedSpriteMaterial.svelte'
name: <AnimatedSpriteMaterial>
type: 'component'
componentSignature:
  {
    props:
      [
        {
          name: 'textureUrl',
          type: 'string',
          required: true,
          description: 'The URL of the spritesheet texture image.'
        },
        {
          name: 'dataUrl',
          type: 'string',
          required: false,
          description: 'The URL of the spritesheet JSON.'
        },
        {
          name: 'animation',
          type: 'string',
          required: false,
          description: 'The current playing animation name.'
        },
        {
          name: 'loop',
          type: 'boolean',
          required: false,
          default: 'true',
          description: 'Whether or not the current animation should loop.'
        },
        {
          name: 'autoplay',
          type: 'boolean',
          required: false,
          default: 'true',
          description: 'Controls whether or not to automatically run an animation on load.'
        },
        {
          name: 'fps',
          type: 'boolean',
          required: false,
          default: '10',
          description: 'The desired frames per second of the animation.'
        },
        {
          name: 'filter',
          type: '"nearest" | "linear"',
          required: false,
          default: '"nearest"',
          description: 'The texture filtering applied to the spritesheet.'
        },
        {
          name: 'alphaTest',
          type: 'number',
          required: false,
          default: '0.1',
          description: 'Sets the alpha value to be used when running an alpha test.'
        },
        {
          name: 'delay',
          type: 'number',
          required: false,
          default: '0',
          description: 'Delay the start of the animation in ms.'
        },
        {
          name: 'transparent',
          type: 'boolean',
          required: false,
          default: 'true',
          description: 'Whether or not the material should be transparent.'
        },
        {
          name: 'flipX',
          type: 'boolean',
          required: false,
          default: 'false',
          description: 'Whether or not the Sprite should flip sides on the x-axis.'
        },

        {
          name: 'totalFrames',
          type: 'number',
          required: false,
          default: 'rows * columns - 1',
          description: 'The total number of frames in the spritesheet.'
        },
        {
          name: 'startFrame',
          type: 'number',
          required: false,
          default: '0',
          description: 'The start frame of the current animation.'
        },
        {
          name: 'endFrame',
          type: 'number',
          required: false,
          default: 'totalFrames',
          description: 'The end frame of the current animation.'
        },
        {
          name: 'rows',
          type: 'number',
          required: false,
          default: '1',
          description: 'The number of rows in the spritesheet.'
        },
        {
          name: 'columns',
          type: 'number',
          required: false,
          description: 'The number of columns in the spritesheet.'
        }
      ],
    events:
      [
        { name: 'load', payload: 'void', description: 'Fires when all resources have loaded.' },
        { name: 'start', payload: 'void', description: 'Fires when an animation starts.' },
        { name: 'end', payload: 'void', description: 'Fires when an animation ends.' },
        { name: 'loop', payload: 'void', description: 'Fires when an animation loop completes.' }
      ],
    exports: [{ name: play, type: '() => void' }, { name: pause, type: '() => void' }]
  }
---

Provides animation tools for spritesheets.

<Example path="extras/animated-sprite-material" />

This material is most easily used by passing it a [spritesheet](https://www.aseprite.org/docs/sprite-sheet/) URL and a [JSON metadata file](https://gist.github.com/dacap/db18e5747a4b6e208d3c) URL.

Currently, JSON metadata using [Aseprite's](https://www.aseprite.org/) [hash export format](https://www.aseprite.org/docs/cli/#data) is supported.

Animation names [from tags](https://www.aseprite.org/docs/tags) can be used to transition to specific animations in the spritesheet.

```svelte {4,5}+
<T.Sprite>
  <AnimatedSpriteMaterial
    animation="Idle"
    textureUrl="./player.png"
    dataUrl="./player.json"
  />
</T.Sprite>
```

If no metadata file is provided, additional props must be passed to run an animation:

- `totalFrames`, if the spritesheet is only a single row.
- `totalFrames`, `rows`, and `columns`, otherwise.

```svelte {4-6}+
<T.Sprite>
  <AnimatedSpriteMaterial
    textureUrl="./fire.png"
    totalFrames={14}
    rows={4}
    columns={4}
  />
</T.Sprite>
```

Additionally, if a sheet with no JSON supplied has multiple animations, start and end frames must be passed to run an animation within the sheet.

```svelte {7-8}+
<T.Sprite>
  <AnimatedSpriteMaterial
    textureUrl="./fire.png"
    totalFrames={14}
    rows={4}
    columns={4}
    startFrame={4}
    endFrame={8}
  />
</T.Sprite>
```

`<AnimatedSpriteMaterial>` can be attached to a `<T.Sprite>` as well as a `<T.Mesh>`.

<Example path="extras/animated-sprite-mesh" />

In the case of a `Mesh` parent a `MeshBasicMaterial` will be used by default, instead of a `SpriteMaterial` when attached to a `Sprite`. A custom depth material will be attached when parented to a mesh to support shadows.

Any other material type can be used as well.

```svelte {3}+
<T.Mesh>
  <AnimatedSpriteMaterial
    is={THREE.MeshStandardMaterial}
    textureUrl="./fire.png"
    totalFrames={14}
  />
</T.Mesh>
```


================================================
File: apps/docs/src/content/reference/extras/ascii-renderer.mdx
================================================
---
order: 5.10
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/components/AsciiRenderer/AsciiRenderer.svelte'
name: <AsciiRenderer>
type: 'component'
componentSignature:
  {
    exports:
      [
        { name: 'start', type: '() => void', description: 'Manually start the render task' },
        { name: 'stop', type: '() => void', description: 'Manually stop the render task' },
        {
          name: 'getEffect',
          type: '() => THREE.AsciiEffect',
          description: 'Getter for the underlying AsciiEffect instance'
        }
      ],
    props:
      [
        {
          default: 'useThrelte().camera.current',
          description: 'the camera to use when renderering',
          name: 'camera',
          required: false,
          type: THREE.Camera
        },
        {
          default: 'useThrelte().scene',
          description: 'the scene to use when renderering',
          name: 'scene',
          required: false,
          type: THREE.Scene
        },
        {
          default: 'true',
          description: 'whether to automatically run the render task',
          name: 'autoRender',
          required: false,
          type: 'boolean'
        },
        {
          name: 'characters',
          default: "' .:-+*=%@#'",
          description: 'character set used by the renderer. Sorted left-to-right from least to most opaque',
          required: false,
          type: 'string'
        },
        {
          default: "'#000000'",
          description: 'background color used when `options.color` is set to `false`',
          name: 'bgColor',
          required: false,
          type: 'string'
        },
        {
          default: "'#ffffff'",
          description: 'text color used when `options.color` is set to `false`',
          name: 'fgColor',
          required: false,
          type: 'string'
        },
        {
          default: '{}',
          description: "object passed to the effect's constructor. because the effect doesn't support adjusting individual option props, whenever an option prop changes, the effect must be recreated",
          name: 'options',
          required: false,
          type: 'Three.AsciiEffectOptions'
        },
        {
          name: 'onstart',
          required: false,
          type: '() => void',
          description: 'function to call anytime the renderer has been started'
        },
        {
          name: 'onstop',
          required: false,
          type: '() => void',
          description: 'function to call anytime the renderer has been stopped'
        }
      ]
  }
---

A wrapper around Three's [AsciiEffect](https://github.com/timoxley/threejs/blob/master/examples/js/effects/AsciiEffect.js) addon. It replaces the main render function with a function that renders the scene to an HTML table and overlays it on top of the canvas. Areas with a higher "brightness" are mapped to characters that appear "fuller".

<Example path="extras/ascii-renderer/basic" />

## Usage

Typically you'd use `<AsciiRenderer>` alongside your main `Scene` component. `<AsciiRenderer>` creates an absolutely postioned table element that is appended to the dom element of the `<Canvas>`. You may need to set the wrapping element's position to `relative`

```svelte
<div>
  <Canvas>
    <AsciiRenderer />
    <Scene />
  </Canvas>
</div>

<style>
  div {
    position: relative;
  }
</style>
```

## Characters

The `characters` prop should be sorted by ascending "opaqueness".

```svelte
<AsciiRenderer characters=" #" />
```

The example above uses a character set with two characters - ` ` and `#`.

## Colors

By default the renderer sets `options.color` to `false` and will only use the colors given by the `fgColor` and `bgColor` props. `fgColor` and `bgColor` can be any acceptable CSS color string. If your colors contain an alpha component, make sure to set `options.alpha` to `true`.

If `options.color` is set to `true`, `fgColor` and `bgColor` will be ignored and the corresponding color of the scene will be used for each character.

```svelte
<AsciiRenderer options={{ color: true }} />
```

<Tip type="info">
  Setting `options.color` to `true` slows down performance. Using a static scene or manually
  rendering can help.
</Tip>

## Other Options Props

Because the effect doesn't support dynamically updating options, any time an `options` property changes, a new `AsciiEffect` is created inside `<AsciiRenderer`. For this reason, `options` is passed as an object to `<AsciiRenderer>`

- `options.block` makes the characters into color blocks. It is only applied if `options.color` is `true`.
- `options.invert` inverts the `fgColor` and `bgColor` colors.
- `options.resolution` controls how detailed the render is.
- `options.scale` controls the scale of the characters. Note that zooming the camera does not control the size of the characters.

<Tip type="info">
  A new `AsciiEffect` instance must be created anytime `options` changes because an effect can not
  have it options changed after it has been created. This is a limitation of the `AsciiEffect` addon
  from ThreeJS.
</Tip>

## Disabling the Render Task

If at some point your scene doesn't need to be rendered because it will no longer update or nothing will change between frames, you can turn off the rendering task by setting the `autoRender` prop to `false`. This will stop the render task from running which can improve performance. This is especially useful when using `options.color` which is known to slow down the renderer.

`AsciiRenderer` passes its `AsciiEffect` instance to its `children` snippet. This allows you to opt out of `AsciiEffect`'s renderering task but still use the effect it creates. It can also be used for on-demand rendering.

<Example path="extras/ascii-renderer/only-effect" />

The example above demonstrates how to render on demand. The scene is only rendered when the `color` checkbox changes. The change causes the `options` object to update which triggers a new `AsciiEffect` to be created. The effect is passed into the `<Scene>` component and an `$effect` is used to rerender the scene.


================================================
File: apps/docs/src/content/reference/extras/audio-listener.mdx
================================================
---
order: 6.2
category: '@threlte/extras'
name: '<AudioListener>'
type: 'component'
sourcePath: 'packages/extras/src/lib/audio/AudioListener/AudioListener.svelte'
componentSignature:
  {
    extends:
      {
        type: 'AudioListener',
        url: 'https://threejs.org/docs/index.html#api/en/audio/AudioListener'
      },
    props:
      [
        { name: 'id', type: 'string', required: false },
        { name: 'masterVolume', type: 'number', required: false }
      ],
    exports:
      [
        { name: 'resumeContext', type: '() => Promise<void>' },
        { name: 'audioContext', type: 'AudioContext' }
      ]
  }
---

The `<AudioListener>` represents a virtual listener of the all positional and non-positional audio effects in the scene.
An application usually creates a single `<AudioListener>` component. It is a mandatory component for audio components like `<Audio>` and `<PositionalAudio>`.
In most cases, the listener component is a child of the camera, so the 3D transformation of the camera represents the 3D transformation of the listener.

### Examples

```svelte
<script>
  import { T, Canvas } from '@threlte/core'
  import { AudioListener } from '@threlte/extras'
</script>

<Canvas>
  <T.PerspectiveCamera
    makeDefault
    position={[3, 3, 3]}
    lookAt={[0, 0, 0]}
  >
    <AudioListener />
  </T.PerspectiveCamera>
</Canvas>
```

You may pass an `id` to the `<AudioListener>` component in order to connect `<Audio>` and `<PositionalAudio>` components to specific `<AudioListener>` components:

```svelte
<script>
  import { T, Canvas } from '@threlte/core'
  import { Audio, AudioListener } from '@threlte/extras'
</script>

<Canvas>
  <T.PerspectiveCamera
    makeDefault
    position={[3, 3, 3]}
    lookAt={[0, 0, 0]}
  >
    <AudioListener
      id="left-ear"
      position={{ x: -1 }}
    />
    <AudioListener
      id="right-ear"
      position={{ x: 1 }}
    />
  </T.PerspectiveCamera>

  <Audio
    id="left-ear"
    source={'audio/left-track.mp3'}
  />
  <Audio
    id="right-ear"
    source={'audio/right-track.mp3'}
  />
</Canvas>
```


================================================
File: apps/docs/src/content/reference/extras/audio.mdx
================================================
---
order: 6.1
category: '@threlte/extras'
name: <Audio>
sourcePath: 'packages/extras/src/lib/audio/Audio/Audio.svelte'
type: 'component'
componentSignature:
  {
    extends: { type: 'Audio', url: 'https://threejs.org/docs/index.html#api/en/audio/Audio' },
    props:
      [
        {
          name: 'src',
          type: 'string | AudioBuffer | HTMLMediaElement | AudioBufferSourceNode | MediaStream',
          required: true
        },
        {
          name: 'id',
          type: 'string',
          required: false,
          default: 'default',
          description: 'The id of the AudioListener this Audio will be attached to.'
        },
        { name: 'autoplay', type: 'boolean', required: false },
        { name: 'loop', type: 'boolean', required: false },
        {
          name: 'volume',
          type: 'number',
          required: false,
          description: 'The value should range between 0 to 1. Be cautious, values outside this range might cause unintended loudness.'
        },
        { name: 'playbackRate', type: 'number', required: false },
        { name: 'detune', type: 'number', required: false }
      ],
    events:
      [
        { name: 'load', payload: 'AudioBuffer', description: 'Fired when the audio has loaded.' },
        {
          name: 'progress',
          payload: 'ProgressEvent<EventTarget>',
          description: 'Fired when the audio is loading.'
        },
        { name: 'error', payload: 'ErrorEvent', description: 'Fired when the audio fails to load.' }
      ],
    exports:
      [
        { name: play, type: '(delay?: number) => Promise<THREE.Audio>' },
        { name: pause, type: '() => THREE.Audio' },
        { name: stop, type: '() => THREE.Audio' }
      ]
  }
---

Create a non-positional (global) audio object.
This uses the [Web Audio API](https://developer.mozilla.org/en-US/Web/API/Web_Audio_API).

<Tip type="warning">
You need to have an `<AudioListener>` component in your scene in order to use `<Audio>`and `<PositionalAudio>`components. The `<AudioListener>` component needs to be mounted *before* any `<Audio>` or `<PositionalAudio>` components:

```svelte
<T.PerspectiveCamera makeDefault>
  <AudioListener />
</T.PerspectiveCamera>

<PositionalAudio />
```

</Tip>

### Example

```svelte
<script>
  import { T, Canvas } from '@threlte/core'
  import { AudioListener, Audio } from '@threlte/extras'
</script>

<Canvas>
  <T.PerspectiveCamera
    makeDefault
    position={[3, 3, 3]}
    lookAt={[0, 0, 0]}
  >
    <AudioListener />
  </T.PerspectiveCamera>

  <Audio src={'/audio/track.mp3'} />
</Canvas>
```


================================================
File: apps/docs/src/content/reference/extras/audioCategory.mdx
================================================
---
category: '@threlte/extras'
name: Audio
order: 6
isDivider: true
---


================================================
File: apps/docs/src/content/reference/extras/bake-shadows.mdx
================================================
---
order: 7.7
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/components/BakeShadows/BakeShadows.svelte'
name: '<BakeShadows>'
type: 'component'
---

`<BakeShadows>` instantly freezes all shadow maps upon mounting and unfreezes them upon unmounting. This improves performance by making all shadows static. Use `<BakeShadows` if you have a complex but static scene as the shadows will only be calculated once.

<Example path="extras/bake-shadows/basic" />

When `<BakeShadows>` is used within a `<Suspense>`, shadows will be frozen after the boundary is no longer in a suspended state. It will unfreeze if the boundary is re-suspended.

<Example path="extras/bake-shadows/spaceships" />

The example above is an ideal scene for `<BakeShadows>` because all objects are stationary and the shadows will never change.


================================================
File: apps/docs/src/content/reference/extras/billboard.mdx
================================================
---
order: 4.12
category: '@threlte/extras'
name: '<Billboard>'
sourcePath: 'packages/extras/src/lib/components/Billboard/Billboard.svelte'
type: 'component'
componentSignature:
  {
    extends: { type: 'Group', url: 'https://threejs.org/docs/index.html#api/en/objects/Group' },
    props: [{ name: 'follow', type: 'boolean | THREE.Object3D', default: 'true', required: false }]
  }
---

This component is a port of [drei's `<Billboard>`
component](https://github.com/pmndrs/drei#billboard) which rotates its contents
to always face the camera or specified object.

<Example path="extras/billboard" />

## Examples

### Basic Example

```svelte title="Billboard.svelte"
<script lang="ts">
  import { T } from '@threlte/core'
  import { Billboard } from '@threlte/extras'
</script>

<Billboard>
  <T.Mesh>
    <T.MeshStandardMaterial />
    <T.PlaneGeometry args={[2, 2]} />
  </T.Mesh>
</Billboard>
```

To disable the billboard from rotating its contents to face the camera, you can
optionally pass in a `follow` prop set to `false`.


================================================
File: apps/docs/src/content/reference/extras/contact-shadows.mdx
================================================
---
order: 4.13
category: '@threlte/extras'
name: <ContactShadows>
sourcePath: 'packages/extras/src/lib/components/ContactShadows/ContactShadows.svelte'
type: 'component'
componentSignature:
  {
    extends: { type: 'Group', url: 'https://threejs.org/docs/index.html#api/en/objects/Group' },
    props:
      [
        { name: 'opacity', type: 'number', required: false },
        { name: 'width', type: 'number', required: false },
        { name: 'height', type: 'number', required: false },
        { name: 'blur', type: 'number', required: false },
        { name: 'far', type: 'number', required: false },
        { name: 'smooth', type: 'boolean', required: false },
        { name: 'resolution', type: 'number', required: false },
        { name: 'frames', type: 'number', required: false },
        { name: 'scale', type: 'number | [x: number, y: number]', required: false },
        { name: 'color', type: 'THREE.ColorRepresentation', required: false },
        { name: 'depthWrite', type: 'boolean', required: false }
      ],
    exports: [{ name: 'refresh', type: '() => void' }]
  }
---

This component is a port of [drei's `<ContactShadows>` component](https://github.com/pmndrs/drei#contactshadows).

A contact shadow implementation, facing upwards (positive Y) by default. `scale` can be a positive number or a 2D array (`x: number, y: number]`).

```svelte
<ContactShadows
  opacity={1}
  scale={10}
  blur={1}
  far={10}
  resolution={256}
  color="#000000"
/>
```

Since this is a rather expensive effect you can limit the amount of frames it renders when your objects are static. For instance making it render only once:

```svelte
<ContactShadows frames={1} />
```

Use the binding `refresh` to manually refresh the shadows:

```svelte
<script>
  let refresh

  const onSomeEvent = () => {
    if (refresh) refresh()
  }
</script>

<ContactShadows
  bind:refresh
  frames={0}
/>
```

Currently it has the same limitations of drei's version: It yields unexpected results if moved on the x or the z axis.

<Example path="extras/contact-shadows" />

### Example

```svelte
<script lang="ts">
  import { ContactShadows } from 'threlte/extras'
</script>

<ContactShadows
  scale={10}
  blur={2}
  far={2.5}
  opacity={0.5}
/>
```


================================================
File: apps/docs/src/content/reference/extras/content.mdx
================================================
---
category: '@threlte/extras'
name: Content
order: 1
isDivider: true
---


================================================
File: apps/docs/src/content/reference/extras/csm.mdx
================================================
---
order: 4.14
category: '@threlte/extras'
name: <CSM>
sourcePath: 'packages/extras/src/lib/components/CSM/CSM.svelte'
type: 'component'
componentSignature:
  {
    props:
      [
        { name: 'enabled', type: 'boolean', required: false },
        { name: 'camera', type: 'THREE.Camera | undefined', required: false },
        { name: 'configure', type: '(csm: CSM) => void', required: false },
        { name: 'args', type: 'CSMParameters', required: false },
        { name: 'lightIntensity', type: 'number', required: false },
        { name: 'lightColor', type: 'THREE.ColorRepresentation', required: false },
        {
          name: 'lightDirection',
          type: 'THREE.Vector3Tuple',
          required: false,
          default: '[1, -1, 1]'
        }
      ]
  }
---

The `<CSM/>` component offers a streamlined convenience integration of the Cascaded Shadow Maps technique, sourced from the Three.js addon.

<Example path="extras/csm" />

Cascaded Shadow Maps (CSM) are a technique employed to render shadows with varying levels of
detail based on their distance from the camera. CSMs utilize multiple shadow maps to produce
higher resolution shadows closer to the camera and gradually decrease this resolution for
shadows farther away. This method is especially beneficial when rendering sun-cast
shadows over vast terrains, ensuring detailed and performance-optimized shadow renderings.

## Usage

```svelte title="Scene.svelte"
<script lang="ts">
  import { CSM } from '@threlte/extras'
  import { Vector3 } from 'three'
</script>

<CSM
  enabled
  args={{
    lightDirection: new Vector3(1, -1, 1).normalize()
  }}
>
  <!-- Your scene goes here -->
</CSM>
```

For CSM to work, shadow maps must be enabled. Threlte does this by default. **Do not disable shadowmaps** by [`<Canvas shadows={false}>`](/docs/reference/core/canvas#component-signature).

Then, wrap all of the objects that you wish to use CSM on (typically your entire scene) with the `<CSM>` component.

Internally, the `<CSM>` component modifies the shader code of all materials inside the component.
Currently, support is limited only to `THREE.MeshStandardMaterial` and `THREE.MeshPhongMaterial`.

<Tip type="warning">Setting `castShadow` property on any lights in a scene with `<CSM>` enabled leads to crashes.</Tip>

## CSM Parameters

The `<CSM>` component exposes an optional `args` prop which is used to instantiate the class `CSM`. These arguments are not reactive and are only updated when CSM is enabled.

### Parameters explained

| Name                 | Type                                                                                   | Description                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| -------------------- | -------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| camera               | `THREE.Camera`                                                                         | Camera which is currently used for rendering, defaults to the camera set via `makeDefault`.                                                                                                                                                                                                                                                                                                                                                   |
| parent               | `THREE.Object3D`                                                                       | `THREE.Object3D` where lights will be stored.                                                                                                                                                                                                                                                                                                                                                                                                 |
| cascades             | number                                                                                 | Number of shadow cascades.                                                                                                                                                                                                                                                                                                                                                                                                                    |
| maxFar               | number                                                                                 | Frustum far plane distance (i.e. shadows are not visible farther this distance from camera). May be smaller than `camera.far` value.                                                                                                                                                                                                                                                                                                          |
| mode                 | `"uniform" \| "logarithmic" \| "practical" \| "custom"`                                | Defines a split scheme (~ how the large frustum is splitted into smaller ones). Can be `'uniform'`(linear), `'logarithmic'`, `'practical'` or `'custom'`. For most cases `'practical'` may be the best choice. Equations used for each scheme can be found in [GPU Gems 3. Chapter 10.](https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch10.html) If mode is set to `'custom'`, you'll need to define your own `customSplitsCallback` |
| shadowMapSize        | number                                                                                 | Resolution of shadow maps (one per cascade).                                                                                                                                                                                                                                                                                                                                                                                                  |
| shadowBias           | number                                                                                 | Serves the same purpose as `THREE.LightShadow.bias`, but most likely you will need to use much smaller values.                                                                                                                                                                                                                                                                                                                                |
| lightDirection       | `THREE.Vector3`                                                                        | Normalized `THREE.Vector3`. Should be set by the prop `lightDirection`                                                                                                                                                                                                                                                                                                                                                                        |
| lightIntensity       | number                                                                                 | Same as `THREE.DirectionalLight.intensity`. Should be set by the prop `lightIntensity`                                                                                                                                                                                                                                                                                                                                                        |
| lightNear            | number                                                                                 | Shadow camera frustum near plane.                                                                                                                                                                                                                                                                                                                                                                                                             |
| lightFar             | number                                                                                 | Shadow camera frustum far plane.                                                                                                                                                                                                                                                                                                                                                                                                              |
| lightMargin          | number                                                                                 | Defines how far the shadow camera is moved along the z-axis in cascade frustum space. The larger the value is, the more space `LightShadow` will be able to cover. Should be set to a higher values for larger scenes.                                                                                                                                                                                                                        |
| customSplitsCallback | `(cascades: number, cameraNear: number, cameraFar: number, breaks: number[]) => void;` | A callback to compute custom cascade splits when `mode` is set to `'custom'`. The callback should accept three number parameters: `cascadeCount`, `nearDistance`, `farDistance` and return an array of split distances ranging from 0 to 1, where 0 is equal to `nearDistance` and 1 is equal to `farDistance`.                                                                                                                               |

For implementation details, refer to [the Three.js GitHub repository](https://github.com/mrdoob/three.js/blob/dev/examples/jsm/csm/CSM.js).

## Custom configuration

The `<CSM>` component offers a configuration callback, which is called when CSM is activated.
This callback facilitates advanced configurations, such as enabling the fade feature.

```svelte title="Scene.svelte"
<CSM
  configure={(csm) => {
    // advanced CSM configuration can be handle here.
    csm.fade = true
  }}
>
  <!-- Your scene goes here -->
</CSM>
```

<Tip type="tip">
  With fade enabled, shadows subtly diminish close to `maxFar` distance, presenting a more aesthetic
  transition compared to an abrupt cut-off. It may be more visually pleasing, but it's important to
  consider potential performance implications. While typically minimal, the computational complexity
  can escalate based on the number of cascades and lights present in the scene. Fade is disabled by
  default.
</Tip>

## Providing a fallback

You may want to use a regular `<T.DirectionalLight>` when CSM is not enabled,
for instance if you are developing a game and want to support low-end devices by
disabling shadows altogehter. You can do this by using the `enabled` prop and
the `disabled` slot:

```svelte title="Scene.svelte"
<CSM enabled={settings.shadows}>
  <!-- Your scene goes here -->

  <slot name="disabled">
    <!-- Will be mounted if settings.shadows is false -->
    <T.DirectionalLight castShadow={false} />
  </slot>
</CSM>
```


================================================
File: apps/docs/src/content/reference/extras/cube-camera.mdx
================================================
---
order: 5.10
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/components/CubeCamera/CubeCamera.svelte'
name: '<CubeCamera>'
type: 'component'
componentSignature:
  {
    extends: { type: 'Group', url: 'https://threejs.org/docs/#api/en/objects/Group' },
    exports:
      [
        { description: 'restarts the internal update task', name: 'restart', type: '() => void' },
        {
          description: 'causes the cube camera to update which renders to the render target',
          name: 'update',
          type: '() => void'
        }
      ],
    props:
      [
        {
          name: 'autoStart',
          required: false,
          type: 'boolean',
          default: 'true',
          description: 'whether to automatically start the render task.'
        },
        {
          default: 'Infinity',
          description: 'controls how many frames the render task will run for',
          name: 'frames',
          required: false,
          type: 'number'
        },
        {
          default: "'auto'",
          description: 'custom background to use when rendering to the render target',
          name: 'background',
          required: false,
          type: "Three.Scene['background'] | 'auto'"
        },
        {
          default: "'auto'",
          description: 'custom fog to use when rendering to the render target',
          name: 'fog',
          required: false,
          type: "Three.Scene['fog'] | 'auto'"
        },
        {
          default: '1000',
          description: 'passed along to the underlying cube camera',
          name: 'far',
          required: false,
          type: 'number'
        },
        {
          default: '0.1',
          description: 'passed along to the underlying cube camera',
          name: 'near',
          required: false,
          type: 'number'
        },
        {
          name: 'onupdatestart',
          description: 'a callback prop that is called anytime the render task is started',
          required: false,
          type: '() => void'
        },
        {
          name: 'onupdatestop',
          description: 'a callback prop that is called anytime the render task is stopped',
          required: false,
          type: '() => void'
        },
        {
          default: '256',
          description: 'size of the render target. more resolution means more detail',
          name: 'resolution',
          required: false,
          type: 'number'
        }
      ]
  }
---

A wrapper around three's
[CubeCamera](https://threejs.org/docs/index.html#api/en/cameras/CubeCamera) that
exposes a `renderTarget` prop. Before rendering to the render target, children
are set to invisible to exclude them from the render.

<Example path="extras/cube-camera" />

## Usage

The entire render target that is used by the underlying cube camera is available
through the `renderTarget` snippet prop. Usually you'll only want to use the
`renderTarget.texture`.

```svelte
<CubeCamera>
  {#snippet children({ renderTarget })}
    <T.Mesh>
      <T.SphereGeometry />
      <T.MeshStandardMaterial envMap={renderTarget.texture} />
    </T.Mesh>
  {/snippet}
</CubeCamera>
```

## Controlling Updates

By default, `frames` is set to `Infinity` which means the scene is rendered to
the render target every frame. This is sometimes unnecessary especially if you
have a static scene. To improve performance, you can use the `frames` prop to
control how many times the scene should be rendered.

For moving objects, let `frames` default to `Infinity`. If you have a static
scene, set `frames` equal to the number of `<CubeCamera>`s in the scene. This
will allow each one to render and then be picked up in each other's reflection.

### Manual Updates

If you want full control over updates, use the `update` function available as a
component export and through the `children` snippet.

<Tip type="warning">
  If you use the `update` function, be sure to set `frames` to `0` to prevent the internal update
  task from starting automatically.
</Tip>

#### As a Component Export

```svelte title="Scene.svelte"
<script>
  let cubeCameraComponent = $state()

  $effect(() => {
    // …
    cubeCameraComponent?.update()
  })
</script>

<CubeCamera
  frames={0}
  bind:this={cubeCameraComponent}
>
  <!-- … -->
</CubeCamera>
```

#### Through Children Snippet

```svelte title="Scene.svelte"
<CubeCamera frames={0}>
  {#snippet children({ update })}
    <T.Mesh oncreate{update}>
      <T.BoxGeometry />
    </T.Mesh>
  {/snippet}
</CubeCamera>
```

### Restarting the Task

If you need to restart the update task, you can do so through the `restart`
component export

```svelte
<script>
  let cubeCameraComponent = $state()

  $effect(() => {
    // dependencies here
    cubeCameraComponent?.restart()
  })
</script>

<CubeCamera
  frames={1}
  bind:this={cubeCameraComponent}
>
  <!-- ... -->
</CubeCamera>
```

`restart` is also available through the `children` snippet.

```svelte
<CubeCamerae frames={1}>
  {#snippet children({ restart })}
    <T.Mesh oncreate={restart}>
      <!-- ... -->
    </T.Mesh>
  {/snippet}
</CubeCamera>
```

## Scene Props

`<CubeCamera>` accepts a `background` prop that can be used to set the
background of the scene when rendering to the render target. By default the
current `scene.background` is used. `background` can be any valid
[Scene.background](https://threejs.org/docs/index.html#api/en/scenes/Scene.background).

```svelte
<script>
  import { Color } from 'three'

  const background = new Color(0xff_00_ff)
</script>

<CubeCamera {background}>
  <!-- ... -->
</CubeCamera>
```

The `fog` prop is used the same way and accepts any valid
[scene.fog](https://threejs.org/docs/index.html#api/en/scenes/Scene.fog). By
default `scene.fog` is used.

These "scene" props are only used when rendering the scene to the underlying
render target.

## Callback Props

The `onupdatestart` callback prop is called anytime the underlying update task
has been started.

```svelte
<CubeCamera
  onupdatestart={() => {
    console.log('update started')
  }}
>
  <!-- ... -->
</CubeCamera>
```

The `onupdatestop` callback fires anytime the update task has stopped. It is
called on restarts and when the internal counter goes over the `frames` limit.
This means that if `frames` is set to `Infinity`, as it is by default,
`onupdatestop` is never called.


================================================
File: apps/docs/src/content/reference/extras/cube-environment.mdx
================================================
---
order: 4.142
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/components/environment/CubeEnvironment/CubeEnvironment.svelte'
name: <CubeEnvironment>
type: 'component'
componentSignature:
  {
    props:
      [
        {
          description: 'a six-tuple of urls to load',
          name: 'urls',
          required: false,
          type: '[positiveX: string, negativeX: string, positiveY: string, negativeY: string, positiveZ: string, negativeZ: string]'
        },
        {
          default: 'false',
          description: 'whether to set `scene.background` to the loaded environment texture',
          name: 'isBackground',
          required: false,
          type: 'boolean'
        },
        {
          default: 'useThrelte().scene',
          description: 'the scene that will have its environment and/or background set',
          name: 'scene',
          required: false,
          type: 'THREE.Scene'
        },
        {
          description: 'a bindable of the loaded cube texture.',
          name: 'texture',
          required: false,
          type: 'THREE.CubeTexture'
        }
      ]
  }
---

`<CubeEnvironment>` is almost exactly like \<Enviroment> but it has a few key
differences, namely that its used to load and assign `THREE.CubeTexture`s to
`scene.environment`. Other differences will be listed below. For all other
information please refer to the
[\<Environment>](/docs/reference/extras/environment) documentation.

<Example path="extras/cube-environment/basic" />

## URLs

`<CubeEnvironment>`'s `urls` prop is a six-tuple of textures that comprise a
cube texture. The first file's extension decides which loader to use to load the
files. Refer to the table below to determine which loader is used for each
extension. The order of the `urls` is important. The order is `[positiveX,
negativeX, positiveY, negativeY, positiveZ, negativeZ]`.

| extension  | loader                                                                                                                  |
| ---------- | ----------------------------------------------------------------------------------------------------------------------- |
| .hdr       | [Three.HDRCubeTextureLoader](https://github.com/mrdoob/three.js/blob/dev/examples/jsm/loaders/HDRCubeTextureLoader.js/) |
| all others | [Three.CubeTextureLoader](https://threejs.org/docs/#api/en/loaders/CubeTextureLoader)                                   |

## Grounded Skybox

`<CubeEnvironment>` is other than `<Environment>` not able to create a
`GroundedSkybox` instance.


================================================
File: apps/docs/src/content/reference/extras/detailed.mdx
================================================
---
order: 7.6
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/components/Detailed/Detailed.svelte'
name: '<Detailed>'
type: 'component'
componentSignature:
  { extends: { type: 'LOD', url: 'https://threejs.org/docs/#api/en/objects/LOD' }, props: [] }
---

`<Detailed>` is an abstraction around ThreeJS's [LOD](https://threejs.org/docs/#api/en/objects/LOD). A common technique to improve performance is to swap out high-detail models or meshes for low-detail ones at large distances.

<Example path="extras/detailed" />

Notice how as the mesh's distance from the camera increases, a geometry with less vertices is shown.

<Tip type="warning">
The distance between the camera and the `<Detailed>` component itself is what determines which level-of-detail to use. You can set positions for children but they will not be used in the distance calculation.
</Tip>

Children of `<Detailed>` accept a distance prop. This prop determines the visibility of each child based on its distance from the camera. If not specified, distance defaults to 0.

```svelte
<Detailed>
  <T.Mesh>
    <T.BoxGeometry />
  </T.Mesh>
  <T.Mesh distance={10}>
    <T.BoxGeometry />
  </T.Mesh>
</Detailed>
```

Children of `<Detailed>` accept a hysteresis prop which can be used to prevent flickering at LOD boundaries. If not specified, hysteresis defaults to 0.

```svelte
<Detailed>
  <T.Mesh hysteresis={0.5}>
    <T.BoxGeometry />
  </T.Mesh>
</Detailed>
```

<Tip type="tip">
  It is fairly common to export a high-detail, medium-detail, and low-detail model from 3D asset
  creation tools.
</Tip>


================================================
File: apps/docs/src/content/reference/extras/discard-material.mdx
================================================
---
order: 5.10
category: '@threlte/extras'
name: '<MeshDiscardMaterial>'
sourcePath: 'packages/extras/src/lib/components/MeshDiscardMaterial/MeshDiscardMaterial.svelte'
type: 'component'
componentSignature:
  {
    extends:
      {
        type: 'ShaderMaterial',
        url: 'https://threejs.org/docs/index.html#api/en/materials/ShaderMaterial'
      }
  }
---

`<MeshDiscardMaterial>` is a material that renders nothing. It does so by discarding everything in the fragment shader. The difference between `<T.Mesh visible={false} />` and `<MeshDiscardMaterial>` is that shadows and children are still visible when using `<MeshDiscardMaterial>`.

<Example path="extras/mesh-discard-material" />

In the example above, the visible mesh does not use `<MeshDiscardMaterial>` nor sets `visible={false}`. The center mesh sets `visible={false}`. Notice how its shadow is missing. The final mesh uses `<MeshDiscardMaterial>` and its shadow is visible even though the mesh itself isn't.


================================================
File: apps/docs/src/content/reference/extras/edges.mdx
================================================
---
order: 5.2
category: '@threlte/extras'
name: <Edges>
sourcePath: 'packages/extras/src/lib/components/Edges/Edges.svelte'
type: 'component'
componentSignature:
  {
    extends:
      {
        type: 'LineSegments',
        url: 'https://threejs.org/docs/index.html#api/en/objects/LineSegments'
      },
    props:
      [
        { name: 'thresholdAngle', type: 'number', required: false },
        { name: 'color', type: 'THREE.ColorRepresentation', required: false }
      ]
  }
---

Abstracts `THREE.EdgesGeometry`. This component automatically pulls the geometry from its parent.

Edges are displayed when the angle between two faces exceeds the angle defined by the property `threshold`.

<Example path="extras/edges" />

<small>
  Model: Battle Damaged Sci-fi Helmet by [theblueturtle\_](https://sketchfab.com/theblueturtle_)
</small>

### Example

```svelte
<script lang="ts">
  import { BoxGeometry, MeshBasicMaterial } from 'three'
  import { Edges } from '@threlte/extras'
  import { T } from '@threlte/core'
</script>

<T.Mesh
  geometry={new BoxGeometry()}
  material={new MeshBasicMaterial()}
>
  <Edges color="black" />
</T.Mesh>
```


================================================
File: apps/docs/src/content/reference/extras/environment.mdx
================================================
---
order: 4.141
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/components/environment/Environment/Environment.svelte'
name: <Environment>
type: 'component'
componentSignature:
  {
    props:
      [
        {
          description: 'the url to a texture to load and use',
          name: 'url',
          required: false,
          type: 'string'
        },
        {
          description: 'a bindable of the loaded texture',
          name: 'texture',
          required: false,
          type: 'THREE.DataTexture | THREE.Texture'
        },
        {
          default: 'false',
          description: 'whether to set `scene.background` to the loaded environment texture',
          name: 'isBackground',
          required: false,
          type: 'boolean'
        },
        {
          default: 'useThrelte().scene',
          description: 'the scene that will have its environment and/or background set',
          name: 'scene',
          required: false,
          type: 'THREE.Scene'
        },
        {
          default: 'false',
          description: 'creates a ground projected skybox',
          name: 'ground',
          required: false,
          type: 'boolean | { height?: number, radius?: number, resolution?: number }'
        },
        {
          default: 'undefined',
          description: 'a reference to the created `GroundedSkybox` instance when using grounded projection',
          name: 'skybox',
          required: false,
          type: 'undefined | THREE.GroundedSkybox'
        }
      ]
  }
---

Asynchronously loads a single equirectangular-mapped texture and sets the provided scene's `environment` and or `background` to the texture. [Here](/textures/equirectangular/jpg/equirect_ruined_room.jpg) is an example of such a texture.

<Example path="extras/environment/basic" />

## Fetching, Loading, and Assigning Textures

`<Environment>`'s `url` prop is used to fetch and load textures. If it is provided, a corresponding loader will be used to fetch, load, and assign the texture to `scene.environment`.

`<Environment>` supports loading `exr`, `hdr`, and any other file type that can be loaded by ThreeJS's [TextureLoader](https://threejs.org/docs/#api/en/loaders/TextureLoader) such as `jpg` files. This means you can swap the `url` prop at any time and `<Environment>` will dispose of the previous texture and assign the new one to the scene's `environment` and/or `background` properties. Loaders within `<Environment>` are created on demand and cached for future use until `<Environment>` unmounts.

Internally `<Environment>` creates a loader based on the extension of the `url` prop. Refer to the table below to determine what kind of loader is used for a particular extension.

| extension  | loader                                                                                             |
| ---------- | -------------------------------------------------------------------------------------------------- |
| exr        | [Three.EXRLoader](https://github.com/mrdoob/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js/)  |
| hdr        | [Three.RGBELoader](https://github.com/mrdoob/three.js/blob/dev/examples/jsm/loaders/RGBELoader.js) |
| all others | [Three.TextureLoader](https://threejs.org/docs/#api/en/loaders/TextureLoader)                      |

<Tip type="info">
	Any time `<Environment>` loads a texture, it will dispose of the old one. The texture is also disposed when `<Environment>` unmounts.
</Tip>

### Loaders Are Simple

Loaders used inside `<Environment>` are not extendable. They only fetch and load the texture at `url`. If you need to use the methods that [ThreeJS loaders](https://threejs.org/docs/index.html?q=loader#api/en/loaders/Loader) have, you should create the loader outside of `<Environment>` and load it there then pass the texture through the `texture` prop.

```svelte
<script>
  import { TextureLoader } from 'three'

  const loader = new TextureLoader().setPath('https://path/to/texture/').setRequestHeader({
    // .. request headers that will be used when fetching the texture
  })

  const promise = loader.loadAsync('texture.jpg').then((texture) => {
    texture.mapping = EquirectangularReflectionMapping
    return texture
  })
</script>

{#await promise then texture}
  <Environment {texture} />
{/await}
```

### `texture` Prop for Preloaded Textures

`<Environment>` provides a bindable `texture` prop that you can use if you've already loaded the texture somewhere else in your application. The example below provides a preloaded texture to `<Environment>` instead of having it fetch and load one.

<Example path="extras/environment/bring-your-own-texture" />

Be aware that if `<Environment>` loads a texture, it will set the `texture` bindable prop **after** it has been loaded. This means that if you provide both `url` and `texture` properties, the texture at `url` will eventually be assigned to `texture`.

```typescript title="Scene.svelte"
<Environment {texture} url="/path/to/texture/file" />
```

Loading only occurs if `url` is passed to `<Environment>`.

## Restoring Props When Scene Updates

All of `<Environment>`'s props are reactive, even `scene`. If the `scene` prop is updated, `<Environment>` will restore the initial `environment` and `background` properties of the last scene.

The example below creates a custom render task that draws two scenes to the canvas - one on the left and one on the right. Pressing the button switches the environment to be applied to either the left or the right side. You can observe that when `side` updates, the original `background` and `environment` for the previous side are restored.

<Example path="extras/environment/swapping-scenes" />

## Suspended Loading

Any textures that are loaded by `<Environment>` are suspended so they may be used in a suspense context. This means if you're fetching the file over a slow network, you can show something in the "fallback" snippet of a [\<Suspense>]('/docs/reference/extras/suspense') component while the texture is being fetched and loaded.

```svelte title="Scene.svelte"
<script>
  import { Suspense, Text } from '@threlte/extras'
</script>

<Suspense>
  {#snippet fallback()}
    <Text text="loading environment" />
  {/snippet}
  <Environment url="https//url-of-your-file.hdr" />
</Suspense>
```

Note that suspension only occurs if `url` is provided. When a texture is provided through the `texture` prop, there is nothing that needs to loaded, so there's nothing that needs to be suspended.

## Grounded Skyboxes

`<Environment>` also supports ground projected environments through ThreeJS's [GroundedSkybox](https://threejs.org/examples/#webgl_materials_envmaps_groundprojected) addon. To use this feature, set the `ground` prop to `true` or to an object with optional `height`, `radius` and `resolution` props. `height` defaults to `1`, `radius` to `1`, and `resolution` to `128`

<Example path="extras/environment/ground-projection" />

The bindable `skybox` prop is a reference to the created `GroundedSkybox` instance. When using this feature, ThreeJS recommends setting the instance's `position.y` to `height`. This will position the "flat" part of the skybox at the origin.

```svelte title="Scene.svelte"
<script>
  let skybox = $state() // GroundedSkybox | undefined

  const height = 15

  $effect(() => {
    skybox?.position.setY(height)
  })
</script>

<Environment
  bind:skybox
  url="file.hdr"
  ground={{ height }}
/>
```

There are a couple of important things to consider when using the `ground` property:

1. `skybox` is only set to a `GroundedSkybox` instance if `ground` !== `false` and **after** the texture is available. It is set to `undefined` when `<Environment>` unmounts.

2. A new instance of `GroundedSkybox` is created whenever the `ground` prop updates to something other than `false`. This is a limitation of the addon. If you need to modify the skybox's properties, try to do it through the `skybox` bindable to avoid creating and destroying multiple instances.

3. `scene.environment` and/or `scene.background` are still set to the environment texture. This is done so that the environment map still affects materials used in the scene.


================================================
File: apps/docs/src/content/reference/extras/fake-glow-material.mdx
================================================
---
order: 5.3
category: '@threlte/extras'
name: '<FakeGlowMaterial>'
sourcePath: 'packages/extras/src/lib/components/FakeGlowMaterial/FakeGlowMaterial.svelte'
type: 'component'
componentSignature:
  {
    extends:
      {
        type: 'ShaderMaterial',
        url: 'https://threejs.org/docs/index.html#api/en/materials/ShaderMaterial'
      },
    props:
      [
        { name: 'glowColor', type: 'ColorRepresentation', default: '"green"', required: false },
        {
          name: 'falloff',
          type: 'number',
          default: '0.1',
          required: false,
          description: 'Controls the value of the Falloff effect. Ranges from 0.0 to 1.0.'
        },
        {
          name: 'glowInternalRadius',
          type: 'number',
          default: '6.0',
          required: false,
          description: 'Controls the internal glow radius. Ranges from -1.0 to 1.0. Set a darker color to get the fresnel effect only.'
        },
        { name: 'glowSharpness', type: 'number', default: '1.0', required: false }
      ]
  }
---

This component is a port of [ektogamat's `<FakeGlowMaterial>` r3f component](https://github.com/ektogamat/fake-glow-material-r3f)
which displays a glowing outline around a mesh using a custom shader, instead of post-processing.

<Example path="extras/fake-glow-material" />

## Examples

### Basic Example

```svelte title="FakeGlowMaterial.svelte"
<script lang="ts">
  import { T } from '@threlte/core'
  import { FakeGlowMaterial } from '@threlte/extras'
</script>

<T.Mesh>
  <FakeGlowMaterial glowColor="red" />
  <T.IcosahedronGeometry args={[4, 4]} />
</T.Mesh>
```

This effect is mesh based, meaning you need to provide a mesh for this to work properly.
The mesh must also be smooth enough that glsl can calculate the normals properly.

For sharp meshes like a cube, you can use a sphere to simulate the glow, instead of a copy of the cube.

```svelte title="FakeGlowMaterialCube.svelte"
<script lang="ts">
  import { T } from '@threlte/core'
  import { FakeGlowMaterial } from '@threlte/extras'
</script>

<T.Mesh>
  <FakeGlowMaterial glowColor="blue" />
  <T.BoxGeometry args={[2, 2, 2]} />
</T.Mesh>

<T.Mesh>
  <FakeGlowMaterial glowColor="blue" />
  <T.IcosahedronGeometry args={[3, 4]} />
</T.Mesh>
```


================================================
File: apps/docs/src/content/reference/extras/float.mdx
================================================
---
order: 4.16
category: '@threlte/extras'
name: '<Float>'
sourcePath: 'packages/extras/src/lib/components/Float/Float.svelte'
type: 'component'
componentSignature:
  {
    extends: { type: 'Group', url: 'https://threejs.org/docs/index.html#api/en/objects/Group' },
    props:
      [
        {
          name: 'speed',
          type: 'number | [x: number, y: number, z: number]',
          default: '1',
          required: false
        },
        {
          name: 'floatIntensity',
          type: 'number | [x: number, y: number, z: number]',
          default: '1',
          required: false
        },
        {
          name: 'floatingRange',
          type: '[number, number] | [x: [number, number], y: [number, number], z: [number, number]]',
          default: '[-0.1, 0.1]',
          required: false
        },
        {
          name: 'rotationIntensity',
          type: 'number | [x: number, y: number, z: number]',
          default: '0',
          required: false
        },
        {
          name: 'rotationSpeed',
          type: 'number | [x: number, y: number, z: number]',
          default: '0',
          required: false
        },
        { name: 'seed', type: 'number', default: 'Math.random() * 10000', required: false }
      ]
  }
---

This component is a port of [drei's `<Float>` component](https://github.com/pmndrs/drei#float) and makes its contents float or hover.

<Example path="extras/float" />

## Examples

### Basic Example

```svelte title="FloatingMesh.svelte"
<script lang="ts">
  import { T } from '@threlte/core'
  import { Float } from '@threlte/extras'
</script>

<Float
  floatIntensity={5}
  scale={$scale}
  rotationIntensity={2}
>
  <T.Mesh>
    <T.MeshStandardMaterial color={'orange'} />
    <T.BoxGeometry args={[5, 5, 5]} />
  </T.Mesh>
</Float>
```

## Floating

`floatingRange` determines the allowed range of position trasformation, and by extension the **direction** in which the children will move. If you provide a single number tuple, like `[-0.1,0.1]` the movement will happen on y axis. Alternatively you can provide an array of three tuples to change the movement axes. For example `[[0,0],[0,0],[-0.5,0.5]]` will move children between -0.5 and 0.5 relative to the starting position on the Z axis.

## Rotation

Rotation is set by `rotationSpeed` and `rotationIntensity`. Both of them need to be different from 0 to enable rotation. Providing a `number` in either of them applies it to all three axes. You get more granual control by passing an array `[x: number, y: number, z: number]`. `rotationSpeed` is responsible for the speed of the animation and `rotationIntensity` for the angle.

`seed` is responsible for the starting state of the animations and is random by default. Setting to a fixed value to get a predictable starting result.


================================================
File: apps/docs/src/content/reference/extras/getting-started.mdx
================================================
---
order: -2
category: '@threlte/extras'
name: Getting Started
---

The package `'@threlte/extras'` provides useful utilities, abstractions and plugins for your Threlte application.

## Installation

```bash title="Terminal"
npm install @threlte/extras
```

## Usage

<Tip type="experimental">
  The content of this package can be used directly but it's also meant to be a recipe for creating
  your own abstractions and plugins depending on your use case.
</Tip>

### Components

Most components are [**abstractions**](/docs/learn/advanced/custom-abstractions) of one or more `<T>` components and forward all props and event listeners to it.

Let's look at an example, the [`<OrbitControls>`](/docs/reference/extras/orbit-controls). They are a common component in Three.js applications and can be used to easily manipulate the camera. Let's implement it:

```svelte title="Scene.svelte" {10}+
<script>
  import { OrbitControls } from '@threlte/extras'
  import { T } from '@threlte/core'
</script>

<T.PerspectiveCamera
  makeDefault
  position={[5, 5, 5]}
>
  <OrbitControls />
</T.PerspectiveCamera>
```

In a regular Three.js application, you would have to create a `OrbitControls` instance by
passing the camera and a DOM element to it. In Threlte, you can just use the `<OrbitControls>`
component and it will automatically use the default camera and the `<canvas>` element the
renderer is rendering to. It will also automatically invalidate the frame on demand.

Under the hood though, there's still a regular `<T>` component that is doing the work of
applying props and registering event listeners. Internally, `<OrbitControls>` is
forwarding all props and event listeners, so you can use it just like a regular `<T>` component.

Let's add an event listener that's called when the camera is moved:

```svelte title="Scene.svelte" {11-13}+
<script>
  import { OrbitControls } from '@threlte/extras'
  import { T } from '@threlte/core'
</script>

<T.PerspectiveCamera
  makeDefault
  position={[5, 5, 5]}
>
  <OrbitControls
    onchange={(e) => {
      console.log(e)
    }}
  />
</T.PerspectiveCamera>
```

The event listener is forwarded to the `<T>` component and will be called when the camera is moved.
Keep in mind that these events are not hand-wired in the component, but are forwarded to the
underlying `<T>` component which in turn forwards them to the Three.js object. So you can use any
event listener that is supported by the `<T>` component.

### Plugins

The package also provides a few [plugins](/docs/learn/advanced/plugins) that can be used to extend the functionality of Threlte and `<T>` components.
The most notable one is probably the plugin [`interactivity`](/docs/reference/extras/interactivity) that provides a way to interact with the scene. We can
extend our example from above and implement `interactivity`:

```svelte title="Scene.svelte" {5}+
<script>
  import { OrbitControls, interactivity } from '@threlte/extras'
  import { T } from '@threlte/core'

  interactivity()
</script>

<T.PerspectiveCamera
  makeDefault
  position={[5, 5, 5]}
>
  <OrbitControls />
</T.PerspectiveCamera>

<T.Mesh
  onclick={() => {
    console.log('clicked')
  }}
>
  <T.BoxGeometry />
  <T.MeshBasicMaterial color="red" />
</T.Mesh>
```

Now, when we click on the box, we will see a message in the console. The `interactivity` plugin
registers a global event listener on the `<canvas>` element and forwards all events to the
respective `<T>` components. Check out the [guide on events](/docs/learn/basics/events) for more
information on how to use events in Threlte.

<Tip type="tip">
  Plugins are injected via context and therefore need to be implement at the root of your
  application, this is typically your `Scene.svelte` component. Check out our [recommended app
  structure](/docs/learn/basics/context).
</Tip>

### Hooks

Hooks are regular functions with the limitation that they can only be invoked from the top level of
a component. `'@threlte/extras'` provides useful hooks for loading assets, creating animations
and more. Let's look at an example where we use the hook [`useGltf`](/docs/reference/extras/use-gltf)
to load an asset:

```svelte title="Scene.svelte"
<script>
  import { useGltf } from '@threlte/extras'
  import { T } from '@threlte/core'

  // Place the model in your public folder
  const model = useGltf('/model.glb')
</script>
```

The hook will return the special Threlte store `AsyncWritable` that makes it easy to consume the
result of the loader. The store will be updated once the asset is loaded and can be used in the
template either with the `{#await}` or the `{#if}` block. Let's use the `{#await}` block to
display a loading message:

```svelte title="Scene.svelte"
<script>
  import { useGltf } from '@threlte/extras'
  import { T } from '@threlte/core'
  import LoadingPlaceholder from './LoadingPlaceholder.svelte'

  const model = useGltf('/model.glb')
</script>

{#await model}
  <LoadingPlaceholder />
{:then value}
  <T is={value} />
{/await}
```

Keep in mind that the hook `useGltf` caches the result as it's using
[`useLoader`](/docs/reference/core/use-loader) internally.


================================================
File: apps/docs/src/content/reference/extras/gizmo.mdx
================================================
---
order: 2.1
category: '@threlte/extras'
name: <Gizmo>
sourcePath: 'packages/extras/src/lib/components/Gizmo/Gizmo.svelte'
type: 'component'
componentSignature:
  {
    props:
      [
        {
          name: 'renderTask',
          required: false,
          type: 'TaskOptions',
          description: 'Options for the task to render the gizmo scene in the viewport. By default, this happens after the `autoRenderTask`.'
        },
        { name: 'controls', type: 'OrbitControls | CameraControls', required: false }
      ],
    events:
      [
        {
          name: 'start',
          payload: "Event<'start', ViewportGizmo>",
          description: 'Triggered when a view change interaction begins.'
        },
        {
          name: 'change',
          payload: "Event<'change', ViewportGizmo>",
          description: 'Triggered during view changes.'
        },
        {
          name: 'end',
          payload: "Event<'end', ViewportGizmo>",
          description: 'Triggered when a view change interaction ends.'
        }
      ]
  }
---

A gizmo for snap-to camera controls.

Uses the [Three Viewport Gizmo library](https://fennec-hub.github.io/three-viewport-gizmo/).

<Example path="extras/gizmo" />

Three's `OrbitControls` or yomotsu's [`CameraControls`](https://github.com/yomotsu/camera-controls) can be provided as a `controls` prop.

Alternatively, the `<Gizmo>` can be placed as a child of a controls component.

```svelte
<OrbitControls>
  <!-- Will attach itself to this OrbitControls -->
  <Gizmo />
</OrbitControls>
```

In addition to the props listed below, `<Gizmo>` can accept [any of the options](https://fennec-hub.github.io/three-viewport-gizmo/api.html#gizmooptions) from the underlying Three Viewport Gizmo instance as a prop.

<Tip type="warning">These props cause the gizmo to rebuild itself, so update them sparingly.</Tip>


================================================
File: apps/docs/src/content/reference/extras/gltf.mdx
================================================
---
order: 1.1
category: '@threlte/extras'
name: <GLTF>
sourcePath: 'packages/extras/src/lib/components/GLTF/GLTF.svelte'
type: 'component'
componentSignature:
  {
    extends: { type: 'Group', url: 'https://threejs.org/docs/index.html#api/en/objects/Group' },
    props:
      [
        { name: url, type: 'string', required: true },
        { name: 'dracoLoader', type: 'DRACOLoader', required: false },
        { name: 'meshoptDecoder', type: 'MeshoptDecoder', required: false },
        { name: 'ktx2Loader', type: 'KTX2Loader', required: false }
      ],
    events:
      [
        {
          name: 'load',
          payload: 'GLTF & { materials: Record<string, THREE.Material>, nodes: Record<string, THREE.Object3D> }'
        },
        { name: 'unload', payload: 'void' },
        { name: 'error', payload: 'string' }
      ],
    bindings:
      [
        {
          name: 'gltf',
          type: 'GLTF & { materials: Record<string, THREE.Material>, nodes: Record<string, THREE.Object3D> }'
        },
        { name: 'scene', type: 'THREE.Group' },
        { name: 'animations', type: 'THREE.AnimationClip[]' },
        { name: 'asset', type: "GLTF['asset']" },
        { name: 'cameras', type: 'THREE.Camera[]' },
        { name: 'scenes', type: 'THREE.Group[]' },
        { name: 'userData', type: 'any' },
        { name: 'parser', type: 'GLTFParser' },
        { name: 'materials', type: 'Record<string, THREE.Material>' },
        { name: 'nodes', type: 'Record<string, THREE.Object3D>' }
      ]
  }
---

`<GLTF />` loads a single model from a url. The `url` property is reactive and will load new 3D content if changed. The new content will be swapped as soon as loading is finished.

<Tip type="tip">
  Asset loading can sometimes produce surprising results. We've detailed common issues you may run
  into on our [loading assets](/docs/learn/basics/loading-assets) page.
</Tip>

<Example path="extras/gltf" />

<small>
  Model: Battle Damaged Sci-fi Helmet by [theblueturtle\_](https://sketchfab.com/theblueturtle_)
</small>

### Interaction

The `<GLTF>` component supports interaction events with the use of `interactivity` plugin.

```svelte
<script>
  import { interactivity } from '@threlte/extras'
  interactivity()
</script>

<GLTF
  position={{ y: 1 }}
  scale={3}
  url="/models/helmet/DamagedHelmet.gltf"
  onclick={() => {
    console.log('User clicked!')
  }}
/>
```

### Compression

The `<GLTF>` component supports compressed glTF files.

#### DRACO

To use DRACO compression, import the `useDraco` hook or provide an instance of a `DRACOLoader`.

```svelte
<script>
  import { GLTF, useDraco } from '@threlte/extras'

  const dracoLoader = useDraco() // Creates a cached instance of DracoLoader
</script>

<GLTF
  url="/models/helmet/DamagedHelmet.gltf"
  {dracoLoader}
/>
```

The `useDraco` hook will load a default DRACO decoder from Google servers, specifically `https://www.gstatic.com/draco/v1/decoders/`.

### KTX 2

To use KTX2 compressed textures, import the `useKtx2` hook or provide an instance of a `KTX2Loader`.

```svelte
<script>
  import { useKtx2 } from '@threlte/extras'

  const ktx2Loader = useKtx2('path/to/transcoder') // Creates a cached instance of KTX2Loader
</script>

<GLTF
  url="/models/helmet/DamagedHelmet.gltf"
  {ktx2Loader}
/>
```

#### Meshopt

To use meshopt compression, import the `useMeshopt` hook or provide an instance of a `MeshoptDecoder`.

The `useMeshopt` hook will load a default meshopt decoder from Three, specifically `https://github.com/mrdoob/three.js/blob/dev/examples/jsm/libs/meshopt_decoder.module.js`.

```svelte
<script>
  import { GLTF, useMeshopt } from '@threlte/extras'

  const meshoptDecoder = useMeshopt() // Creates a cached instance of MeshoptDecoder
</script>

<GLTF
  url="/models/helmet/DamagedHelmet.gltf"
  {meshoptDecoder}
/>
```


================================================
File: apps/docs/src/content/reference/extras/grid.mdx
================================================
---
order: 4.17
category: '@threlte/extras'
name: <Grid>
sourcePath: 'packages/extras/src/lib/components/Grid/Grid.svelte'
type: 'component'
componentSignature:
  {
    extends: { type: 'Mesh', url: 'https://threejs.org/docs/index.html#api/en/objects/Mesh' },
    props:
      [
        { name: 'plane', type: "'xz' | 'xy' | 'zy'", default: "'xz'", required: false },
        { name: 'cellColor', type: 'ColorRepresentation', default: "'#000000'", required: false },
        { name: 'cellSize', type: 'number', default: '1', required: false },
        { name: 'cellThickness', type: 'number', default: '1', required: false },
        {
          name: 'sectionColor',
          type: 'ColorRepresentation',
          default: "'#0000ee'",
          required: false
        },
        { name: 'sectionSize', type: 'number', default: '10', required: false },
        { name: 'sectionThickness', type: 'number', default: '2', required: false },
        {
          name: 'gridSize',
          type: 'number | [number, number]',
          default: '[20,20]',
          required: false
        },
        { name: 'followCamera', type: 'boolean', default: 'false', required: false },
        { name: 'infiniteGrid', type: 'boolean', default: 'false', required: false },
        { name: 'fadeDistance', type: 'number', default: '100', required: false },
        { name: 'fadeStrength', type: 'number', default: '1', required: false },
        {
          name: type,
          type: "'grid' | 'lines' | 'circular' | 'polar'",
          default: "'grid'",
          required: false
        },
        {
          name: 'axis',
          type: "'x' | 'y' | 'z'",
          default: "'x'",
          required: false,
          description: "'line' only. Designates the world axis along which the line will be oriented."
        },
        {
          name: 'maxRadius',
          type: 'number',
          default: '0',
          required: false,
          description: "'circular' and 'polar' only. 0 removes the constraint."
        },
        {
          name: 'cellDividers',
          type: 'number',
          default: '6',
          required: false,
          description: "'polar' only. How many lines will divide the polar grid. Specifies the number of lines that will subdivide the polar grid. For instance, 2 dividers will quarter the grid into 4 sections of 90° each, while 6 dividers will divide the grid into 12 segments, each measuring 30°."
        },
        {
          name: 'sectionDividers',
          type: 'number',
          default: '2',
          required: false,
          description: "'polar' only. Specifies the number of lines that will subdivide the polar grid. For instance, 2 dividers will quarter the grid into 4 sections of 90° each, while 6 dividers will divide the grid into 12 segments, each measuring 30°."
        }
      ]
  }
---

A robust grid implementation with multiple tweakable parameters.

<Example path="extras/grid" />

## Usage

This component provides sensible defaults. You can initialize the default grid with just `<Grid>`. `ref` passes a reference from the `<T.Mesh/>` the grid is constructed on.

### Grid types

The grid type can be selected by setting the `type` parameter. The available grid types are:

- `grid`: represents a standard box grid. It does not require any additional properties. (default)
- `lines`: grid consisting of lines that align along a single world axis. You specify this axis by providing either `x`, `y` or `z` to the `axis` property.
- `circular`: grid formed of concentric circles. It includes a `maxRadius` property that sets the maximum growth extent for the grid. A value of `0` removes this limit, allowing the grid to occupy the entire geometry, even if it results in incomplete circles.
- `polar`: similar to the circular type, but it also features lines that subdivide the concentric circles. It too has a `maxRadius` property. Additionally, it has two properties for specifying dividers: `cellDivider` and `sectionDivider`. These determine how many lines will segment the circle into various sectors. For example, 2 lines result in 4 segments at 90° each, while 6 lines create 12 sectors at 30° apiece.

| Grid                                               | Lines                                               | Circular                                               | Polar                                               |
| -------------------------------------------------- | --------------------------------------------------- | ------------------------------------------------------ | --------------------------------------------------- |
| ![Grid preview](/images/docs/extras/grid/grid.jpg) | ![Grid preview](/images/docs/extras/grid/lines.jpg) | ![Grid preview](/images/docs/extras/grid/circular.jpg) | ![Grid preview](/images/docs/extras/grid/polar.jpg) |

### Cells and Sections

Grid is split into cells and sections. **Cell** is meant to represent the smallest units on your grid, whereas
**section** is a group of cells. You can adjust the size of the grid by changing the `cellSize` and `sectionSize`
parameters. Size is in Three world units, so for example a mesh with `BoxGeometry(1,1,1)` will fit perfectly into
a size 1 cell. By default a cell is 1 unit and a section 10, which means that a grid of 10x10 cells will be
outlined with a section line.

### Lines

You can adjust the color and thickness of cell and section lines with `cellColor`, `cellThickness`, `sectionColor`, `sectionThickness`.

### Grid size and fading

The `<Grid>` component is a `THREE.Mesh` with a `PlaneGeometry` attached to it. The `gridSize` parameter defines the size of the `PlaneGeometry`.
You can extend the grid into infinity if you set the `infiniteGrid` parameter to `true`.
Changing `fadeDistance` sets how far from the camera position the grid begins to fade by having its alpha reduced. `fadeStrength` determines how fast it happens (exponent). `fadeStrength = 0` means that there is no fading (not recommended for large grids).

### Custom geometry

You have the option to insert your own custom geometry into the `<Grid/>` slot. The preceding example demonstrates this by showcasing a preview of a terrain-like geometry generated using Perlin noise.

```svelte
<Grid>
  <T.BoxGeometry />
</Grid>
```

### Follow camera

Setting `followCamera` to true applies a transform that moves the grid to the camera's position on the chosen `plane`.


================================================
File: apps/docs/src/content/reference/extras/html.mdx
================================================
---
order: 1.2
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/components/HTML/HTML.svelte'
name: <HTML>
type: 'component'
componentSignature:
  {
    extends: { type: 'Group', url: 'https://threejs.org/docs/index.html#api/en/objects/Group' },
    exports:
      [
        {
          name: 'startRendering',
          type: '() => void',
          description: 'Manually start the render task'
        },
        { name: 'stopRendering', type: '() => void', description: 'Manually stop the render task' },
        {
          description: 'renders a single frame of the provided html',
          name: 'render',
          type: '() => void'
        }
      ],
    props:
      [
        { name: 'transform', type: 'boolean', default: 'false', required: false },
        { name: 'calculatePosition', type: '(
            obj: Object3D,
            camera: Camera,
            size: { width: number; height: number }
            ) => [number, number]', required: false },
        { name: 'eps', type: 'number', default: '0.001', required: false },
        {
          name: 'occlude',
          type: "boolean | THREE.Object3D[] | 'blending'",
          default: 'false',
          required: false
        },
        {
          name: 'zIndexRange',
          type: '[number, number]',
          default: '[16777271, 0]',
          required: false
        },
        { name: 'sprite', type: 'boolean', default: 'false', required: false },
        {
          name: 'pointerEvents',
          type: "'auto' | 'none' | 'visiblePainted' | 'visibleFill' | 'visibleStroke' | 'visible' | 'painted' | 'fill' | 'stroke' | 'all' | 'inherit'",
          default: "'auto'",
          required: false
        },
        { name: 'center', type: 'boolean', default: 'false', required: false },
        { name: 'fullscreen', type: 'boolean', default: 'false', required: false },
        { name: 'distanceFactor', type: 'number', default: 'undefined', required: false },
        { name: 'as', type: 'keyof HTMLElementTagNameMap', default: "'div'", required: false },
        { name: 'portal', type: 'HTMLElement', default: 'undefined', required: false },
        { name: 'castShadow', type: 'boolean', default: 'undefined', required: false },
        { name: 'receiveShadow', type: 'boolean', default: 'undefined', required: false },
        { name: 'material', type: 'THREE.Material', default: 'undefined', required: false },
        { name: 'geometry', type: 'THREE.BufferGeoemtry', default: 'undefined', required: false },
        {
          name: 'autoRender',
          type: 'boolean',
          default: 'true',
          required: false,
          description: 'whether the render task should be ran every frame'
        }
      ]
  }
---

This component is a port of [drei's `<Html>`
component](https://github.com/pmndrs/drei#html). It allows you to tie HTML
content to any object of your scene. It will be projected to the objects
whereabouts automatically.

<Tip type="warning">
	The container of your `<Canvas>` component needs to be set to `position:
	relative | absolute | sticky | fixed`. This is because the DOM element will
	be mounted as a sibling to the `<canvas>` element.
</Tip>

<Example path="extras/html/basic" />

## Stopping and Starting the Task

`<HTML>` has an `autoRender` prop that you can use to turn off and on its
render task. If at some point in your application, you no longer need to update
the hmtl, you can set `autoRender` to `false`. If you need to resume the task,
set `autoRender` back to `true`.

`<HTML>` also exports it's internal render task and the `startRendering`,
`stopRendering`, and `render` functions so you can either manually render the
html or start and stop the internal task at your will.

```svelte title="Manually-Rendering"
<script>
  let html = $state()

  $effect(() => {
    // if (shouldRender) {
    html?.render()
    // }
  })
</script>

<HTML
  autoRender={false}
  bind:this={html}
>
  <h1>Hello World</h1>
</HTML>
```

```svelte title="Start-And-Stop-Rendering"
<script>
  let html = $state()

  // turn this on and off in accordance with your application
  let renderWhileTrue = $state(false)

  $effect(() => {
    if (html !== undefined) {
      if (renderWhileTrue) {
        html.startRendering()
        // always stop rendering if it was started
        return () => {
          html.stopRendering()
        }
      }
    }
  })
</script>

<HTML
  autoRender={false}
  bind:this={html}
>
  <h1>Hello World</h1>
</HTML>
```

In both cases you should set `autoRender` to `false` so that the render task
doesn't automatically begin.

Lastly, you can access these functions from the `<HTML>`'s children snippet.

```svelte
<HTML autoRender={false}>
  {#snippet children({ render, startRendering, stopRendering })}
    <button onclick={startRendering}>start rendering</button>
    <button onclick={stopRendering}>stop rendering</button>
    <button onclick={render}>render a single frame</button>
  {/snippet}
</HTML>
```

## Examples

### Basic Example

```svelte
<script lang="ts">
  import { HTML } from '@threlte/extras'
</script>

<HTML>
  <h1>Hello, World!</h1>
</HTML>
```

### Transform

`transform` applies matrix3d transformations.

```svelte
<script lang="ts">
  import { HTML } from '@threlte/extras'
</script>

<HTML transform>
  <h1>Hello World</h1>
</HTML>
```

### Occlude

`<Html>` can be occluded behind geometry using the occlude `occlude` property.

```svelte
<script lang="ts">
  import { HTML } from '@threlte/extras'
</script>

<HTML
  transform
  occlude
>
  <h1>Hello World</h1>
</HTML>
```

Setting `occlude` to `"blending"` will allow objects to partially occlude the
`<HTML>` component.

<Tip type="warning">
	This occlusion mode requires the `<canvas>` element to have `pointer-events`
	set to `none`. Therefore, any events like those in `OrbitControls` must be
	set on the canvas parent. Extras components like `<OrbitControls>` do this
	automatically.
</Tip>

<Example path="extras/html/phone" />

### Visibility Change Event

Use the property `occlude` and bind to the event `visibilitychange` to
implement a custom hide/show behaviour.

```svelte
<script lang="ts">
  import { HTML } from '@threlte/extras'

  const onVisibilityChange = (isVisible: boolean) => {
    console.log(isVisible)
  }
</script>

<HTML
  transform
  occlude
  onvisibilitychange={onVisibilityChange}
>
  <h1>Hello World</h1>
</HTML>
```

<Tip type="info">
	When binding to the event `visibilitychange` the contents of `<HTML>` is
	_not_ automatically hidden when it's occluded.
</Tip>

### Sprite Rendering

Use the property `sprite` in `transform` mode to render the contents of
`<HTML>` as a sprite.

```svelte
<script lang="ts">
  import { HTML } from '@threlte/extras'
</script>

<HTML
  transform
  sprite
>
  <h1>Hello World</h1>
</HTML>
```

### Center

Add a -50%/-50% css transform with `center` when _not_ in `transform` mode.

```svelte
<script lang="ts">
  import { HTML } from '@threlte/extras'
</script>

<HTML center>
  <h1>Hello World</h1>
</HTML>
```

### Portal

Use the property `portal` to mount the contents of the `<HTML>` component on
another `HTMLElement`. By default the contents are mounted as a sibling to the
rendering `<canvas>`.

```svelte
<script lang="ts">
  import { HTML } from '@threlte/extras'
</script>

<HTML portal={document.body}>
  <h1>Hello World</h1>
</HTML>
```

## uikit

An alternative to using HTML for UI is
[uikit](https://pmndrs.github.io/uikit/docs/getting-started/vanilla). The
vanilla code has be wrapped into
[threlte-uikit](https://github.com/michealparks/threlte-uikit) for use in
threlte projects. There are situations where this package is necessary, for
instance the `<HTML/>` component cannot be used within XR sessions.


================================================
File: apps/docs/src/content/reference/extras/hud.mdx
================================================
---
order: 4.15
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/components/HUD/HUD.svelte'
name: <HUD>
type: 'component'
componentSignature:
  {
    props:
      [
        {
          name: 'autoRender',
          type: 'boolean',
          required: false,
          description: 'Whether the HUD should automatically render its contents'
        },
        {
          name: 'toneMapping',
          type: 'THREE.ToneMapping',
          required: false,
          description: 'Defaults to the parent context toneMapping'
        },
        {
          name: 'stage',
          type: 'Stage',
          required: false,
          description: 'Defaults to the render stage'
        }
      ]
  }
---

Renders a heads-up-display (HUD). Each HUD creates a new scene rendered on top of the main scene with a separate [Threlte context](/docs/reference/core/use-threlte) and camera.

<Tip type="warning">
  The HUD component creates a partially new Threlte context, specifically a new scene and camera.
  Everything else in `useThrelte` is preserved and reused.
</Tip>

<Example path="extras/hud/simple" />

Because creating a `<HUD>` is somewhat similar to creating a `<Canvas>`, it is recommended to use the same best practices and
place all objects you want in the HUD within a new `Scene` component:

```svelte title=MyHUD.svelte {2,6}+
<script>
  import Scene from './Scene.svelte'
</script>

<HUD>
  <Scene />
</HUD>
```

```svelte title=Scene.svelte
<script>
  import { T } from '@threlte/core'
</script>

<T.PerspectiveCamera
  makeDefault
  position={[0, 0, 0]}
  oncreate={(ref) => ref.lookAt(0, 0, 0)}
/>

<T.AmbientLight />

<T.Mesh>
  <T.BoxGeometry />
  <T.MeshStandardMaterial />
</T.Mesh>
```


================================================
File: apps/docs/src/content/reference/extras/image-material.mdx
================================================
---
order: 5.4
category: '@threlte/extras'
name: <ImageMaterial>
sourcePath: 'packages/extras/src/lib/components/ImageMaterial/ImageMaterial.svelte'
type: 'component'
'componentSignature':
  {
    extends:
      {
        type: 'ShaderMaterial',
        url: 'https://threejs.org/docs/index.html?q=shaderm#api/en/materials/ShaderMaterial'
      },
    'props':
      [
        { name: 'color', type: 'THREE.ColorRepresentation', default: 'white', required: false },
        { name: 'radius', type: 'number', default: '0', required: false },
        {
          name: 'brightness',
          type: 'number',
          default: '0',
          required: false,
          description: 'Modifies brightness. Recommended range from -1 to 1.'
        },
        {
          name: 'contrast',
          type: 'number',
          default: '0',
          required: false,
          description: 'Modifies contrast. Recommended range from -1 to 1.'
        },
        {
          name: 'hue',
          type: 'number',
          default: '0',
          required: false,
          description: 'Modifies hue. Range from 0 to 1.'
        },
        {
          name: 'saturation',
          type: 'number',
          default: '0',
          required: false,
          description: 'Modifies saturation. Recommended range from -1 to 1.'
        },
        {
          name: 'lightness',
          type: 'number',
          default: '0',
          required: false,
          description: 'Modifies lightness. Recommended range from -1 to 1.'
        },
        {
          name: 'monochromeColor',
          type: 'THREE.ColorRepresentation',
          default: '#535970',
          required: false,
          description: 'Sets a monochrome tint the image is converted to.'
        },
        {
          name: 'monochromeStrength',
          type: 'number',
          default: '0',
          required: false,
          description: 'Sets the strength of monochrome effect. Range from 0 to 1.'
        },
        {
          name: 'negative',
          type: 'boolean',
          default: 'false',
          required: false,
          description: 'Enables/disables negative effect.'
        },
        {
          name: 'colorProcessingTexture',
          type: 'THREE.Texture | THREE.VideoTexture',
          required: false,
          description: 'Sets a texture used to adjust the strength and the pattern of color processing effects. Each channel of the texture is responsible for a different color processing function. R - hue, G - saturation, B - lightness, A - alpha.'
        },
        { name: 'alphaThreshold', type: 'number', default: '0', required: false, description: '' },
        { name: 'alphaSmoothing', type: 'number', default: '0', required: false, description: '' },
        { name: 'zoom', type: 'number', default: '1', required: false },
        { name: 'toneMapped', type: 'boolean', default: 'true', required: false },
        { name: 'transparent', type: 'boolean', default: 'false', required: false },
        { name: 'opacity', type: 'number', default: '1', required: false },
        { name: 'side', type: 'THREE.Side', default: 'THREE.FrontSide', required: false }
      ]
  }
---

Adapted from drei's [`<Image>`](https://github.com/pmndrs/drei?tab=readme-ov-file#image) component, with additional color processing extras.

A shader-based image material component with auto-cover (similar to css/background: cover).

<Example path="extras/image-material" />

<small>
  Images from
  [Wikipedia](https://en.wikipedia.org/wiki/Wikipedia:Featured_pictures/Artwork/Paintings). Carousel
  originally by [Cyd Stumpel](https://codesandbox.io/s/9s2wd9?file=/src/App.js:1160-1168).
</small>

## Example

```svelte
<script lang="ts">
  import { DoubleSide } from 'three'
  import { ImageMaterial } from '@threlte/extras'
</script>

<T.Mesh>
  <T.PlaneGeometry />
  <ImageMaterial
    transparent
    side={DoubleSide}
    url="KlimtDieJungfrau.jpg"
    radius={0.1}
    zoom={1.1}
  />
<T.Mesh>
```

`<ImageMaterial>` can also be used with instanced or batched meshes.

## Color processing effects

The `<ImageMaterial />` component offers a range of properties for dynamic color processing.

The properties `brightness`, `contrast`, `hue`, `saturation`, and `lightness` adjust the image's initial values additively.
To decrease brightness, for instance, you would use a negative value, while a positive value would increase it. The `hue` shift is the only exception,
its values range from 0 to 1, representing a complete cycle around the color wheel. Notably, values 0 and 1 are equivalent, indicating the same hue position.

For the monochrome effect, specify your preferred tint using the `monochromeColor` property,
and control the effect's intensity with `monochromeStrength`.
Setting this strength to 0 disables the effect entirely, while a value of 1 applies it fully,
rendering the image in varying shades of a single color.

### Advanced color processing with a texture

The `colorProcessingTexture` property enables advanced color processing by allowing you to specify a texture
that changes the strength and pattern of color effects. It can be used to create dynamic, animated effects as well as static ones that target only
specified image areas.

Each texture channel controls a different color processing effect:

- <span class="text-red-500">Red</span> for hue
- <span class="text-green-400">Green</span> for saturation,
- <span class="text-cyan-300">Blue</span> for lightness
- <span class="text-white">Alpha</span> for transparency.

Red, green and blue channels are applied multiplicatively to the values of hue, saturation and lightness.

The alpha channel acts differently, providing a flexible alpha override mechanism, that uses a range of values for
dynamic image reveal effect. With changing the `alphaThreshold` property, areas with alpha values approaching 1 are revealed first,
followed by regions with values tending towards 0.

To further control this effect, the `alphaSmoothing` property allows for a gradual fade-in effect within a specified range.
For instance, with an alphaThreshold of 0.5 and an alphaSmoothing set to 0.15, alpha values spanning from 0.5 to 0.65
will smoothly transition into visibility.

Enable "color processing with a texture" in the example on top of this page to see the effect applying RGBA color processing texture can have.

<div class="flex w-full flex-col items-center">
  <img
    src="/textures/alpha.jpg"
    class="max-w-[300px]"
  />
  <span>
    *Alpha image used in the example. The lighter values towards the center are revealed first.*
  </span>
</div>

### Order of processing effects

1. Alpha override
2. Brightness
3. Contrast
4. Hue, Saturation, Lightness
5. Monochrome
6. Negative


================================================
File: apps/docs/src/content/reference/extras/instance.mdx
================================================
---
order: 7.1
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/components/Instancing/Instance.svelte'
name: '<Instance>'
type: 'component'
componentSignature:
  {
    extends:
      { type: 'PositionalMesh', url: 'https://threejs.org/docs/index.html#api/en/objects/Mesh' },
    props:
      [
        { name: 'id', type: 'string', default: 'default', required: false },
        { name: 'color', type: 'THREE.ColorRepresentation', required: false }
      ]
  }
---

Every `<Instance>` component nested in an [`<InstancedMesh>`](/docs/reference/extras/instanced-mesh) component resembles one instance. An `<Instance>` can therefore only be used as a child component to a `<InstancedMesh>` component. The `<Instance>` component can be transformed and colorized individually:

```svelte
<InstancedMesh>
  <T.BoxGeometry />
  <T.MeshStandardMaterial />

  <Instance
    position.x={5}
    scale={1}
  />
  <Instance
    position.z={2}
    scale={2}
    color="red"
  />
</InstancedMesh>
```


================================================
File: apps/docs/src/content/reference/extras/instanced-mesh.mdx
================================================
---
order: 7.2
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/components/Instancing/InstancedMesh.svelte'
name: '<InstancedMesh>'
type: 'component'
componentSignature:
  {
    extends:
      {
        type: 'InstancedMesh',
        url: 'https://threejs.org/docs/index.html#api/en/objects/InstancedMesh'
      },
    props:
      [
        { name: 'id', type: 'string', default: 'default', required: false },
        {
          name: 'limit',
          type: 'number',
          default: '1000',
          required: false,
          description: 'Limits the amount of possible <Instance> components.'
        },
        {
          name: 'range',
          type: 'number',
          default: '1000',
          required: false,
          description: 'Limits the amount of drawn <Instance> components.'
        },
        {
          name: 'update',
          type: 'boolean',
          default: 'true',
          required: false,
          description: 'Whether the THREE.InstancedMesh should be updated.'
        }
      ]
  }
---

The component `<InstancedMesh>` is wrapping the Three.js object InstancedMesh and provides instanced rendering support. Use `<InstancedMesh>` if you have to render a large number of objects with the same geometry and material but with different world transformations and colors. The usage of `<InstancedMesh>` will help you to reduce the number of draw calls and thus improve the overall rendering performance in your application.

<Example path="extras/instanced-mesh/simple" />

## Usage

An `<InstancedMesh>` is used in conjunction with the [`<Instance>`](/docs/reference/extras/instance) component:

```svelte
<InstancedMesh>
  <T.BoxGeometry />
  <T.MeshStandardMaterial />

  <Instance />
  <Instance />
</InstancedMesh>
```

It's also possible to nest other objects in an `<InstancedMesh>` component:

```svelte
<InstancedMesh>
  <T.BoxGeometry />
  <T.MeshStandardMaterial />

  <Instance />
  <Instance />

  <GLTF />
</InstancedMesh>
```

Provide an `id` to use multiple `<InstancedMesh>` components:

```svelte
<InstancedMesh id="tree">
  <T is={treeGeometry} />
  <T.MeshStandardMaterial map={treeTexture} />

  <InstancedMesh id="leaf">
    <T is={leafGeometry} />
    <T.MeshStandardMaterial map={leafTexture} />

    <T.Group position.x={1}>
      <Instance id="tree" /> // Instance of InstancedMesh with id="tree"
      <Instance id="leaf" /> // Instance of InstancedMesh with id="leaf"
    </T.Group>

    <T.Group position.x={-2}>
      <Instance id="tree" />
      <Instance id="leaf" />
    </T.Group>
  </InstancedMesh>
</InstancedMesh>
```

## Instance count

Use the property `limit` to set the maximum amount of `<Instance>` components (defaults to 1000). The property `limit` will be used to initialize the internally used Float32Array. Use the property `range` to optionally limit the amount of drawn instances.

```svelte {2,3}+
<InstancedMesh
  limit={10000}
  range={100}
>
  <T.BoxGeometry />
  <T.MeshStandardMaterial />

  <Instance />
  <Instance />
</InstancedMesh>
```

## Events

<Example path="extras/instanced-mesh/colors" />

Instances also support interactivity events.

```svelte {5}
<InstancedMesh>
  <T.BoxGeometry />
  <T.MeshStandardMaterial />

  <Instance onclick={onClick} />
</InstancedMesh>
```

## Nesting

Instances can be nested in other objects and all parent transformations apply as usual:

```svelte
<InstancedMesh>
  <T.BoxGeometry />
  <T.MeshStandardMaterial />

  <T.Group rotation.z={DEG2RAD * 180}>
    <Instance />

    <T.Group position.y={2}>
      <Instance />
    </T.Group>
  </T.Group>
</InstancedMesh>
```


================================================
File: apps/docs/src/content/reference/extras/instanced-meshes.mdx
================================================
---
order: 7.3
category: '@threlte/extras'
name: '<InstancedMeshes>'
sourcePath: 'packages/extras/src/lib/components/Instancing/InstancedMeshes'
type: 'component'
componentSignature:
  {
    extends:
      {
        type: 'InstancedMesh',
        url: 'https://threejs.org/docs/index.html#api/en/objects/InstancedMesh'
      },
    props:
      [
        {
          name: 'limit',
          type: 'number',
          default: '1000',
          required: false,
          description: 'Limits the amount of possible <Instance> components.'
        },
        {
          name: 'range',
          type: 'number',
          default: '1000',
          required: false,
          description: 'Limits the amount of drawn <Instance> components.'
        },
        {
          name: 'update',
          type: 'boolean',
          default: 'true',
          required: false,
          description: 'Whether the THREE.InstancedMesh should be updated.'
        },
        { name: 'meshes', type: 'THREE.Mesh[] | Record<string, THREE.Mesh>', required: true }
      ]
  }
---

The component `<InstancedMeshes>` takes existing `THREE.Mesh` instances and creates a `THREE.InstancedMesh` per `THREE.Mesh`. This is especially useful if you want to instantiate a lot of meshes that have been loaded with hooks like [`useGltf`](/docs/reference/extras/use-gltf).

It takes the same arguments as [`<InstancedMesh>`](/docs/reference/extras/instanced-mesh).

<Example path="extras/instanced-mesh/merged" />

## Usage

### Passing a map

Load a gltf file with the [`useGltf`](/docs/reference/extras/use-gltf) hook and pass the result to the `<InstancedMeshes>` component. The [slot prop](https://svelte.dev/docs#template-syntax-slot) `components` can be used to instantiate a mesh multiple times.

```svelte
<script lang="ts">
  import { useGltf, InstancedMeshes } from '@threlte/extras'

  // Let's say the file contains a mesh named "Cube".
  // The hook `useGltf`  will automatically provide a map with
  // all nodes of the gltf file at the key `nodes`. When
  // passing that map to the `<InstancedMeshes>` component, it will
  // automatically filter out all nodes that are not
  // `THREE.Mesh` instances.
  const gltf = useGltf('path/to/file.gltf')
</script>

{#if $gltf}
  <!--
    You can use object destructuring
    to access the component <Cube>
  -->
  <InstancedMeshes meshes={$gltf.nodes}>
    {#snippet children({ components: { Cube } })}
      <Cube position.y={2} position.x={-1}>
    {/snippet}
  </InstancedMeshes>
{/if}
```

<Tip type="tip">
  When using `<InstancedMeshes>` with a large gltf file, be aware that `<InstancedMeshes>` will
	create a new `<InstancedMesh>` for each `<Mesh>` in the gltf file.
  This can lead to a lot of `<InstancedMesh>` components, which can have a negative
  impact on performance. You might want to filter out the meshes you want to
  instantiate beforehand.
</Tip>

### Passing an array

If you don't want to use the `useGltf` hook, you can also pass an array of `THREE.Mesh` instances to the `<InstancedMeshes>` component.

```svelte
<script lang="ts">
  import { InstancedMeshes } from '@threlte/extras'
  import { Mesh, BoxGeometry, MeshStandardMaterial } from 'three'

  const meshes = [
    new Mesh(new BoxGeometry(), new MeshStandardMaterial()), // MeshA
    new Mesh(new SphereGeometry(), new MeshStandardMaterial()), // MeshB
    new Mesh(new PlaneGeometry(), new MeshStandardMaterial())  // MeshC
  ]
</script>

<!--
    You can use array destructuring
    to access the components <MeshA>,
    <MeshB> and <MeshC>
  -->
<InstancedMeshes meshes={meshes}>
  {#snippet children({ components: [MeshA, MeshB, MeshC] })}
    <MeshA position.y={2} position.x={-1}>
    <MeshB position.y={-2}>
    <MeshC position.y={0} position.x={1}>
  {/snippet}
</InstancedMeshes>
```


================================================
File: apps/docs/src/content/reference/extras/instanced-sprite.mdx
================================================
---
order: 7.4
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/components/InstancedSprite/InstancedSprite.svelte'
name: <InstancedSprite>
type: 'component'
componentSignature:
  {
    props:
      [
        {
          name: 'alphaTest',
          type: 'number',
          required: false,
          default: '0.1',
          description: 'Sets the alpha value to be used when running an alpha test.'
        },
        {
          name: 'autoUpdate',
          type: 'boolean',
          required: false,
          default: 'true',
          description: 'Update animations automatically every frame'
        },
        {
          name: 'baseMaterial',
          type: 'typeof MeshBasicMaterial | typeof MeshStandardMaterial | typeof MeshLambertMaterial | typeof MeshPhongMaterial',
          required: false,
          default: 'typeof MeshBasicMaterial',
          description: 'Base material used to construct the sprite material.'
        },
        {
          name: 'billboarding',
          type: 'boolean',
          required: false,
          default: 'typeof MeshBasicMaterial',
          description: 'Sets the default global billboarding state that is used unless the setAt was called on the instance.'
        },
        { name: 'count', type: 'number', required: true, description: 'Number of instances' },
        {
          name: 'fps',
          type: 'boolean',
          required: false,
          default: '10',
          description: 'The desired frames per second of the animation.'
        },
        {
          name: 'playmode',
          type: '"FORWARD" | "REVERSE" | "PAUSE" | "PINGPONG"',
          required: false,
          default: '"FORWARD"',
          description: 'Sets playmode for all instances'
        },
        {
          name: 'transparent',
          type: 'boolean',
          required: false,
          default: 'true',
          description: 'Whether or not the material should be transparent.'
        },
        {
          name: 'randomPlaybackOffset',
          type: 'boolean | number',
          required: false,
          default: 'true',
          description: 'Offset sprite animation time by a random number of milliseconds.'
        }
      ],
    bindings: [{ name: ref, type: 'InstancedSpriteMesh' }]
  }
---

import ComponentSignature from '../../../components/ComponentSignature/ComponentSignature.astro'

<Tip type="experimental">
  This is an early version - features and API might change significantly over time. Please report
  any issues you encounter on Discord or Github.
</Tip>

The `<InstancedSprite>` component allows you to efficiently spawn large numbers of animated
[sprites](<https://en.wikipedia.org/wiki/Sprite_(computer_graphics)>) in your scene and update each instance
using the `useInstancedSprite` hook, or with a `<Instance>` component available through a slot prop.

You can find an example of a [more complex scene here](/docs/examples/animation/complex-sprite-scene).

<Example path="extras/instanced-sprite" />

## `<InstancedSprite>`

To use the `<InstancedSprite>` you must provide it with sprite metadata and a texture. While we recommend utilizing the
[`buildSpritesheet()`](#buildSpritesheet) utility for this purpose, you are also free to implement your own
custom solution, provided it meets the component's input requirements.

Other than it's own props, `<InstanedSprite/>` extends and accepts all properties of
[Three.js instanced mesh](https://threejs.org/docs/#api/en/objects/InstancedMesh), such as `castShadow`, `frustumCulled` etc.

```svelte
<InstancedSprite
  bind:ref
  {spritesheet}
  count={500}
  playmode={'FORWARD'}
  fps={9}
  billboarding
  hueShift={{ h: 1.5, s: 0.9, v: 1 }}
  randomPlaybackOffset={2000}
  castShadow
/>
```

#### Required props

| Prop          | description                                                                                             |
| ------------- | ------------------------------------------------------------------------------------------------------- |
| `count`       | number of instances                                                                                     |
| `spritesheet` | Object with `spritesheet` metadata and a `texture` `{spritesheet: SpritesheetFormat, texture: Texture}` |

#### Optional props

| Prop                   | description                                                                                                                                                                                                                                                                     |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `autoUpdate`           | Update animations automatically. It should stay `true` for most usecases. Setting to `false` is most commonly used in case of [static sprites](#static-sprites--atlassing) but it can also be used for advanced manual animation updates.                                       |
| `billboarding`         | Sets the default global billboarding (sprites always facing the camera) state that is used unless the setAt was called on the instance.                                                                                                                                         |
| `playmode`             | Sets playmode for all instances. `"FORWARD" \| "REVERSE" \| "PAUSE" \| "PINGPONG"`                                                                                                                                                                                              |
| `fps`                  | The desired frames per second of the animation                                                                                                                                                                                                                                  |
| `alphaTest`            | Sets the alpha value to be used when running an alpha test                                                                                                                                                                                                                      |
| `transparent`          | Whether or not the material should be transparent                                                                                                                                                                                                                               |
| `randomPlaybackOffset` | Offset each sprite's animation timer by a random number of milliseconds. If `true`, randomness is within 0-100ms range. Providing the prop with a number sets the upper range of the offset - `randomPlaybackOffset={2000}` means that the animation will be offset by 0-2000ms |
| `hueShift`             | Changes sprite look by tweaking the material's output color by a provided hueShift, saturation and vibrance `{h: number, s: number, v:number}`                                                                                                                                  |

You create and update instances in three ways:

1. Utilizing the `useInstancedSprite()` hook (recommended approach).
2. Using the `<Instance>` component offered through a slot prop.
3. Directly with the underlying class using the `ref` binding.

### `useInstancedSprite`

The hook has to be used in a child component of `<InstancedSprite>` and returns an object with following properties:

- `count`: Total number of instances.
- `updatePosition(id: number, position: Vector3Tuple, scale?: Vector2Tuple)`: A utility function for updating an instance's position and scale.
- `animationMap`: A writable store (`Writable<Map<string, number>>`) that maps animation names to their corresponding IDs.
  Animation names are useful to have for setting a random animation from a pool etc. The IDs are reserved for more advanced usecases.
- `sprite`: Provides direct access to the `InstancedSpriteMesh`, enabling updates to instance properties such as animations, billboarding, and play mode.

```ts
import { useInstancedSprite } from '@threlte/extras'

const hook = useInstancedSprite()
// it's useful to immediately destructure it like this
const { updatePosition, count, animationMap, sprite } = useInstancedSprite()

// Examples of using the InstancedSpriteMesh API:

// play animation on instance id 0 - loops by defualt
sprite.play('IdleBackward').at(0)
// play animation without looping
sprite.play('RunLeft', false).at(1)
// play animation backwards with looping
sprite.play('RunLeft', true, 'REVERSE').at(2)

// mesh.play is a utility that combines the use of these functions:
// animation by name
sprite.animation.setAt(0, 'RunBackward')
// looping y/n
sprite.loop.setAt(0, false)
// animation direction - FORWARD (default) / REVERSE / PAUSE
sprite.playmode.setAt(0, 'REVERSE')

// billboarding
sprite.billboarding.setAll(true)
sprite.billboarding.setAt(0, true)
```

#### Typescript support

The useInstancedSprite hook supports typing for autocompletion of animation names:

```ts
type AnimationNames = 'walk' | 'run' | 'idle' | 'fly'
const { updatePosition, count, animationMap, sprite } = useInstancedSprite<AnimationNames>()
```

### `<Instance>`

Instance is a slot prop component that is used to update sprite instances properties. You can gain access to it with the `Instance` snippet prop on `InstancedSprite` component.
Then put it as a child component. The only required property is `id`. It also has `position` of type `Vector3Tuple` prop and `scale` of type `Vector2Tuple`.

Other than this, it as other properties that you can find in the `InstancedSpriteMesh`, so: `animationName`, `playmode`, `billboarding`, `offset`, `loop`,
`flipX`, `flipY`, `frameId`. Read more about them in the [InstancedSpriteMesh](#instancedspritemesh) section

The `<Instance>` component serves as a declarative alternative to `useInstancedSprite` hook to dynamically update the properties of sprite instances within the
`InstancedSprite` component. You can access through the `Instance` snippet prop.

_Example: Set a position, scale and flipX for every instance._

```svelte
<InstancedSprite
  count={10000}
  {spritesheet}
>
  {#snippet children({ Instance })}
    {#each { length: 10000 } as _, i}
      <Instance
        position={[Math.random() * 100, Math.random() * 100, Math.random() * 100]}
        scale={[3, 3]}
        flipX
        id={i}
      />
    {/each}
  {/snippet}
</InstancedSprite>
```

<ComponentSignature
  titleOverride={` `}
  idOverride="instance-component-signature"
  componentName={'<Instance/>'}
  signature={{
    props: [
      {
        name: 'id',
        type: 'number',
        required: true,
        description: 'Instance id. Ranges between 0 and the `count` value of InstacedSpriteMesh.'
      },
      {
        name: 'animationName',
        type: 'string',
        required: false,
        description: 'Sets an active animation by name.'
      },
      {
        name: 'position',
        type: 'Vector3Tuple',
        required: false,
        description: 'Sets the position of an instance.'
      },
      {
        name: 'scale',
        type: 'Vector2Tuple',
        required: false,
        description: 'Sets the scale of an instance.'
      },
      {
        name: 'playmode',
        type: '"FORWARD" | "REVERSE" | "PAUSE" | "PINGPONG"',
        required: false,
        description: 'Sets the playmode of an instance.'
      },
      {
        name: 'billboarding',
        type: 'boolean',
        required: false,
        description: 'Toggles billboarding on/off.'
      },
      {
        name: 'offset',
        type: 'number',
        required: false,
        description: 'Sets the exact time value in ms by which the animation playback is offset.'
      },
      {
        name: 'loop',
        type: 'boolean',
        required: false,
        description:
          'Toggles looping of the animation on/off. If off, the last played frame is displayed when the animation completes.'
      },
      {
        name: 'flipX',
        type: 'boolean',
        required: false,
        description: 'Toggles flipping the sprite horizontally.'
      },
      {
        name: 'flipY',
        type: 'boolean',
        required: false,
        description: 'Toggles flipping the sprite vertically.'
      },
      {
        name: 'frameId',
        type: 'number',
        required: false,
        description: `Sets an exact frame to display. If animationName is set, it's the id of the frame in that given animation, otherwise it's a spritesheet frame id.`
      }
    ]
  }}
/>

### binding

The `InstancedSpriteMesh` class is the foundation behind the `<InstancedSprite>` component, written to enable efficient instancing of animated sprites within a
Three.js environment. The `<InstancedSprite>` component lets you bind to it through `ref`.

The class extends the capabilities of the [troika's InstancedUniformsMesh](https://protectwise.github.io/troika/three-instanced-uniforms-mesh/). For an in-depth exploration of `InstancedSpriteMesh` and its features, refer to the documentation available at [InstancedSpriteMesh docs](https://three-kit.vercel.app/instancedsprite/01-instanced-sprite-mesh/).

## Spritesheets

### SpritesheetMetadata

Object used in `buildSpritesheet` function has to be compliant with the `SpritesheetMetadata` type format. This type is structured to
accommodate the metadata for one or multiple sprite files within a single spritesheet.

```ts
type SpritesheetMetadata = {
  url: string
  type: 'rowColumn' | 'frameSize'
  width: number
  height: number
  animations: {
    name: string
    frameRange: [number, number]
  }[]
}[]
```

#### Understanding SpritesheetMetadata

A `SpritesheetMetadata` is an array, with each entry representing metadata fields for one sprite:

    - `url`: Specifies the path or URL to the sprite image file.
    - `type`: Determines the method of defining the spritesheet dimensions. Type `"rowColumn"` specifies the layout in terms of rows
    and columns within the image, and type `"frameSize"` instead defines the size of each frame, allowing the utility to calculate the layout.
    - `width` and `height`: Depending on type, these refer to the number of `columns` and `rows` (`"rowColumn"`) or the dimensions of a single frame (`"frameSize"`).
    - `animations`: An array detailing the animations, where each animation has a name and a `frameRange`. The `frameRange` is a tuple
    marking the start and end frames of the animation.

#### Typesafety

For improved developer experience when working with TypeScript, it is strongly recommended to use `as const` assertion in
combination with `satisfies SpritesheetMetadata`. This approach not only ensures compliance with the `SpritesheetMetadata`
type but also enables autocompletion for animation names within utility functions, which is highly recommended:

### `buildSpritesheet()`

`buildSpritesheet()` is a utility function for building a final texture and spritesheet object from a provided `SpritesheetMetadata` object or external source.
Each `buildSpritesheet` method return an Promise that and has to be awaited. Promise returned by each method contains an object with a `spritesheet`
ready for use in `<InstancedSprite>`.

#### buildSpritesheet().from(meta: SpritesheetMetadata)

Other than `spritesheet` promise, it also returns a `useInstancedSprite` hook. This hook can be enhanced with
extra typescript support for autocompletion of animation names as such:

```ts
const meta = [
  {
    url: '/textures/sprites/cacodaemon.png',
    type: 'rowColumn',
    width: 8,
    height: 4,
    animations: [
      { name: 'fly', frameRange: [0, 5] },
      { name: 'attack', frameRange: [8, 13] },
      { name: 'idle', frameRange: [16, 19] },
      { name: 'death', frameRange: [24, 31] }
    ]
  }
] as const satisfies SpritesheetMetadata

const result = buildSpritesheet.from<typeof meta>(meta)
```

![Tree sprite atlas](/images/docs/extras/instanced-sprite/useInstancedSpriteAutocomplete.png)

#### buildSpritesheet().fromAseprite(asepriteDataUrl: string, spriteImageUrl: string)

Similar to above, but it parses the Aseprite metadata json into the correct format.
Does not provide any additional utilities.

### Examples

#### Multiple animations

```ts
const demonSpriteMeta = [
  {
    url: '/textures/sprites/cacodaemon.png',
    type: 'rowColumn',
    width: 8,
    height: 4,
    animations: [
      { name: 'fly', frameRange: [0, 5] },
      { name: 'attack', frameRange: [8, 13] },
      { name: 'idle', frameRange: [16, 19] },
      { name: 'death', frameRange: [24, 31] }
    ]
  }
] as const satisfies SpritesheetMetadata
```

#### Multiple files

```ts
const goblinSpriteMeta = [
  {
    url: '/textures/sprites/goblin/Attack.png',
    type: 'rowColumn',
    width: 8,
    height: 1,
    animations: [{ name: 'attack', frameRange: [0, 7] }]
  },
  {
    url: '/textures/sprites/goblin/Death.png',
    type: 'rowColumn',
    width: 4,
    height: 1,
    animations: [{ name: 'death', frameRange: [0, 3] }]
  },
  {
    url: '/textures/sprites/goblin/Idle.png',
    type: 'rowColumn',
    width: 4,
    height: 1,
    animations: [{ name: 'idle', frameRange: [0, 3] }]
  }
] as const satisfies SpritesheetMetadata
```

## Static sprites & Atlassing

This component focuses on targetting animated sprites, but it's possible to use it for static images as well. If each frame of the spritesheet is a separate animation, then it effectively acts as an [atlas](https://en.wikipedia.org/wiki/Texture_atlas) with named sprites.

The `<Tree/>` component in the example above does this.
![Tree sprite atlas](/textures/sprites/trees-pixelart.png)

Set `autoUpdate={false}` on static components and only update it manually with `sprite.update()`. This has to be done when the InstancedSprite is initiated or when spritesheet or atlas change.
If you don't do it, then the spritesheet will run animation updates each frame to run animations that don't really exist.


================================================
File: apps/docs/src/content/reference/extras/interaction.mdx
================================================
---
category: '@threlte/extras'
name: Interaction
order: 2
isDivider: true
---


================================================
File: apps/docs/src/content/reference/extras/interactivity.mdx
================================================
---
order: 2.5
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/interactivity'
name: 'interactivity'
type: 'plugin'
---

To add click, pointer and wheel events to your Threlte app use the `interactivity` plugin.

```svelte title="Scene.svelte" {2,3}+
<script>
  import { interactivity } from '@threlte/extras'
  interactivity()
</script>
```

<Example path="extras/interactivity" />

All child components can now make use of the new events.

```svelte title="Scene.svelte" {7-9}+
<script>
  import { interactivity } from '@threlte/extras'
  interactivity()
</script>

<T.Mesh
  onclick={() => {
    console.log('clicked')
  }}
>
  <T.BoxGeometry />
  <T.MeshStandardMaterial color="red" />
</T.Mesh>
```

## Available Events

The following interaction events are available:

```svelte
<T.Mesh
  onclick={(e) => console.log('click')}
  oncontextmenu={(e) => console.log('context menu')}
  ondblclick={(e) => console.log('double click')}
  onwheel={(e) => console.log('wheel')}
  onpointerup={(e) => console.log('up')}
  onpointerdown={(e) => console.log('down')}
  onpointerover={(e) => console.log('over')}
  onpointerout={(e) => console.log('out')}
  onpointerenter={(e) => console.log('enter')}
  onpointerleave={(e) => console.log('leave')}
  onpointermove={(e) => console.log('move')}
  onpointermissed={() => console.log('missed')}
/>
```

## Event Data

All interaction events contain the following data:

```typescript
type Event = THREE.Intersection & {
  intersections: THREE.Intersection[] // The first intersection of each intersected object
  object: THREE.Object3D // The object that was actually hit
  eventObject: THREE.Object3D // The object that registered the event
  camera: THREE.Camera // The camera used for raycasting
  delta: THREE.Vector2 //  Distance between mouse down and mouse up event in pixels
  nativeEvent: MouseEvent | PointerEvent | WheelEvent // The native browser event
  pointer: Vector2 // The pointer position in normalized device coordinates
  ray: THREE.Ray // The ray used for raycasting
  stopPropagation: () => void // Function to stop propagation of the event
  stopped: boolean // Whether the event propagation has been stopped
}
```

## Event Propagation

Propagation works a bit differently to the DOM because objects can occlude each other in 3D.
The intersections array in the event data includes all objects intersecting the ray, not just the
nearest. Only the first intersection with each object is included. The event is first delivered
to the object nearest the camera, and then bubbles up through its ancestors like in the DOM.
After that, it is delivered to the next nearest object, and then its ancestors, and so on.
This means objects are transparent to pointer events by default, even if the object handles
the event.

`event.stopPropagation()` doesn't just stop this event from bubbling up, it also stops it from
being delivered to farther objects (objects behind this one). All other objects, nearer or farther,
no longer count as being hit while the pointer is over this object. If they were previously
delivered pointerover events, they will immediately be delivered pointerout events. If you want
an object to block pointer events from objects behind it, it needs to have an event handler as follows:

```svelte
<T.Mesh onclick={(e) => e.stopPropagation()} />
```

even if you don't want this object to respond to the pointer event. If you do want to handle the
event as well as using `stopPropagation()`, remember that the `pointerout` events will happen during
the `stopPropagation()` call. You probably want your other event handling to happen after this.

## Interactivity Event Target

If no event target is specified, all event handlers listen to events on the `domElement` of the
`renderer` (which is the canvas element by default). You can specify a different target by passing
a `target` prop to the `interactivity` plugin.

```svelte title="Scene.svelte"
<script>
  import { interactivity } from '@threlte/extras'

  interactivity({
    target: document
  })
</script>
```

It's also possible to change the target at runtime by updating the store `target` returned from the
`interactivity` plugin.

```svelte title="Scene.svelte"
<script>
  import { interactivity } from '@threlte/extras'

  const { target } = interactivity()

  $effect(() => {
    target.set(document)
  })
</script>
```

## Interactivity Event Compute

In the event that your event target is not the same size as the canvas, you can pass a `compute` function
to the `interactivity` plugin. This function receives the DOM event and the interactivity state and should
set the `pointer` property of the state to the pointer position in normalized device coordinates as well
as set the raycaster up for raycasting.

```svelte title="Scene.svelte"
<script>
  import { interactivity } from '@threlte/extras'
  import { useThrelte } from '@threlte/core'

  const { camera } = useThrelte()

  interactivity({
    compute: (event, state) => {
      // Update the pointer
      state.pointer.update((p) => {
        p.x = (event.clientX / window.innerWidth) * 2 - 1
        p.y = -(event.clientY / window.innerHeight) * 2 + 1

        return p
      })

      // Update the raycaster
      state.raycaster.setFromCamera(state.pointer.current, $camera)
    }
  })
</script>
```

## Interactivity Event Filtering

You can filter and sort events by passing a `filter` to the `interactivity` plugin. The function receives all hits and the interactivity state and should return the hits that should be delivered to the event handlers in the order they should be delivered.

```svelte title="Scene.svelte"
<script>
  import { interactivity } from '@threlte/extras'

  interactivity({
    filter: (hits, state) => {
      // Only return the first hit
      return hits.slice(0, 1)
    }
  })
</script>
```

## Interactivity State

To access the interactivity state, you can use the `useInteractivity` hook in any child component of the component that implements the `interactivity` plugin as follows:

```svelte title="Child.svelte"
<script>
  import { useInteractivity } from '@threlte/extras'

  const { pointer, pointerOverTarget } = useInteractivity()

  $inspect($pointer, $pointerOverTarget)
</script>
```

where this is the type of the interactivity state:

```ts
export type State = {
  enabled: CurrentWritable<boolean>
  target: CurrentWritable<HTMLElement | undefined>
  pointer: CurrentWritable<Vector2>
  pointerOverTarget: CurrentWritable<boolean>
  lastEvent: MouseEvent | WheelEvent | PointerEvent | undefined
  raycaster: Raycaster
  initialClick: [x: number, y: number]
  initialHits: THREE.Object3D[]
  hovered: Map<string, IntersectionEvent<MouseEvent | WheelEvent | PointerEvent>>
  interactiveObjects: THREE.Object3D[]
  compute: ComputeFunction
  filter?: FilterFunction
}
```

<Tip type="tip">
  [`CurrentWritable`](/docs/reference/core/utilities#currentwritable) is a custom Threlte store.
  It's a regular writable store that also has a `current` property which is the current value of the
  store. It's useful for accessing the value of a store in a non-reactive context, such as in loops.
</Tip>

## TypeScript

### Prop Types

By default, the `interactivity` plugin does not add any prop types to the `<T>`
component. You can however extend the types of the `<T>` component by defining
the `Threlte.UserProps` type in your ambient type definitions. In a typical
SvelteKit application, you can find these [in
`src/app.d.ts`](https://svelte.dev/docs/kit/types#app.d.ts). The interactivity
plugin exports the `InteractivityProps` type which you can use as shown below:

```ts title="src/app.d.ts"
import type { InteractivityProps } from '@threlte/extras'

declare global {
  namespace Threlte {
    interface UserProps extends InteractivityProps {}
  }
}

export {}
```

Now all event handlers on `<T>` components will be type safe.

```svelte title="Scene.svelte"
<script>
  import { interactivity } from '@threlte/extras'
  interactivity()
</script>

<T.Mesh
  onclick={(e) => {
    // e: IntersectionEvent<MouseEvent>
  }}
/>
```


================================================
File: apps/docs/src/content/reference/extras/layers.mdx
================================================
---
order: 8.3
category: '@threlte/extras'
name: 'layers'
sourcePath: 'packages/extras/src/lib/layers'
type: 'plugin'
---

`layers` is a plugin that provides inheritance for the property `layers` on `<T>` components.
Typically when assigning a value to `layers` on a `<T>` component, it will only be applied to that component.
This plugin allows you to assign a value to `layers` on a parent component and have it be inherited by all child components.

<Tip type="tip">
  This plugin injects and relies on a context. It's affecting all `<T>` components that are
	descendants of the component that uses it. Check out the [guide on structuring your
  app](/docs/learn/basics/app-structure) to learn more about contexts.
</Tip>

## Usage

```svelte title="Scene.svelte" {2,3}+
<script>
  import { layers } from '@threlte/extras'
  layers()
</script>

<!--
The camera needs to be on the same layer
as an object for the object to be visible
-->
<T.PerspectiveCamera layers={[4, 5]} />

<!--
Everything inside this group that isn't
assigned another layer is on layer 4 and
is therefore visible to the camera
-->
<T.Group layers={4}>
  <T.Mesh>
    <T.BoxGeometry />
    <T.MeshStandardMaterial />
  </T.Mesh>

  <!-- This Mesh is on all layers -->
  <T.Mesh layers={'all'}>
    <T.BoxGeometry />
    <T.MeshStandardMaterial />
  </T.Mesh>
</T.Group>
```


================================================
File: apps/docs/src/content/reference/extras/linear-gradient-texture.mdx
================================================
---
order: 5.9
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/components/GradientTexture/LinearGradientTexture.svelte'
name: '<LinearGradientTexture>'
type: 'component'
componentSignature:
  {
    extends:
      {
        type: 'CanvasTexture',
        url: 'https://threejs.org/docs/index.html#api/en/textures/CanvasTexture'
      },
    props:
      [
        {
          default: '1024',
          description: "width of the texture's canvas",
          name: 'width',
          required: false,
          type: 'number'
        },
        {
          default: '1024',
          description: "height of the texture's canvas",
          name: 'height',
          required: false,
          type: 'number'
        },
        {
          required: false,
          default: '0',
          description: x-axis coordinate of the gradient's start point,
          name: 'startX',
          type: 'number'
        },
        {
          required: false,
          default: '0',
          description: y-axis coordinate of the gradient's start point,
          name: 'startY',
          type: 'number'
        },
        {
          required: false,
          default: '0',
          description: x-axis coordinate of the gradient's end point,
          name: 'endX',
          type: 'number'
        },
        {
          required: false,
          default: 'height',
          description: y-axis coordinate of the gradient's end point,
          name: 'endY',
          type: 'number'
        },
        {
          default: "[{color: '#000000', offset: 0}, {color: '#ffffff', offset: 1}]",
          description: 'list of stops applied to the gradient. more info at https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createLinearGradient',
          name: 'stops',
          required: false,
          type: 'GradientStop[]'
        }
      ]
  }
---

A reactive linear gradient texture. The underlying texture uses an [OffscreenCanvas](https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas) and a [CanvasTexture](https://threejs.org/docs/index.html#api/en/textures/CanvasTexture) and is assigned the same [colorspace](https://threejs.org/docs/index.html#api/en/textures/Texture.colorSpace) as the renderer.

<Example path="extras/gradient-texture/linear" />

## Attaching the Texture

The texture is automatically attached to the `map` property of its parent. You can disable this behaviour by setting the `attach` prop to `false`. This may be useful if you want to create the texture but use it somewhere else.

```svelte
<script>
  let texture = $state()
</script>

<LinearGradientTexture
  attach={false}
  bind:ref={texture}
/>

<SomeComponent {texture} />
```

## Gradient Stops

`<LinearGradientTexture>` accepts a `stops` prop which is an array of color stops that define the gradient. A stop is defined by two things; an `offset` and a `color`. Gradient stops are identical to how you would use them with a [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createLinearGradient#examples), notably the `offset` should be a number between 0 and 1 inclusive. Stop colors can be any valid color representation in ThreeJS. Here are a couple examples of valid stops.

```svelte
<LinearGradientTexture
  stops={[
    { color: 'black', offset: 0 },
    { color: 'white', offset: 1 }
  ]}
/>

<LinearGradientTexture
  stops={[
    { color: '#00ffff', offset: 0 },
    { color: '#ff00ff', offset: 0.5 },
    { color: '#ffff00', offset: 1 }
  ]}
/>
```

You can even mix and match color representations

```svelte
<LinearGradientTexture
  stops={[
    { color: 'red', offset: 0 },
    { color: 0xff_00_00, offset: 0.25 },
    { color: 'rgb(255, 0, 0)', offset: 0.5 },
    { color: '#ff0000', offset: 0.75 },
    { color: new Color(new Color(new Color())).set(1, 0, 0), offset: 1 }
  ]}
/>
```

All of the colors above are valid representations of the color <span style="color: red">red</span>.

## Gradient Start Point and End Point

You can control the gradient start point and end point with the `startX`, `startY`, `endX`, and `endY` props. For example, the props for a gradient that starts at the bottom left corner of the texture and ends at the top right corner would be:

```svelte
<LinearGradientTexture
  startX={0}
  startY={height}
  endX={width}
  endY={0}
/>
```

## Adjusting Scene Colors

If the colors in your scene do not match the color in your stops, you may need to adjust the tone mapping of the scene. `ToneMapping` constants are imported from the three library.

```svelte
<script>
  import { useThrelte } from '@threlte/core'
  import { LinearToneMapping } from 'three'

  const { toneMapping } = useThrelte()

  toneMapping.set(LinearToneMapping)
</script>
```


================================================
File: apps/docs/src/content/reference/extras/loading.mdx
================================================
---
category: '@threlte/extras'
name: Loading
order: 3
isDivider: true
---


================================================
File: apps/docs/src/content/reference/extras/mask.mdx
================================================
---
order: 5.4
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/components/Mask/Mask.svelte'
name: <Mask>
type: 'component'
componentSignature:
  {
    extends: { type: 'Mesh', url: 'https://threejs.org/docs/index.html#api/en/objects/Mesh' },
    'props':
      [
        {
          name: 'id',
          type: 'number',
          required: false,
          default: '1',
          'description': 'Each mask must have an id, you can have compound masks referring to the same id.'
        },
        {
          name: 'colorWrite',
          type: 'boolean',
          required: false,
          default: 'false',
          'description': 'If colors of the masks own material will leak through.'
        },
        {
          name: 'depthWrite',
          type: 'boolean',
          required: false,
          default: 'false',
          'description': 'If depth  of the masks own material will leak through.'
        }
      ]
  }
---

Masks use the stencil buffer to cut out areas of the screen. This component is a port of [drei's `<Mask>` component](https://github.com/pmndrs/drei#mask).

<Tip type="warning">The Mask component requires Three.js to render with a stencil buffer. As of [r163](https://github.com/mrdoob/three.js/releases/tag/r163), stencil is set to `false` by default. To enable the stencil buffer, set it in your canvas's renderer: `<Canvas createRenderer={(canvas)=>{return new WebGLRenderer({canvas,stencil: true })}}>`. In prior versions the default is `true` already.</Tip>

<Example path="extras/mask" />

First you need to define a mask, give it the shape that you want.

```svelte
<Mask id={1}>
  <T.PlaneGeometry />
  <T.MeshBasicMaterial />
</Mask>
```

Now refer to it with the `useMask` hook and the same id, your content will now be masked out by the geometry defined above.

```svelte
<script lang="ts">
  import { useMask } from '@threlte/extras'
  const stencil = useMask(1)
</script>

<T.Mesh>
  <T.TorusKnotGeometry />
  <T.MeshStandardMaterial {...stencil} />
</T.Mesh>
```

You can build compound masks with multiple shapes by re-using an id. You can also use the mask as a normal mesh by providing colorWrite and depthWrite props.

```svelte
<Mask
  position={[-1, 0, 0]}
  id={1}
>
  <T.PlaneGeometry />
  <T.MeshBasicMaterial />
</Mask>
<Mask
  colorWrite
  depthWrite
  position={[1, 0, 0]}
  id={1}
>
  <T.CircleGeometry />
  <T.MeshBasicMaterial />
</Mask>
```

Invert masks individually by providing a 2nd boolean argument to the useMask hook.

```ts
const stencil = useMask(1, true)
```


================================================
File: apps/docs/src/content/reference/extras/mesh-bounds.mdx
================================================
---
order: 7.8
category: '@threlte/extras'
name: 'meshBounds'
sourcePath: 'packages/extras/src/lib/utilities/meshBounds.ts'
---

A raycast function that will first check for collision with the object's
bounding sphere, then it will check against the object's bounding box but
**only** if the bounding box has been previously computed. You can use this
function if you want to trade pointer precision for an increase in performance.

## Usage

### Basic Usage

`meshBounds` can simply be passed to an object's
[`raycast`](https://threejs.org/docs/index.html?q=mesh#api/en/objects/Mesh.raycast)
prop.

```svelte
<script>
  import { meshBounds } from '@threlte/extras'
</script>

<T.Mesh raycast={meshBounds}>
  <T.BoxGeometry />
</T.Mesh>
```

<Tip type="tip">
  If your meshes or models aren't very complex in terms of geometry, `meshBounds` won't provide much
  of a performance boost.
</Tip>

<Example
  path="extras/mesh-bounds"
  showFile="Scene.svelte"
/>

### Creating a plugin

Instead of manually applying the `meshBounds` raycast function to each mesh, you
can use a [Threlte plugin](/docs/learn/advanced/plugins) to automatically
apply the `meshBounds` raycast function to all meshes in your scene.

```svelte title="Scene.svelte"
<script>
  import { T, injectPlugin, isInstanceOf } from '@threlte/core'
  import { meshBounds } from '@threlte/extras'

  injectPlugin('mesh-bounds-plugin', (args) => {
    if (isInstanceOf(args.ref, 'Mesh')) {
      args.ref.raycast = meshBounds
    }
  })
</script>

<!-- No need to manually apply the meshBounds raycast function -->
<T.Mesh>
  <T.MeshBasicMaterial color="hotpink" />
  <T.BoxGeometry />
</T.Mesh>
```

To selectively apply the `meshBounds` raycast function to only certain meshes,
you can listen to a prop (e.g. `raycastMeshBounds`) and conditionally apply the
function.

```svelte title="Scene.svelte"
<script>
  import { T, injectPlugin, isInstanceOf } from '@threlte/core'
  import { meshBounds } from '@threlte/extras'
  import { onDestroy } from 'svelte'

  injectPlugin('mesh-bounds-plugin', (args) => {
    if (!isInstanceOf(args.ref, 'Mesh')) return

    const originalRaycast = args.ref.raycast

    $effect(() => {
      if (!!args.props.raycastMeshBounds) {
        args.ref.raycast = meshBounds
      } else {
        args.ref.raycast = originalRaycast
      }
    })

    onDestroy(() => {
      args.ref.raycast = originalRaycast
    })

    return {
      pluginProps: ['raycastMeshBounds']
    }
  })
</script>

<!-- Regular raycasting -->
<T.Mesh>
  <T.MeshBasicMaterial color="hotpink" />
  <T.BoxGeometry />
</T.Mesh>

<!-- meshBounds raycasting -->
<T.Mesh raycastMeshBounds>
  <T.MeshBasicMaterial color="hotpink" />
  <T.BoxGeometry />
</T.Mesh>
```


================================================
File: apps/docs/src/content/reference/extras/mesh-refraction-material.mdx
================================================
---
order: 5.7
category: '@threlte/extras'
name: '<MeshRefractionMaterial>'
sourcePath: 'packages/extras/src/lib/components/MeshRefractionMaterial/MeshRefractionMaterial.svelte'
type: 'component'
componentSignature:
  {
    extends:
      {
        type: 'ShaderMaterial',
        url: 'https://threejs.org/docs/index.html#api/en/materials/ShaderMaterial'
      },
    props:
      [
        { name: 'envMap', type: 'CubeTexture | Texture', required: true },
        {
          name: 'bounces',
          type: 'number',
          default: '2',
          required: false,
          description: 'Number of ray-cast bounces, it can be expensive to have too many'
        },
        {
          name: 'ior',
          type: 'number',
          default: '2.4',
          required: false,
          description: 'Refraction index'
        },
        {
          name: 'fresnel',
          type: 'number',
          default: '0.0',
          required: false,
          description: 'Fresnel (strip light)'
        },
        {
          name: 'aberrationStrength',
          type: 'number',
          default: '0.0',
          required: false,
          description: 'RGB shift intensity, can be expensive'
        },
        { name: 'color', type: 'ColorRepresentation', default: 'white', required: false },
        {
          name: 'fastChrome',
          type: 'boolean',
          default: 'true',
          required: false,
          description: 'If this is on it uses fewer ray casts for the RGB shift sacrificing physical accuracy'
        }
      ]
  }
---

<Tip type="info">
  To use this component you need to install the seperate library `three-mesh-bvh`, please run `npm
  install three-mesh-bvh` before adding this component to your project.
</Tip>

<Tip type="experimental">
  This material may not work reliably on some devices or browsers. We're investigating possible
  fixes.
</Tip>

This component is a port of [drei's `<MeshRefractionMaterial>`
component](https://github.com/pmndrs/drei#meshrefractionmaterial), a convincing Glass/Diamond refraction material.

<Example path="extras/mesh-refraction-material" />

## Examples

### Basic Example

You can either pass in a texture to use as the environment:

```svelte title="RefractionWithTexture.svelte"
<script lang="ts">
  import { T, useLoader } from '@threlte/core'
  import { MeshRefractionMaterial } from '@threlte/extras'
  import { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js'

  const env = useLoader(RGBELoader).load('/hdr/aerodynamics_workshop_1k.hdr')
</script>

{#await env then texture}
  <T.Mesh>
    <MeshRefractionMaterial envMap={texture} />
    <T.IcosahedronGeometry args={[4, 0]} />
  </T.Mesh>
{/await}
```

or you can use a cube camera to generate the environment:

```svelte title="RefractionWithCubeCamera.svelte"
<script lang="ts">
  import { T, useThrelte, useTask } from '@threlte/core'
  import { MeshRefractionMaterial } from '@threlte/extras'
  import { WebGLCubeRenderTarget, CubeCamera } from 'three'

  let renderTarget: WebGLCubeRenderTarget = new WebGLCubeRenderTarget(128)
  let cubeCamera: CubeCamera = new CubeCamera(0.1, 100, renderTarget)

  const { scene, renderer } = useThrelte()

  useTask(() => {
    if (cubeCamera) {
      cubeCamera.update(renderer, scene)
    }
  })
</script>

<T.Mesh>
  <MeshRefractionMaterial envMap={renderTarget.texture} />
  <T.IcosahedronGeometry args={[4, 0]} />
</T.Mesh>
```


================================================
File: apps/docs/src/content/reference/extras/meshline-geometry.mdx
================================================
---
order: 5.5
category: '@threlte/extras'
name: <MeshLineGeometry>
sourcePath: 'packages/extras/src/lib/components/MeshLine/MeshLineMaterial.svelte'
type: 'component'
componentSignature:
  {
    extends:
      {
        type: 'BufferGeometry',
        url: 'https://threejs.org/docs/index.html#api/en/core/BufferGeometry'
      },
    props:
      [
        {
          name: 'points',
          type: 'THREE.Vector3[]',
          default: '[]',
          required: true,
          description: 'The array of points that form the line.'
        },
        {
          name: 'shape',
          type: "'none' | 'taper' | 'custom'",
          default: "'none'",
          required: false,
          description: "The shape of the line. Use 'custom' to use your own function."
        },
        {
          name: 'shapeFunction',
          type: '(p:number) => number',
          default: 'p => 1',
          required: false,
          description: 'A function to define the width of each point along the line. For example `p => 1 - p` will make the line taper.'
        }
      ]
  }
---

Used in combination with [`<MeshLineMaterial>`](/docs/reference/extras/meshline-material) to create a line formed of a strip of billboarded triangles, based on <a href="https://github.com/spite/THREE.MeshLine" target="_blank">THREE.MeshLine</a>.

<Example path="extras/meshline-geometry" />

## Usage

This component works by taking an array of points to form a line geometry without any thickness, which is then projected and expanded in screen space by `<MeshLineMaterial>`.
Both `<MeshLineMaterial>` and `<MeshLineGeometry>` need to be the children of the same parent mesh.

### Example

```svelte
<script>
  const points = [new Vector3(-1, 1, -1), new Vector3(0, 1, 0), new Vector3(1, 1, 1)]
</script>

<T.Mesh>
  <MeshLineGeometry {points} />
  <MeshLineMaterial
    width={0.5}
    color="#fe3d00"
  />
</T.Mesh>
```

### Points

The `points` property is required and accepts an array of `THREE.Vector3` objects.
The `points` property is reactive and you can animate the line by updating the positions of the `Vector3` objects within the array.

<Tip type="warning">
  When updating the <b>points</b> array you must ensure the updated array is the same length as the
  initial array, otherwise the points will not update. In other words you can alter the position of
  points in the array but you cannot add or remove points.
</Tip>

### Shape

By default the line will be a constant thickness along it's length, at a width defined in `<MeshLineMaterial>`.
To create a line that tapers down to a point at each end you can set the `shape` property to `'taper'`.

For more control over the shape of the line you can set the `shape` property to `'custom'` and pass a custom function to the `shapeFunction` property.

The function will define the width at each point along the line, for example `p => 2` will make the line double the width.
The property `p` is the percentage of the number of points, i.e. for point 200 of 250 points, p = 0.8.
For example the following code will define a line that tapers off at one end:

```svelte
<T.Mesh>
  <MeshLineGeometry
    {points}
    shape={'custom'}
    shapeFunction={(p) => 1 - p}
  />
  <MeshLineMaterial />
</T.Mesh>
```


================================================
File: apps/docs/src/content/reference/extras/meshline-material.mdx
================================================
---
order: 5.6
category: '@threlte/extras'
name: <MeshLineMaterial>
sourcePath: 'packages/extras/src/lib/components/MeshLine/MeshLineMaterial.svelte'
type: 'component'
componentSignature:
  {
    extends:
      { type: 'ShaderMaterial', url: 'https://threejs.org/docs/#api/en/materials/ShaderMaterial' },
    props:
      [
        {
          name: 'color',
          type: 'ColorRepresentation',
          default: "'#ffffff'",
          required: false,
          description: 'The color of the line.'
        },
        {
          name: 'width',
          type: 'number',
          default: '1',
          required: false,
          description: "The width of the line. If attenuate is true it's world units, otherwise it's screen pixels."
        },
        {
          name: 'opacity',
          type: 'number',
          default: '1',
          required: false,
          description: 'The opacity of the line. For values less than 1 transparent must be set to true.'
        },
        {
          name: 'dashArray',
          type: 'number',
          default: '0',
          required: false,
          description: 'The length and space between dashes. 0 = no dash.'
        },
        {
          name: 'dashOffset',
          type: 'number',
          default: '0',
          required: false,
          description: 'The location where the dash will begin. Ideal to animate the line.'
        },
        {
          name: 'dashRatio',
          type: 'number',
          default: '0',
          required: false,
          description: 'The ratio between the visible and non-visible sections of the dash.'
        },
        {
          name: 'attenuate',
          type: 'boolean',
          default: 'true',
          required: false,
          description: 'Set to false to make the line width constant regardless distance.'
        },
        {
          name: 'scaleDown',
          type: 'number',
          default: '0',
          required: false,
          description: "The amount to scale down the line when points are close together. 0 = don't scale."
        }
      ]
  }
---

Used in combination with [`<MeshLineGeometry>`](/docs/reference/extras/meshline-geometry) to create a line formed of a strip of billboarded triangles, based on <a href="https://github.com/spite/THREE.MeshLine" target="_blank">THREE.MeshLine</a>.

<Example path="extras/meshline-material/animated" />

## Usage

This component works by taking a line geometry from `<MeshLineGeometry>` and projecting and expanding the vertices in screen space.
Both `<MeshLineMaterial>` and `<MeshLineGeometry>` need belong to the same parent mesh.

### Example

```svelte
<script>
  const points = [new Vector3(-5, 1, 0), new Vector3(0, 1, 0), new Vector3(5, 1, 0)]
</script>

<T.Mesh>
  <MeshLineGeometry {points} />
  <MeshLineMaterial
    width={0.5}
    color="#fe3d00"
  />
</T.Mesh>
```

### Width and color

By default the line will be white and have a width of 1.
The `width` property will use world units and scale correctly with other objects in your scene.
If you would like the line to be a fixed size regardless of distance from the camera you can set the `attenuate` property to `false`.

### Opacity and dashes

Just like other materials in Three.js you need to set `transparent` to `true` for opacity to have any effect.
You must also set `transparent` to `true` for if you are using dashed lines.

You can use a combination of `dashArray`, `dashRatio` and `dashOffset` to create dashed lines.

<Tip type="tip">
  If you're rendering transparent lines, dashed lines or lines with an alpha map you can avoid
  issues where the line overlaps itself by setting <b>depthTest</b> to <b>false</b>.
</Tip>

### Alpha map

You can pass a texture to the `alphaMap` property to use as an alpha mask along the length of the line, where black is invisible and white is visible.
In the example below we load a paint brush texture with the `useTexture` hook.

<Example path="extras/meshline-material/alpha-map" />


================================================
File: apps/docs/src/content/reference/extras/misc.mdx
================================================
---
category: '@threlte/extras'
name: Misc
order: 8
isDivider: true
---


================================================
File: apps/docs/src/content/reference/extras/onReveal.mdx
================================================
---
order: 3.4
category: '@threlte/extras'
name: 'onReveal'
type: 'hook'
sourcePath: 'packages/extras/src/lib/suspense/onReveal.ts'
---

`onReveal` invokes a callback when the component is revealed (i.e., no
longer suspended in the context of a
[`<Suspense>`](/docs/reference/extras/suspense) boundary). It mimics Svelte's
lifecycle method `onMount`. If there is no `<Suspense>` component, the callback
will be executed with Svelte's `onMount` as the component will never suspend.

<Tip type="tip">
	`onReveal` is mimicking Svelte's `onMount` and can be used in
	its place for triggering animations, etc., within the boundaries of a
	`<Suspense>` component. If it's used outside of a `<Suspense>` component, it
	will behave just like Svelte's `onMount`.
	This means that
</Tip>

## Example

The following component loads a model with the hook `useGltf` and is potentially
wrapped in a `<Suspense>` boundary.

```svelte
<script>
  import { T } from '@threlte/core'
  import { onReveal, useGltf } from '@threlte/extras'

  const gltf = useGltf('model.gltf')

  onReveal(() => {
    console.log('The component has been revealed')
  })
</script>

{#await gltf then { scene }}
  <T is={scene}>
{/await}
```

You may also return a function from the callback to be executed when the
component is unmounted or the component is suspended again.

```ts
onReveal(() => {
  console.log('The component has been revealed')

  return () => {
    console.log('The component has been unmounted or suspended again')
  }
})
```


================================================
File: apps/docs/src/content/reference/extras/onSuspend.mdx
================================================
---
order: 3.4
category: '@threlte/extras'
name: 'onSuspend'
type: 'hook'
sourcePath: 'packages/extras/src/lib/suspense/onSuspend.ts'
---

`onSuspend` invokes a callback when the component becomes suspended
within the boundaries of a [`<Suspense>`](/docs/reference/extras/suspense) component. If there is no `<Suspense>`
component, the callback will never be executed, as the component will never
suspend.

## Example

The following component loads a model with the hook `useGltf` and is potentially
wrapped in a `<Suspense>` boundary.

```svelte
<script>
  import { T } from '@threlte/core'
  import { onSuspend, useGltf } from '@threlte/extras'

  const gltf = useGltf('model.gltf')

  onSuspend(() => {
    console.log('The component has been suspended')
  })
</script>

{#await gltf then { scene }}
  <T is={scene}>
{/await}
```

<Tip type="tip">
	`onSuspend` can be used to execute additional logic
	when a component becomes suspended within a `<Suspense>` boundary.
</Tip>


================================================
File: apps/docs/src/content/reference/extras/orbit-controls.mdx
================================================
---
order: 2.2
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/components/controls/OrbitControls/OrbitControls.svelte'
name: '<OrbitControls>'
type: 'component'
componentSignature:
  {
    extends:
      { type: 'OrbitControls', url: 'https://threejs.org/docs/#examples/controls/OrbitControls' }
  }
---

`<OrbitControls>` allow the camera to orbit around a target while ensuring a
fixed camera up vector. If the camera orbits over the "north" or "south" poles,
the camera experiences a "gimbal lock" that forces the scene to rotate until it
is rightside up. This type of camera control is commonly used for showing off 3D
models of products because it prevents them from ever appearing upside down. For
an alternative camera controller, see
[`<TrackballControls>`](/docs/reference/extras/trackball-controls).

The `<OrbitControls>` component must be a direct child of a camera component and
will mount itself to that camera.

<Example
  path="extras/orbit-controls"
  iframe
/>

This example shows off just a few of the configurable properties of
`<OrbitControls>`. To see all 30+ properties, consult the [Three.js
docs](https://threejs.org/docs/#examples/en/controls/OrbitControls).

## Usage

```svelte
<script>
  import { OrbitControls } from '@threlte/extras'
  import { T } from '@threlte/core'
</script>

<T.PerspectiveCamera
  makeDefault
  fov={50}
>
  <OrbitControls enableDamping />
</T.PerspectiveCamera>
```

`<OrbitControls>` is a light wrapper that will use its parent as the target
camera and the DOM element the renderer is rendering to as the DOM element to
listen to pointer events.


================================================
File: apps/docs/src/content/reference/extras/outlines.mdx
================================================
---
order: 5.8
category: '@threlte/extras'
name: <Outlines>
sourcePath: 'packages/extras/src/lib/components/Outlines/Outlines.svelte'
type: 'component'
componentSignature:
  {
    'props':
      [
        {
          name: 'color',
          type: 'THREE.ColorRepresentation',
          required: false,
          default: 'black',
          description: 'Outline color'
        },
        {
          name: 'screenspace',
          type: 'boolean',
          required: false,
          default: 'false',
          description: 'Line thickness is independent of zoom'
        },
        {
          name: 'opacity',
          type: 'boolean',
          required: false,
          default: '1',
          description: 'Outline transparency'
        },
        {
          name: 'thickness',
          type: 'number',
          required: false,
          default: '0.05',
          description: 'Outline thickness'
        },
        { name: 'toneMapped', type: 'boolean', required: false, default: 'true' },
        { name: 'angle', type: 'number', required: false, default: 'Math.PI' },
        { name: 'polygonOffset', type: 'boolean', required: false, default: 'false' },
        { name: 'polygonOffsetFactor', type: 'number', required: false, default: '0' },
        { name: 'renderOrder', type: 'number', required: false, default: '0' }
      ]
  }
---

A port of the drei [`<Outlines>`](https://github.com/pmndrs/drei?tab=readme-ov-file#outlines) component.

An ornamental component that extracts the geometry from its parent and displays an [inverted-hull outline](https://bnpr.gitbook.io/bnpr/outline/inverse-hull-method). Supported parents are `Mesh`, `SkinnedMesh` and `InstancedMesh`.

<Example path="extras/outlines" />

<small>
  Model: Battle Damaged Sci-fi Helmet by [theblueturtle\_](https://sketchfab.com/theblueturtle_)
</small>

### Example

```svelte
<script lang="ts">
  import { BoxGeometry, MeshBasicMaterial } from 'three'
  import { T } from '@threlte/core'
  import { Outlines } from '@threlte/extras'
</script>

<T.Mesh
  geometry={new BoxGeometry()}
  material={new MeshBasicMaterial()}
>
  <Outlines color="black" />
</T.Mesh>
```


================================================
File: apps/docs/src/content/reference/extras/peformance.mdx
================================================
---
category: '@threlte/extras'
name: Peformance
order: 7
isDivider: true
---


================================================
File: apps/docs/src/content/reference/extras/perf-monitor.mdx
================================================
---
order: 7.5
category: '@threlte/extras'
name: '<PerfMonitor>'
sourcePath: 'packages/extras/src/lib/components/PerfMonitor/PerfMonitor.svelte'
type: 'component'
componentSignature:
  {
    'props':
      [
        {
          name: 'domElement',
          type: 'HTMLElement',
          default: 'document.body',
          required: false,
          'description': 'Dom element to which stats block will be attached to.'
        },
        {
          name: 'logsPerSecond',
          type: 'number',
          default: '10',
          required: false,
          'description': 'Refresh rate of the logs.'
        },
        {
          name: 'showGraph',
          type: 'boolean',
          default: 'true',
          required: false,
          'description': 'Toggles cpu/gpu/fps graphs rendering.'
        },
        {
          name: 'memory',
          type: 'boolean',
          default: 'true',
          required: false,
          'description': 'Toggles memory info visiblity (geometries, textures, shaders)'
        },
        {
          name: 'enabled',
          type: 'boolean',
          default: 'true',
          required: false,
          'description': 'Toggles stats collection.'
        },
        {
          name: 'visible',
          type: 'boolean',
          default: 'true',
          required: false,
          'description': 'Toggles visibility of the monitor html element. Setting `false` does not stop collection of the stats.'
        },
        {
          name: 'actionToCallUI',
          type: 'string',
          default: ' ',
          required: false,
          'description': 'If set and given characters are typed in the the tab window, the three-perf dev gui will be shown. Disabled by default (empty string).'
        },
        {
          name: 'guiVisible',
          type: 'boolean',
          default: 'false',
          required: false,
          'description': 'Toggles Three-perf dev gui visiblity.'
        },
        {
          name: 'backgroundOpacity',
          type: 'number',
          default: '0.7',
          required: false,
          'description': 'Stats block background opacity level.'
        },
        {
          name: 'scale',
          type: 'number',
          default: '1',
          required: false,
          'description': 'Scale of the stats block html element.'
        },
        {
          name: 'anchorX',
          type: "'left' | 'right'",
          default: "'left'",
          required: false,
          'description': 'Stats html element horizontal anchor.'
        },
        {
          name: 'anchorY',
          type: "'top' | 'bottom'",
          default: "'top'",
          required: false,
          'description': 'Stats html element vertical anchor.'
        }
      ]
  }
---

Utility component for monitoring basic rendering statistics using [three-perf](https://github.com/TheoTheDev/three-perf).

<Example path="extras/perf-monitor" />

## Usage

Simply drop in the `<PerfMonitor>` component as a child of Threlte `<Canvas>`.
The component starts measuring before `mainStage` and ends after `renderStage`.
Learn more about tasks in threlte [here](/docs/learn/basics/scheduling-tasks)

```svelte
<Canvas>
  <PerfMonitor
    anchorX={'right'}
    logsPerSecond={30}
  />
  <Scene />
</Canvas>
```


================================================
File: apps/docs/src/content/reference/extras/portal-target.mdx
================================================
---
order: 8.2
category: '@threlte/extras'
name: '<PortalTarget>'
sourcePath: 'packages/extras/src/lib/components/portals/PortalTarget/PortalTarget.svelte'
type: 'component'
componentSignature: { props: [{ name: 'id', type: 'string', default: 'default', required: false }] }
---

A component that defines a target for a [`<Portal>`](/docs/reference/extras/portal) component.

<Tip type="tip">
  Although Portals are extremely helpful in certain situations, it can be hard to reason about them
  at times. It's recommended to use them sparingly.
</Tip>

## Example

```svelte title="ComponentA.svelte"
<!-- Create a portal with the id "trail" -->
<T.Object3D>
  <PortalTarget id="trail" />
</T.Object3D>
```

```svelte title="ComponentB.svelte"
<Portal id="trail">
  <!-- Use a portal with the id "trail -->
  <T.Mesh>
    <T.BoxGeometry />
    <T.MeshStandardMaterial color="red" />
  </T.Mesh>
</Portal>
```


================================================
File: apps/docs/src/content/reference/extras/portal.mdx
================================================
---
order: 8.1
category: '@threlte/extras'
name: '<Portal>'
sourcePath: 'packages/extras/src/lib/components/portals/Portal/Portal.svelte'
type: 'component'
componentSignature:
  {
    props:
      [
        {
          name: 'id',
          type: 'string',
          default: 'default',
          description: 'The id of the portal to render into.',
          required: false
        },
        {
          name: 'object',
          type:
            {
              name: 'THREE.Object3D',
              url: 'https://threejs.org/docs/index.html#api/en/core/Object3D'
            },
          required: false
        }
      ]
  }
---

A component that renders its children as children of an object that can exist **anywhere in your Threlte application**.
You can either provide an object that will be the parent of the children or use the prop `id` to render into a `<PortalTarget>`.

<Tip type="tip">
  Although Portals are extremely helpful in certain situations, it can be hard to reason about them
  at times. It's recommended to use them sparingly.
</Tip>

## Examples

### Render Helper Objects

Some objects such as the [`THREE.DirectionalLightHelper`](https://threejs.org/docs/index.html#api/en/helpers/DirectionalLightHelper)
need to be added to the scene instead of the light itself or another parent to be functional. We can use the `<Portal>` component for that.

<Example path="extras/portals/helper" />

### Render to a `<PortalTarget>`

You can define where a `<Portal>` should render its children by using the component [`<PortalTarget>`](/docs/reference/extras/portal-target).

<Example path="extras/portals/basic" />


================================================
File: apps/docs/src/content/reference/extras/positional-audio.mdx
================================================
---
order: 6.3
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/audio/PositionalAudio/PositionalAudio.svelte'
name: <PositionalAudio>
type: 'component'
componentSignature:
  {
    extends:
      {
        type: 'PositionalAudio',
        url: 'https://threejs.org/docs/index.html#api/en/audio/PositionalAudio'
      },
    props:
      [
        {
          name: 'src',
          type: 'string | AudioBuffer | HTMLMediaElement | AudioBufferSourceNode | MediaStream',
          required: true
        },
        {
          name: 'id',
          type: 'string',
          required: false,
          default: 'default',
          description: 'The id of the AudioListener this Audio will be attached to.'
        },
        { name: 'autoplay', type: 'boolean', required: false },
        { name: 'loop', type: 'boolean', required: false },
        { name: 'volume', type: 'number', required: false },
        { name: 'playbackRate', type: 'number', required: false },
        { name: 'detune', type: 'number', required: false },
        {
          name: 'directionalCone',
          type: '{ coneInnerAngle: number, coneOuterAngle: number, coneOuterGain: number }',
          required: false
        },
        { name: 'refDistance', type: 'number', required: false },
        { name: 'rolloffFactor', type: 'number', required: false },
        { name: 'distanceModel', type: 'string', required: false },
        { name: 'maxDistance', type: 'number', required: false }
      ],
    events:
      [
        { name: 'load', payload: 'AudioBuffer', description: 'Fired when the audio has loaded.' },
        {
          name: 'progress',
          payload: 'ProgressEvent<EventTarget>',
          description: 'Fired when the audio is loading.'
        },
        { name: 'error', payload: 'ErrorEvent', description: 'Fired when the audio fails to load.' }
      ],
    exports:
      [
        { name: play, type: '(delay?: number) => Promise<THREE.Audio>' },
        { name: pause, type: '() => THREE.Audio' },
        { name: stop, type: '() => THREE.Audio' }
      ]
  }
---

Creates a positional audio entity.
This uses the [Web Audio API](https://developer.mozilla.org/en-US/Web/API/Web_Audio_API).

<Tip type="warning">
You need to have an `<AudioListener>` component in your scene in order to use `<Audio>`and `<PositionalAudio>`components. The `<AudioListener>` component needs to be mounted *before* any `<Audio>` or `<PositionalAudio>` components:

```svelte
<T.PerspectiveCamera makeDefault>
  <AudioListener />
</T.PerspectiveCamera>

<PositionalAudio />
```

</Tip>

<Example path="extras/positional-audio" />

<small>Music: [legrisch](https://legrisch.com)</small>

### Example

```svelte
<script>
  import { T, Canvas } from '@threlte/core'
  import { AudioListener, PositionalAudio } from '@threlte/extras'
  import Car from './Car.svelte'
</script>

<Canvas>
  <T.PerspectiveCamera
    makeDefault
    position={[3, 3, 3]}
    lookAt={[0, 0, 0]}
  >
    <AudioListener />
  </T.PerspectiveCamera>

  <Car>
    <PositionalAudio
      autostart
      loop
      refDistance={10}
      volume={0.2}
      src={'/audio/car-noise.mp3'}
    />
  </Car>
</Canvas>
```


================================================
File: apps/docs/src/content/reference/extras/radial-gradient-texture.mdx
================================================
---
order: 5.10
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/components/GradientTexture/RadialGradientTexture.svelte'
name: '<RadialGradientTexture>'
type: 'component'
componentSignature:
  {
    extends:
      {
        type: 'CanvasTexture',
        url: 'https://threejs.org/docs/index.html#api/en/textures/CanvasTexture'
      },
    props:
      [
        {
          default: '1024',
          description: "width of the texture's canvas",
          name: 'width',
          required: false,
          type: 'number'
        },
        {
          default: '1024',
          description: "height of the texture's canvas",
          name: 'height',
          required: false,
          type: 'number'
        },
        {
          default: '0',
          description: 'inner radius of the gradient',
          name: 'innerRadius',
          required: false,
          type: 'number'
        },
        {
          default: 'auto',
          description: "outer radius of the gradient. if set to 'auto', becomes the radius of the circle that circumscribes the canvas",
          name: 'outerRadius',
          required: false,
          type: 'RadialGradientOuterRadius'
        },
        {
          default: "[{color: '#000000', offset: 0}, {color: '#ffffff', offset: 1}]",
          description: 'list of stops applied to the gradient. more info at https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createLinearGradient',
          name: 'stops',
          required: false,
          type: 'GradientStop[]'
        }
      ]
  }
---

A reactive radial gradient texture that attaches to the "map" property of its parent. The underlying texture uses an [OffscreenCanvas](https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas) and a [CanvasTexture](https://threejs.org/docs/index.html#api/en/textures/CanvasTexture) and is assigned the same [colorspace](https://threejs.org/docs/index.html#api/en/textures/Texture.colorSpace) as the renderer.

<Example path="extras/gradient-texture/radial" />

## Attaching the Texture

The texture is automatically attached to the `map` property of its parent. You can disable this behaviour by setting the `attach` prop to `false`. This may be useful if you want to create the texture but use it somewhere else.

```svelte
<script>
  let texture = $state()
</script>

<RadialGradientTexture
  attach={false}
  bind:ref={texture}
/>

<SomeComponent {texture} />
```

## Radius Props

The `innerRadius` and `outerRadius` props control the size of the gradient. The `innerRadius` prop should be less than the `outerRadius` prop but it is not enforced. If `outerRadius` is set to `'auto'` the `outerRadius` is effectively set to the radius of the circle that circumscribes the canvas. For example, if the canvas's width and height are **1024**, and `outerRadius` is set to `'auto'`, the radius that will be used is **sqrt(1024\*\*2 + 1024\*\*2)** or roughly **724**.

<Tip type="warning">
  It is also not enforced that `innerRadius` and `outerRadius` are both positive.
</Tip>

## Gradient Stops

`<RadialGradientTexture>` accepts a `stops` prop which is an array of color stops that define the gradient. A stop is defined by two things; an `offset` and a `color`. Gradient stops are identical to how you would use them with a 2D context, notably the `offset` should be a number between 0 and 1 inclusive. Stop colors can be any valid color representation in ThreeJS. Here are a couple examples of valid stops.

```svelte
<RadialGradientTexture
  stops={[
    { color: 'black', offset: 0 },
    { color: 'white', offset: 1 }
  ]}
/>

<RadialGradientTexture
  stops={[
    { color: '#00ffff', offset: 0 },
    { color: '#ff00ff', offset: 0.5 },
    { color: '#ffff00', offset: 1 }
  ]}
/>
```

You can even mix and match color representations

```svelte
<RadialGradientTexture
  stops={[
    { color: 'red', offset: 0 },
    { color: 0xff_00_00, offset: 0.25 },
    { color: 'rgb(255, 0, 0)', offset: 0.5 },
    { color: '#ff0000', offset: 0.75 },
    { color: new Color(new Color(new Color())).set(1, 0, 0), offset: 1 }
  ]}
/>
```

## Adjusting Scene Colors

If the colors in your scene do not match the color in your stops, you may need to adjust the tone mapping of the scene. `ToneMapping` constants are imported from the three library.

```svelte
<script>
  import { useThrelte } from '@threlte/core'
  import { LinearToneMapping } from 'three'

  const { toneMapping } = useThrelte()

  toneMapping.set(LinearToneMapping)
</script>
```


================================================
File: apps/docs/src/content/reference/extras/resize.mdx
================================================
---
order: 4.12
category: '@threlte/extras'
name: '<Resize>'
sourcePath: 'packages/extras/src/lib/components/Resize/Resize.svelte'
type: 'component'
componentSignature:
  {
    extends: { type: 'Group', url: 'https://threejs.org/docs/index.html#api/en/objects/Group' },
		exports: [
			{
				name: 'resize',
        type: '() => void',
        description: 'Manually trigger a resize.'
      }
    ],
    props:
      [
        {
          description: 'Specifies which axis to constrain. If not provided, the maximum axis is used',
          name: 'axis',
          required: false,
          type: "'x' | 'y' | 'z'",
          default: 'undefined'
        },
        {
          default: 'false',
          description: 'when true, will automatically resize when children or added or removed',
          name: 'auto',
          required: false,
          type: 'boolean'
        },
        {
          name: 'stage',
          type: 'Stage',
          default: 'useStage("<Resize>", { before: renderStage })',
          description: 'Bring your own stage to control when resizing occurs. If not provided, resizing will occur before the main render stage.',
          required: false
        },
        {
          default: 'undefined',
          description: 'a callback function to run whenever resizing is done',
          name: 'onresize',
          required: false,
          type: '() => void'
        },
        {
          description: 'Bring your own box to capture the bounding box.',
          name: 'box',
          required: false,
          default: 'new Box3()',
          type: 'THREE.Box3'
        },
        {
          description: 'If true, use precise bounding box calculation.',
          name: 'precise',
          required: false,
          default: 'undefined',
          type: 'boolean'
        }
      ]
  }
---

Scales up or down a group of objects by the maximum dimension of their bounding
box. Object proportions are preserved. This is particularly useful if you want
to "normalize" the dimensions of an object to be in the range 0 to 1.

<Example path="extras/resize/plugin" />

## Choosing the Axis

You can choose the axis by providing the `axis` prop, otherwise the maximum axis
is used.

```svelte
<Resize axis="x">
  <T.Mesh />
</Resize>
```

<Tip type="warning">
  If you use the `axis` prop, the dimensions will not be normalized to the range 0 to 1 unless the
  maximum axis is chosen.
</Tip>

## Bring Your Own Box

Use the `box` prop to provide your own Box3 instance. Doing so allows you to
capture the bounding box of the objects prior to any scaling

```svelte
<script>
  import { Box3 } from 'three'
  const box = new Box3()
</script>

<Resize {box}>
  <T.Mesh />
</Resize>

<T.Box3Helper args={[box]} />
```

## Normalizing Multiple Objects

If you have a bunch of source objects that are all different sizes, a useful
technique is to wrap each one in a `<Resize>`. Once they've all been normalized,
it may be easier to reason about their relative sizes.

<Example path="extras/resize/multiple-objects" />

In the example above, the fox model is much larger than the duck and flower models. It is so much larger that you may have to pull the camera back in order to see it. Using `<Resize>` scales each model so that each one fits inside a unit cube. From there, their relative sizes and positions may be easier to work with.

## Manually Triggering a Resize

### Using the Export

You can manually trigger a resize by calling the `resize` export.

```svelte title="Scene.svelte"
<script>
  import { Resize } from '@threlte/extras'

  let resizeRef = $state<ReturnType<typeof useResize>>()

  // ... later
  resizeRef.resize()
</script>

<Resize bind:this={resizeRef}>
  <!-- ... -->
</Resize>
```

### Using the Snippet Argument

You can also use the snippet argument to trigger a resize.

```svelte title="Scene.svelte"
<script>
  import { Resize } from '@threlte/extras'
</script>

<Resize>
  {#snippet children({ resize })}
    <T.Mesh oncreate={resize} />
  {/snippet}
</Resize>
```


================================================
File: apps/docs/src/content/reference/extras/rounded-box-geometry.mdx
================================================
---
order: 1.3
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/components/RoundedBoxGeometry/RoundedBoxGeometry.svelte'
name: <RoundedBoxGeometry>
type: 'component'
componentSignature:
  {
    props:
      [
        {
          name: 'args',
          type: '[number, number, number]',
          required: false,
          default: '[1, 1, 1]',
          description: 'Width, height, depth'
        },
        {
          name: 'radius',
          type: 'number',
          required: false,
          default: '0.05',
          description: 'Radius of the rounded corners.'
        },
        {
          name: 'smoothness',
          type: 'number',
          required: false,
          default: '4',
          description: 'The number of curve segments.'
        },
        {
          name: 'creaseAngle',
          type: 'number',
          required: false,
          default: '0.4',
          description: 'Smooth normals everywhere except faces that meet at an angle greater than the crease angle.'
        },
        {
          name: 'steps',
          type: 'number',
          required: false,
          default: '1',
          description: 'Number of points used for subdividing segments along the depth of the extruded spline.'
        }
      ]
  }
---

Creates a rounded box geometry with a Three.js ExtrudeGeometry.

### Example

```svelte
<script>
  import { T, Canvas } from '@threlte/core'
  import { RoundedBoxGeometry } from '@threlte/extras'
</script>

<Canvas>
  <T.PerspectiveCamera
    makeDefault
    position={[3, 3, 3]}
    lookAt={[0, 0, 0]}
  />

  <T.Mesh>
    <RoundedBoxGeometry />
    <T.MeshPhongMaterial color="hotpink" />
  </T.Mesh>
</Canvas>
```


================================================
File: apps/docs/src/content/reference/extras/sky.mdx
================================================
---
order: 4.18
category: '@threlte/extras'
name: '<Sky>'
sourcePath: 'packages/extras/src/lib/components/Sky/Sky.svelte'
type: 'component'
componentSignature:
  {
    props:
      [
        {
          name: 'scale',
          type: 'number',
          default: '1000',
          descriptions: 'The scale of the cuboid skybox along every axis',
          required: false
        },
        {
          name: 'turbidity',
          type: 'number',
          default: '10',
          descriptions: 'Relative clarity of the sky',
          required: false
        },
        {
          name: 'rayleigh',
          type: 'number',
          default: '3',
          descriptions: 'Amount of rayleigh scattering',
          required: false
        },
        {
          name: 'mieCoefficient',
          type: 'number',
          default: '0.005',
          descriptions: 'Mie scattering coefficient',
          required: false
        },
        {
          name: 'mieDirectionalG',
          type: 'number',
          default: '0.7',
          descriptions: 'Mie scattering directionality',
          required: false
        },
        {
          name: 'elevation',
          type: 'number',
          default: '2',
          descriptions: 'Elevation angle',
          required: false
        },
        {
          name: 'azimuth',
          type: 'number',
          default: '180',
          descriptions: 'Azimuthal angle',
          required: false
        },
        {
          name: 'setEnvironment',
          type: 'boolean',
          default: 'true',
          descriptions: 'Render the sky to the scene environment',
          required: false
        },
        {
          name: 'cubeMapSize',
          type: 'number',
          default: '128',
          descriptions: 'The size of the cube map',
          required: false
        },
        {
          name: 'webGLRenderTargetOptions',
          type: 'number',
          default: '{}',
          descriptions: 'The options for the WebGLCubeRenderTarget',
          required: false
        }
      ]
  }
---

This component adds a [Three.js `Sky` object](https://github.com/mrdoob/three.js/blob/dev/examples/jsm/objects/Sky.js) to the scene, renders that on-demand to a cubemap which is assigned to the default scene as the environment map.

<Example
  path="extras/sky"
  showFile="App.svelte"
/>

## Usage

```svelte
<script lang="ts">
  import { T, Canvas } from '@threlte/core'
  import { Sky } from '@threlte/extras'
</script>

<Canvas>
  <Sky elevation={0.5} />

  <T.PerspectiveCamera
    makeDefault
    position={[0, 3, 18]}
    fov={60}
    oncreate={(ref) => {
      ref.lookAt(0, 0, 0)
    }}
  />
</Canvas>
```

## Environment

By default, this component will render the sky to the scene environment. This can be disabled by setting the `setEnvironment` prop to `false`.

```svelte
<Sky setEnvironment={false} />
```

## Performance

The `<Sky>` component will only re-render the cubemap when the properties change.


================================================
File: apps/docs/src/content/reference/extras/soft-shadows.mdx
================================================
---
order: 4.19
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/components/SoftShadows/SoftShadows.svelte'
name: '<SoftShadows>'
type: 'component'
componentSignature:
  {
    props:
      [
        {
          name: 'size',
          type: 'number',
          default: '25',
          description: 'Size of the light source – the larger the softer the light',
          required: false
        },
        {
          name: 'focus',
          type: 'number',
          default: '0',
          description: 'Depth focus, use it to shift the focal point (where the shadow is the sharpest)',
          required: false
        },
        {
          name: 'samples',
          type: 'number',
          default: '10',
          description: 'Number of samples (more samples less noise but more expensive)',
          required: false
        }
      ]
  }
---

This component is a port of the component [`<SoftShadows>` from drei](https://github.com/pmndrs/drei/blob/master/src/core/softShadows.tsx).

It injects Percentage-Closer Soft Shadows (PCSS) into Three.js' shader chunk. Mounting and unmounting this component will lead to all shaders being be re-compiled, although it will only cause overhead if `<SoftShadows>` is mounted after the scene has already rendered, if it mounts with everything else in your scene shaders will compile naturally.

<Example path="extras/soft-shadows" />


================================================
File: apps/docs/src/content/reference/extras/staging.mdx
================================================
---
category: '@threlte/extras'
name: Staging
order: 4
isDivider: true
---


================================================
File: apps/docs/src/content/reference/extras/stars.mdx
================================================
---
order: 4.2
category: '@threlte/extras'
name: '<Stars>'
sourcePath: 'packages/extras/src/lib/components/Stars/Stars.svelte'
type: 'component'
componentSignature:
  {
    extends: { type: 'Points', url: 'https://threejs.org/docs/index.html#api/en/objects/Points' },
    props:
      [
        {
          name: 'radius',
          type: 'number',
          default: '50',
          required: false,
          description: 'Minimum distance of points to center'
        },
        {
          name: 'depth',
          type: 'number',
          default: '50',
          required: false,
          description: 'Radius + depth = maximum distance of points from center'
        },
        {
          name: 'count',
          type: 'number',
          default: '5000',
          required: false,
          description: 'Number of stars'
        },
        {
          name: 'factor',
          type: 'number',
          default: '6',
          required: false,
          description: 'Size of stars'
        },
        { name: 'saturation', type: 'number', default: '1.0', required: false },
        { name: 'lightness', type: 'number', default: '0.8', required: false },
        {
          name: 'fade',
          type: 'boolean',
          default: 'true',
          required: false,
          description: 'If stars should fade at the edges (shows blurry circles instead of squares)'
        },
        {
          name: 'speed',
          type: 'number',
          default: '0',
          required: false,
          description: 'Speed of blinking animation'
        },
        { name: 'opacity', type: 'number', default: '1.0', required: false }
      ]
  }
---

This component is a port of [drei's `<Stars>`
component](https://github.com/pmndrs/drei#stars), which adds a blinking shader-based starfield to your scene.

<Example path="extras/stars" />

## Examples

### Basic Example

```svelte title="Billboard.svelte"
<script lang="ts">
  import { Stars } from '@threlte/extras'
</script>

<Stars />
```


================================================
File: apps/docs/src/content/reference/extras/suspense.mdx
================================================
---
order: 3.3
category: '@threlte/extras'
name: '<Suspense>'
sourcePath: 'packages/extras/src/lib/suspense/Suspense.svelte'
type: 'component'
componentSignature:
  {
    props:
      [
        {
          name: 'final',
          type: 'boolean',
          default: 'false',
          description: 'If final is set to true, components cannot re-suspend the suspended state.',
          required: false
        }
      ],
    events:
      [
        {
          name: 'load',
          description: 'Fires when all child components wrapped in `suspend` have finished loading.',
          payload: 'void'
        },
        { name: 'suspend', description: 'Fires when a child component suspends.', payload: 'void' },
        {
          name: 'error',
          description: 'Fires when an error is thrown in a child component wrapped in `suspend`.',
          payload: 'Error'
        }
      ]
  }
---

The component `<Suspense>` allows you to orchestrate the loading of resources
inside (nested) child components. The implementation roughly follows a subset of the concept
established by the [React Suspense
API](https://react.dev/reference/react/Suspense) and has certain limitations.

The idea is to allow a parent component to make decisions based on the _loading
state_ of child components. The parent component can then decide to show a loading
indicator or a fallback component while the child component is loading.

<Example path="extras/suspense" />

## Usage

### In a child component

Let's have a look at a simple component that loads a model with the hook `useGltf`.

```svelte title="Model.svelte"
<script>
  import { T } from '@threlte/core'
  import { useGltf } from '@threlte/extras'

  const gltf = useGltf('model.gltf')
</script>

{#await gltf then { scene }}
  <T is={scene}>
{/await}
```

We can make that component _suspense-ready_ by using the hook `useSuspense` and passing the promise returned by `useGltf` to it.

```svelte {3,6}m {5}+ title="Model.svelte"
<script>
  import { T } from '@threlte/core'
  import { useGltf, useSuspense } from '@threlte/extras'

  const suspend = useSuspense()
  const gltf = suspend(useGltf('model.gltf'))
</script>

{#await gltf then { scene }}
  <T is={scene}>
{/await}
```

<Tip type="tip" title="Suspense-ready">
  *Suspense-ready* means it has the ability to hit a `<Suspense>` boundary if there is any. If there's no `<Suspense>` boundary, the component will behave as usual.
</Tip>

### In a parent component

Now we implement the component "Model.svelte" in a parent component:

```svelte title="Parent.svelte"
<script>
  import Model from './Model.svelte'
</script>

<Model />
```

To let the parent component decide what to do while the model component is loading, we wrap the child component in a `<Suspense>` component and show a fallback component while the child component is loading.

```svelte {3,4,7,8,10}+ title="Parent.svelte"
<script>
  import Model from './Model.svelte'
  import Fallback from './Fallback.svelte'
  import { Suspense } from '@threlte/extras'
</script>

<Suspense>
  <Model />

  {#snippet fallback()}
    <Fallback />
  {/snippet}
</Suspense>
```

<Tip type="tip" title="Error Boundary">
  In contrast to the React Suspense API, the `<Suspense>` component also acts as an
  error boundary for async requests	made in child components wrapped in `suspend`.

    The `"error"` snippet will be mounted as soon as an error is thrown in a child component
    wrapped in `suspend` and the snippet prop `errors` can be used to display a meaningful
    error message.

</Tip>

## UX considerations

The `<Suspense>` component is a great tool to improve the user experience of your application. However, it is important to consider the following points:

1. The `<Suspense>` component will only ever show one of the available slots at any time:

- The snippet `"error"` will be shown as soon as an error is thrown.
- The snippet `"fallback"` will be shown as long as a child component is suspended.
- The default slot will be shown as long as no child component is suspended and no error has been thrown.

2. Umounting a component that suspends rendering through awaiting a resource or throwing an error will discard its suspend state.
3. Directly citing the [React Suspense API](https://react.dev/reference/react/Suspense#revealing-nested-content-as-it-loads):
   > Don't put a Suspense boundary around every component. Suspense boundaries should not be more granular than the loading sequence that you want the user to experience.
4. A `<Suspense>` component can be re-suspended if a child component invokes `suspend` again. The property `final` on the component `<Suspense>` can be used to prevent this behavior.

## Limitations

1. It's important to keep in mind that while the contents of the default slot are not visible, they
   are still mounted and the component is otherwise fully functional. This means that any side
   effects (for instance `useTask` hooks) that are invoked in a _suspense-ready_ child component will be
   executed immediately.

```svelte title="Model.svelte"
<script>
  import { T, useTask } from '@threlte/core'
  import { useGltf, useSuspense } from '@threlte/extras'

  const suspend = useSuspense()
  const gltf = suspend(useGltf('model.gltf'))

  useTask(() => {
    // This will be executed immediately
  })
</script>

{#await gltf then { scene }}
  <T is={scene}>
{/await}
```

2. Also, in contrast to the React Suspense API, the `<Suspense>` component does not support showing a stale
   version of a child component while it is loading.


================================================
File: apps/docs/src/content/reference/extras/text-3d-geometry.mdx
================================================
---
order: 1.5
category: '@threlte/extras'
name: '<Text3DGeometry>'
sourcePath: 'packages/extras/src/lib/components/Text3DGeometry/Text3DGeometry.svelte'
type: 'component'
componentSignature:
  {
    'props':
      [
        {
          name: 'font',
          type: 'Font | string',
          required: true,
          description: 'Either a loaded font or a path to a font file.'
        },
        { name: 'text', type: 'string', required: true, description: 'The text to display.' },
        { name: 'size', type: 'number', required: false, default: '100' },
        { name: 'height', type: 'number', required: false, default: '50' },
        { name: 'curveSegments', type: 'number', required: false, default: '12' },
        { name: 'bevelEnabled', type: 'boolean', required: false, default: 'false' },
        { name: 'bevelThickness', type: 'number', required: false, default: '10' },
        { name: 'bevelSize', type: 'number', required: false, default: '8' },
        { name: 'bevelOffset', type: 'number', required: false, default: '0' },
        { name: 'bevelSegments', type: 'number', required: false, default: '3' },
        {
          name: 'smooth',
          type: 'number',
          required: false,
          default: '0',
          description: 'Smooth all edges where the angle between faces is less than value'
        },
        { name: 'depth', type: 'number', required: false, default: '1' },
        { name: 'extrudePath', type: 'Curve<Vector3>', required: false },
        { name: 'steps', type: 'number', required: false, default: '1' },
        { name: 'UVGenerator', type: 'UVGenerator', required: false }
      ]
  }
---

Render 3D text as a geometry using threejs's [TextGeometry](https://threejs.org/docs/index.html#examples/en/geometries/TextGeometry).

<Example path="extras/text-3d-geometry" />

## Examples

### Basic Example

```svelte title="Scene.svelte"
<script lang="ts">
  import { T } from '@threlte/core'
  import { Text3DGeometry } from '@threlte/extras'
</script>

<T.Mesh>
  <Text3DGeometry text={'Hello World'} />
  <T.MeshStandardMaterial />
</T.Mesh>
```

### Using a Custom Font

If no `font` property is provided, the default font "Helvetiker" will be used
and loaded from the CDN
[JSDeliver](https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_regular.typeface.json).

If you want to use a custom font, you can generate a font using
[typeface.js](https://gero3.github.io/facetype.js/). Provide the path to the
resulting JSON file using the prop `font`.

### Suspense-Ready

The component `<Text3DGeometry>` is _suspense-ready_. Using it in a
[`<Suspense>` boundary](/docs/reference/extras/suspense) will suspend
rendering until the provided font is loaded:

```svelte title="Scene.svelte"
<script lang="ts">
  import { T } from '@threlte/core'
  import { Text3DGeometry, Suspense } from '@threlte/extras'
  import Fallback from './Fallback.svelte'
</script>

<Suspense>
  <T.Mesh>
    <Text3DGeometry
      font={'path-to-your-font'}
      text={'Hello World'}
    />
    <T.MeshStandardMaterial />
  </T.Mesh>

  {#snippet fallback()}
    <Fallback />
  {/snippet}
</Suspense>
```

### Loading a Font Yourself

You can also load the font yourself and pass it to the component, like so:

```svelte title="Scene.svelte"
<script lang="ts">
  import { T, useLoader } from '@threlte/core'
  import { Text3DGeometry } from '@threlte/extras'
  import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js'

  let font = useLoader(FontLoader).load('path-to-your-font')
</script>

{#if $font}
  <T.Mesh>
    <Text3DGeometry
      font={$font}
      text={'Hello World'}
    />
    <T.MeshStandardMaterial />
  </T.Mesh>
{/await}
```

### Centering Text

You can center a text by using the [`<Align>` component](/docs/reference/extras/align) and calling the align slot prop when the text geometry is created.

```svelte title="Scene.svelte"
<Align>
  {#snippet children({ align })}
    <T.Mesh>
      <Text3DGeometry
        font={'path-to-your-font'}
        text={`Hello!`}
        oncreate={align}
      />
      <T.MeshStandardMaterial />
    </T.Mesh>
  {/snippet}
</Align>
```

### Smoothing Text

You can smooth the text by setting the `smooth` prop to a value above 0 to smooth all edges where the angle between faces is less than the `smooth` value.


================================================
File: apps/docs/src/content/reference/extras/text.mdx
================================================
---
order: 1.4
category: '@threlte/extras'
name: '<Text>'
sourcePath: 'packages/extras/src/lib/components/Text/Text.svelte'
type: 'component'
componentSignature:
  {
    extends: { type: 'Mesh', url: 'https://threejs.org/docs/index.html#api/en/objects/Mesh' },
    props:
      [
        { name: 'text', type: 'string', required: false },
        { name: 'anchorX', type: "number | 'left' | 'center' | 'right' | string", required: false },
        {
          name: 'anchorY',
          type: "number | 'top' | 'top-baseline' | 'middle' | 'bottom-baseline' | 'bottom' | string",
          required: false
        },
        { name: 'curveRadius', type: 'number', required: false },
        { name: 'direction', type: "'auto' | 'ltr' | 'rtl'", required: false },
        { name: 'font', type: 'string', required: false },
        {
          name: 'characters',
          type: 'string',
          required: false,
          description: 'The set of characters `<Text>` will preload while suspended.'
        },
        { name: 'fontSize', type: 'number', required: false },
        { name: 'letterSpacing', type: 'number', required: false },
        { name: 'lineHeight', type: 'number | string', required: false },
        { name: 'maxWidth', type: 'number', required: false },
        { name: 'overflowWrap', type: "'normal' | 'break-word' | 'normal'", required: false },
        { name: 'textAlign', type: "'left' | 'right' | 'center' | 'justify'", required: false },
        { name: 'textIndent', type: 'number', required: false },
        { name: 'whiteSpace', type: "'normal' | 'nowrap' | 'pre-wrap'", required: false },
        { name: 'material', type: 'Material | Material[]', required: false },
        { name: 'color', type: 'string | number | Color', required: false },
        { name: 'depthOffset', type: 'number', required: false },
        { name: 'clipRect', type: '[number, number, number, number]', required: false },
        { name: 'glyphGeometryDetail', type: 'number', required: false },
        { name: 'sdfGlyphSize', type: 'number', required: false },
        { name: 'outlineWidth', type: 'number | string', required: false },
        { name: 'outlineColor', type: 'ColorRepresentation', required: false },
        { name: 'outlineOpacity', type: 'number', required: false },
        { name: 'outlineBlur', type: 'number | string', required: false },
        { name: 'outlineOffsetX', type: 'number | string', required: false },
        { name: 'outlineOffsetY', type: 'number | string', required: false },
        { name: 'strokeWidth', type: 'number | string', required: false },
        { name: 'strokeColor', type: 'ColorRepresentation | Color', required: false },
        { name: 'strokeOpacity', type: 'number', required: false },
        { name: 'fillOpacity', type: 'number', required: false }
      ]
  }
---

The `<Text>` component uses [troika-three-text](https://github.com/protectwise/troika/tree/master/packages/troika-three-text) to render text.

<Example path="extras/text" />

### Example

```svelte
<script>
  import { Text } from '@threlte/extras'
  let value = ''
</script>

<input
  type="text"
  bind:value
/>
<Text text={value} />
```

`<Text>` is [suspense-ready](/docs/reference/extras/suspense) and will suspend while the font is loading. You can use the `characters` prop to preload a specific set of characters to prevent [FOUC](https://en.wikipedia.org/wiki/Flash_of_unstyled_content).

```svelte
<script>
  import { Text, Suspense } from '@threlte/extras'
</script>

<Suspense>
  <Text
    text="HELLO WORLD"
    characters="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  />

  {#snippet fallback()}
    <!-- show fallback content while font data is loading -->
  {/snippet}
</Suspense>
```


================================================
File: apps/docs/src/content/reference/extras/trackball-controls.mdx
================================================
---
order: 2.3
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/components/controls/TrackballControls/TrackballControls.svelte'
name: '<TrackballControls>'
type: 'component'
componentSignature:
  {
    extends:
      {
        type: 'TrackballControls',
        url: 'https://threejs.org/docs/#examples/controls/TrackballControls'
      }
  }
---

`<TrackballControls>` allow the camera to orbit freely around a target without causing gimbal lock. This type of camera controller is commonly used when the concepts of up and down are less important than the ability to carefully inspect a model from every angle. For an alternative camera controller, see [`<OrbitControls>`](/docs/reference/extras/orbit-controls).

The component `<TrackballControls>` must be a direct child of a camera component and will mount itself to that camera.
By default, damping is enabled. You can disable this by setting `staticMoving` to true.

<Tip type="info">
	Unlike `<OrbitControls>`, `<TrackballControls>` does not support `autoRotate`.
</Tip>

<Example
  path="extras/trackball-controls"
  iframe
/>

This example shows off just a few of the configurable properties of `<TrackballControls>`. To see all 15+ properties, consult the [Three.js docs](https://threejs.org/docs/#examples/en/controls/TrackballControls).

## Usage

```svelte
<script>
  import { TrackballControls } from '@threlte/extras'
  import { T } from '@threlte/core'
</script>

<T.PerspectiveCamera
  makeDefault
  fov={50}
>
  <TrackballControls />
</T.PerspectiveCamera>
```

`<TrackballControls>` is a light wrapper that will use its parent as the target camera and the DOM element
the renderer is rendering to as the DOM element to listen to. It will also by demand invalidate the frame loop.


================================================
File: apps/docs/src/content/reference/extras/transform-controls.mdx
================================================
---
order: 2.4
category: '@threlte/extras'
name: '<TransformControls>'
sourcePath: 'packages/extras/src/lib/components/controls/TransformControls/TransformControls.svelte'
type: 'component'
componentSignature:
  {
    pretext: 'The component <code>&lt;TransformControls&gt;</code> extends both <code>&lt;T.TransformControls&gt;</code> and <code>&lt;T.Group&gt;</code>. You may pass any property of either of these components to the component <code>&lt;TransformControls&gt;</code>.',
    props:
      [
        { name: 'autoPauseOrbitControls', type: 'boolean', required: false },
        { name: 'autoPauseTrackballControls', type: 'boolean', required: false },
        { name: 'object', type: 'THREE.Object3D', required: false }
      ],
    bindings:
      [
        { name: 'controls', type: 'THREE.TransformControls' },
        { name: 'group', type: 'THREE.Group' }
      ]
  }
---

This component can be used to transform objects in 3D space by adapting a similar interaction model of DCC tools like Blender. Unlike other controls, it is not intended to transform the scenes camera.

The component `<TransformControls>` needs to be the parent of the component to be transformed.

To accommodate `<OrbitControls>` or `<TrackballControls>` as well as a `<TransformControls>` component in the same scene, the `<TransformControls>` component is able automatically pause the currently active `<OrbitControls>` or `<TrackballControls>` component when the user is interacting with the `<TransformControls>` component. You can opt out of this behaviour by setting the property `autoPauseOrbitControls` or `autoPauseTrackballControls` to `false`.

<Example
  path="extras/transform-controls"
  iframe
/>

### Examples

```svelte title="Scene.svelte"
<script>
  import { T } from '@threlte/core'
  import { TransformControls } from '@threlte/extras'
  import { MeshStandardMaterial, BoxGeometry } from 'three'
</script>

<TransformControls>
  <T.Mesh
    geometry={new BoxGeometry()}
    material={new MeshStandardMaterial()}
  />
</TransformControls>
```

The `<TransformControls>` component can also be used to transform an object passed to it:

```svelte title="Scene.svelte"
<script>
  import { T } from '@threlte/core'
  import { TransformControls } from '@threlte/extras'
  import { MeshStandardMaterial, BoxGeometry } from 'three'
</script>

<T.Mesh
  geometry={new BoxGeometry()}
  material={new MeshStandardMaterial()}
>
  {#snippet children({ ref })}
    <TransformControls object={ref} />
  {/snippet}
</T.Mesh>

<TransformControls object={someObject} />
```


================================================
File: apps/docs/src/content/reference/extras/transitions.mdx
================================================
---
order: 4.4
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/transitions'
name: transitions
type: 'plugin'
---

<Tip
  type="experimental"
  title="Experimental"
>
  The plugin `transitions` uses Svelte internals. Changes to the runtime of Svelte may break this
  plugin. If you encounter any issues, please [open an issue on
  GitHub](https://github.com/threlte/threlte/issues). It's recommended to lock the version of Svelte
  to a specific version.
</Tip>

The plugin `transitions` enables [Svelte-like
transitions](https://svelte.dev/docs/svelte/transition)
on Threlte components.

```svelte
{#if visible}
  <T.Mesh transition={scale({ duration: 400 })} />
{/if}
```

<Example
  path="extras/transitions"
  showFile="Scene.svelte"
/>

## Usage

To use Threlte transitions, you need to inject the
[plugin](/docs/reference/core/plugins) first via invoking `transitions()`. All
child `<T>` components will then accept the transition properties `in`, `out` and
`transition`.

### `createTransition`

Threlte Transitions use regular [Svelte
transitions](https://svelte.dev/docs/svelte/transition) under the hood and
therefore provide a similar API. The function `createTransition` is used to
conveniently create a transition.

To create a transition, you need to provide a function which accepts a reference
to the object referenced by the `<T>` component and returns an object with the
following properties:

- `duration`: The duration of the transition in milliseconds.
- `tick`: A function that is called on every tick of the transition.
- `easing` (optional): The easing function to use.
- `delay` (optional): The delay of the transition in milliseconds.

```ts
import { isInstanceOf } from '@threlte/core'
import { createTransition } from '@threlte/extras'
import { cubicOut } from 'svelte/easing'

const fade = createTransition((ref) => {
  // Only apply the transition to materials
  if (!isInstanceOf(ref, 'Material')) return

  // Make the material transparent if it's not already
  if (!ref.transparent) {
    ref.transparent = true
    ref.needsUpdate = true
  }

  return {
    tick(t) {
      // t is [0, 1]
      ref.opacity = t
    },
    easing: cubicOut,
    duration: 400,
    delay: 100
  }
})
```

The transition `fade` can now be applied to all `<T>` components that
instantiate classes extending `THREE.Material` like `THREE.MeshBasicMaterial` or
`THREE.MeshStandardMaterial`:

```svelte
<T.MeshStandardMaterial transition={fade} />
```

### Transition Directions

Run a transition only when the component mounts:

```svelte
<T.MeshStandardMaterial in={fade} />
```

Run a transition only when the component unmounts:

```svelte
<T.MeshStandardMaterial out={fade} />
```

Run a transition when the component mounts or unmounts:

```svelte
<T.MeshStandardMaterial transition={fade} />
```

To react on different transition directions in the same transition, you can use
the `direction` parameter:

```ts
import { createTransition } from '@threlte/extras'

// direction is 'in', 'out' or 'both'
const fly = createTransition((ref, { direction }) => {
  // …
})
```

### Transition Parameters

To make reusing transitions throughout your application easier, make
`createTransition` the return value of a function that accepts parameters:

```ts
import { isInstanceOf } from '@threlte/core'
import { createTransition } from '@threlte/extras'

const scale = (duration: number) => {
  return createTransition((ref) => {
    // Only apply the transition to objects
    if (!isInstanceOf(ref, 'Object3D')) return
    return {
      tick(t) {
        ref.scale.setScalar(t)
      },
      duration
    }
  })
}
```

The transition can now be used like this:

```svelte
<T.Mesh transition={scale(400)} />
```

## Transition Events

Similar to Svelte transitions, Threlte transitions also emit events:

```svelte
{#if visible}
  <T.Mesh
    {geometry}
    {material}
    transition={fade}
    onintrostart={() => console.log('intro started')}
    onoutrostart={() => console.log('outro started')}
    onintroend={() => console.log('intro ended')}
    onoutroend={() => console.log('outro ended')}
  />
{/if}
```

## Global Transitions

Transitions are [local by
default](<(https://svelte.dev/docs/svelte/transition#Local-vs-global)>). Local
transitions only play when the block they belong to is created or destroyed, not
when parent blocks are created or destroyed. Threlte offers a function `global`
that marks a transition as global.

```svelte
<script>
  import { global } from '@threlte/extras'
</script>

{#if x}
  {#if y}
    <T.Mesh transition={global(scale(400))} />
  {/if}
{/if}
```

## TypeScript

### Prop Types

By default, the `transitions` plugin does not add any prop types to the `<T>`
component. You can however extend the types of the `<T>` component by defining
the `Threlte.UserProps` type in your ambient type definitions. In a typical
SvelteKit application, you can find these [in
`src/app.d.ts`](https://svelte.dev/docs/kit/types#app.d.ts). The transitions
plugin exports the `TransitionsProps` type which you can use as shown below:

```ts title="src/app.d.ts" {1}+ {4-6}+
import type { TransitionsProps } from '@threlte/extras'

declare global {
  namespace Threlte {
    interface UserProps extends TransitionsProps {}
  }
}

export {}
```

Now all relevant properties on `<T>` components will be type safe.

```svelte title="Scene.svelte"
<script>
  import { transitions } from '@threlte/extras'
  transitions()
</script>

<T.Mesh
  transition={scale(400)}
  onintrostart={() => console.log('intro started')}
/>
```


================================================
File: apps/docs/src/content/reference/extras/use-audio-listener.mdx
================================================
---
order: 6.4
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/audio/useAudioListener.ts'
name: useAudioListener
type: 'hook'
---

`useAudioListener` is a hook that either returns an existing `THREE.AudioListener` or allows
a callback to immediately operate on a `THREE.AudioListener` instance in a callback passed
to the hook.

### Retrieving an existing AudioListener

```ts
const { listener, context } = useAudioListener()
console.log(listener) // THREE.AudioListener
console.log(context) // AudioContext
```

### Using an AudioListener in a callback

```ts
const filter = useAudioListener(({ listener, context }) => {
  return context.createBiquadFilter()
})
```


================================================
File: apps/docs/src/content/reference/extras/use-cursor.mdx
================================================
---
order: 2.6
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/hooks/useCursor.ts'
name: useCursor
type: 'hook'
---

A hook that sets the css cursor property according to the hover state of a mesh, so that you can give the user visual feedback.

If a context is present, the cursor property will be set on the DOM element of the renderer, otherwise it will be set on the body element.

<Example path="extras/use-cursor" />

## Examples

### Simple Usage

Provide arguments to determine the cursor style. The defaults are`'pointer'` for `onPointerOver` and `'auto'` for `onPointerOut`. `useCursor` returns event handlers that you can use to set the hovering state:

```svelte
<script lang="ts">
  import { T } from '@threlte/core'
  import { useCursor } from '@threlte/extras'
  import { BoxGeometry, MeshBasicMaterial } from 'three'

  // Set the cursor to 'grab' if the pointer is
  // hovering over the mesh and to 'crosshair'
  // if the pointer is outside the mesh
  const { onPointerEnter, onPointerLeave } = useCursor('grab', 'crosshair')
</script>

<T.Mesh
  onpointerenter={onPointerEnter}
  geometry={new BoxGeometry()}
  material={new MeshBasicMaterial()}
/>
```

### Renaming Event Handlers

You can rename the event handlers to resolve naming conflicts. Additionally Svelte allows binding multiple event handlers to the same event:

```svelte
<script lang="ts">
  import { T } from '@threlte/core'
  import { useCursor } from '@threlte/extras'
  import { BoxGeometry, MeshBasicMaterial } from 'three'

  const { onPointerEnter: cursorEnter, onPointerLeave: cursorLeave } = useCursor()

  const onPointerEnter = () => {
    console.log('Pointer entered!')
  }
  const onPointerLeave = () => {
    console.log('Pointer left!')
  }
</script>

<T.Mesh
  onpointerenter={cursorEnter}
  onpointerenter={onPointerEnter}
  geometry={new BoxGeometry()}
  material={new MeshBasicMaterial()}
/>
```

### Store Usage

If you want to implement custom logic, you can use the returned svelte store to set the hovering state:

```svelte
<script lang="ts">
  import { T } from '@threlte/core'
  import { useCursor } from '@threlte/extras'
  import { BoxGeometry, MeshBasicMaterial } from 'three'

  const { hovering } = useCursor()
</script>

<T.Mesh
  onpointerenter={() => ($hovering = true)}
  onpointerleave={() => ($hovering = false)}
  geometry={new BoxGeometry()}
  material={new MeshBasicMaterial()}
/>
```

### Change the Cursor Style

Provide svelte stores to change the cursor style also while hovering:

```svelte
<script lang="ts">
  import { T } from '@threlte/core'
  import { useCursor } from '@threlte/extras'
  import { BoxGeometry, MeshBasicMaterial } from 'three'
  import { writable } from 'svelte/store'

  const onPointerOverCursor = writable('grab')

  const { onPointerEnter, onPointerLeave } = useCursor(onPointerOverCursor)

  // somewhere in your application …
  onPointerOverCursor.set('grabbing')
</script>

<T.Mesh
  onpointerenter={onPointerEnter}
  geometry={new BoxGeometry()}
  material={new MeshBasicMaterial()}
/>
```


================================================
File: apps/docs/src/content/reference/extras/use-fbo.mdx
================================================
---
order: 8.5
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/hooks/useFBO.ts'
name: useFBO
type: 'hook'
---

`useFBO` (Framebuffer Object) is a port of [drei's useFBO](https://github.com/pmndrs/drei#usefbo) that creates a [THREE.WebGLRenderTarget](https://threejs.org/docs/index.html#api/en/renderers/WebGLRenderTarget).

Framebuffer objects are useful when you want to render a scene to something other than the canvas. In ThreeJS, you do this by rendering the scene to a RenderTarget. The render target has a texture property that can be used for various things such as postprocessing effects or applying the texture to something in the scene.

<Example path="extras/use-fbo" />

## Options

`useFBO`'s options object extends `Three.RenderTargetOptions`. The additional properties are listed below.

### `size`

`size` is used to set the `width` and `height` of the render target.

If `size` is not provided, the target's size is set to the size of the canvas and it will follow any updates to the size.

```typescript
const { size } = useThrelte()

// use `size`'s width and height
const target = useFBO()

assert(target.width === size.current.width)
assert(target.height === size.current.height)
```

If `size` is provided, the `width` and `height` of the texture are taken from `size`.

```typescript
const size = { width: 512, height: 512 }

const target = useFBO({ size })
assert(target.width === size.width)
assert(target.height === size.height)
```

`width` and `height` both default to `1` if they are not found on the `size` object.

```typescript
const size = { width: 512 }

const target = useFBO({ size })
assert(target.width === size.width)
assert(target.height === 1)
```

```typescript
const size = { height: 512 }

const target = useFBO({ size })
assert(target.width === 1)
assert(target.height === size.height)
```

```typescript
const size = {}

const target = useFBO({ size })
assert(target.width === 1)
assert(target.height === 1)
```

### `depth`

`depth` is used to assign a [DepthTexture](https://threejs.org/docs/#api/en/textures/DepthTexture) to the `depthTexture` property of the render target. It can either be a boolean, "size" object, or `DepthTexture` instance. By default, `depth` is set to `false` and a depth texture is **not** created. When `depth` is used, the scene's depth is rendered to the `depthTexture` of the render target.

If `depth` is set to `true`, a depth texture is created and sized to match the size of the render target, _after_ an appropriate size has been given to the render target.

```typescript
const { size } = useThrelte()

const target = useFBO({ depth: true })

assert(target.depthTexture.image.width === size.current.width)
assert(target.depthTexture.image.height === size.current.height)
```

If `depth` is a depth texture instance, it is assigned to the `depthTexture` property of the returned render target.

```typescript
const depthTexture = new DepthTexture(512, 512)

const target = useFBO({ depth: depthTexture })

assert(target.depthTexture === depthTexture)
```

If `depth` is set to a "size" object, the depth texture size is set the `width` and `height` of the object.

```typescript
const depth = { width: 512, height: 512 }

const target = useFBO({ depth })

assert(target.depthTexture.image.width === depth.width)
assert(target.depthTexture.image.height === depth.height)
```

`width` and `height` default to `1` if they are not found on the `depth` object.

```typescript
const depth = { width: 512 }

const target = useFBO({ depth })

assert(target.depthTexture.image.width === depth.width)
assert(target.depthTexture.image.height === 1)
```

```typescript
const depth = { height: 512 }

const target = useFBO({ depth })

assert(target.depthTexture.image.width === 1)
assert(target.depthTexture.image.height === depth.height)
```

```typescript
const depth = {}

const target = useFBO({ depth })

assert(target.depthTexture.image.width === 1)
assert(target.depthTexture.image.height === 1)
```


================================================
File: apps/docs/src/content/reference/extras/use-gamepad.mdx
================================================
---
order: 2.7
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/hooks/useGamepad.ts'
name: useGamepad
type: 'hook'
---

A hook that will provide a reference to an object that maps [Gamepad](https://developer.mozilla.org/en-US/docs/Web/API/Gamepad)
values using the [Standard Gamepad layout](https://w3c.github.io/gamepad/#remapping) when connected.

```svelte
<script lang="ts">
  import { useGamepad } from '@threlte/extras'

  const gamepad = useGamepad()
</script>
```

More than one gamepad can be connected at any given time, so an optional `index` can be specified.

```svelte
<script lang="ts">
  import { useGamepad } from '@threlte/extras'

  const gamepad1 = useGamepad({ index: 0 })
  const gamepad2 = useGamepad({ index: 1 })
</script>
```

The raw unmapped [Gamepad](https://developer.mozilla.org/en-US/docs/Web/API/Gamepad) can be accessed via the `raw` prop.
This prop will be `null` unless a gamepad is connected.

```svelte
<script lang="ts">
  import { useTask } from '@threlte/core'
  import { useGamepad } from '@threlte/extras'

  const gamepad = useGamepad()

  useTask(() => {
    if (gamepad.raw) {
      // A gamepad is connected!
    }
  })
</script>
```

<Tip type="warning">
  Gamepad data is fetched as an immutable snapshot on every frame, so any variable that caches
  `gamepad.raw` will become stale on the next frame.
</Tip>

### Connection status

The `connected` property provides a `currentWritable` that will update when a gamepad connects.

```svelte
<script lang="ts">
  import { useGamepad } from '@threlte/extras'

  const gamepad = useGamepad()
  const { connected } = gamepad

  $: console.log(`A gamepad ${$connected ? 'connected' : 'disconnected'}!`)
</script>
```

### Standard gamepad layout

If the button and axis layout of the gamepad corresponds with the
[Standard Gamepad layout](https://w3c.github.io/gamepad/#remapping), the gamepad object may be used
to read and subscribe to input values.

Properties are given to more easily access button or joystick values.

```svelte
<script lang="ts">
  import { useTask } from '@threlte/core'
  import { useGamepad } from '@threlte/extras'

  const gamepad = useGamepad()

  useTask(() => {
    console.log(gamepad.leftStick.x, gamepad.leftStick.y)
    console.log(gamepad.leftBumper.value)
    console.log(gamepad.rightTrigger.value)
  })
</script>
```

Event listeners can also be attached to buttons or joysticks, or the gamepad itself.

```svelte
<script lang="ts">
  import { useTask } from '@threlte/core'
  import { useGamepad } from '@threlte/extras'

  const gamepad = useGamepad()

  const off = gamepad.leftTrigger.on('down', (event) => {
    console.log('The left trigger has just been pressed!')
    // Unsubscribe from the event after it has fired once.
    off()
  })

  gamepad.leftStick.on('change', (event) => {
    console.log(`Left stick moved: ${event.value.x}, ${event.value.y}`)
  })

  gamepad.on('press', (event) => {
    console.log(`A ${event.type} event on ${event.target} occurred: ${event.value}`)
  })

  const onPress = () => {
    console.log('A button was pressed!')
  }
  gamepad.on('press', onPress)
  // Some time later...
  gamepad.off('press', onPress)
</script>
```

### XR-Standard gamepad layout

To create a mapped object for a gamepad representing WebXR controller with the [`xr-standard` gamepad layout](https://immersive-web.github.io/webxr-gamepads-module/#xr-standard-heading),
set the `xr` flag to `true` when calling the hook:

```svelte
const leftGamepad = useGamepad({ xr: true, hand: 'left' })
const rightGamepad = useGamepad({ xr: true, hand: 'right' })

leftGamepad.trigger.on('change', (event) => console.log(event))
rightGamepad.trigger.on('change', (event) => console.log(event))
```

This will create a similar mapped object once XR controllers are connected.

### Button mapping and events

The `gamepad` object maps the 17 standard gamepad buttons and 4 axes to:

- The four right cluster buttons: `clusterBottom`, `clusterRight`, `clusterLeft`, `clusterTop`.
- The four top buttons: `leftBumper`, `rightBumper`, `leftTrigger`, `rightTrigger`.
- The center buttons: `select`, `start`, `center`.
- The joystick axes and buttons: `leftStickButton`, `leftStick`, `rightStickButton`, `rightStick`.
- The directional pad: `directionalTop`, `directionalBottom`, `directionalLeft`, `directionalRight`.

In a WebXR context, the following buttons and axes are mapped:

- Two cluster buttons per hand: `clusterBottom`, `clusterTop`.
- The `trigger` and `squeeze` buttons.
- The `touchpad` and `thumbstick` axes.

The available events for mapped buttons are the following:

- `change` will fire whenever the `value` of the stick or button changes. This is helpful for buttons or joysticks that can have continuous values.
- `press` will fire if a button is pressed.
- `down` will fire when a button press begins.
- `up` will fire when a button press ends.
- `touch` is supported by some gamepads, and will fire if a small amount of pressure on a button is detected.
- `touchstart` will fire when a touch begins,
- and `touchend` will fire when a touch ends.


================================================
File: apps/docs/src/content/reference/extras/use-gltf-animations.mdx
================================================
---
order: 3.2
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/hooks/useGltfAnimations.ts'
name: useGltfAnimations
type: 'hook'
---

A convenience hook to use gltf animations loaded by a [\<GLTF>](/docs/reference/extras/gltf) component or by the [`useGltf`](/docs/reference/extras/use-gltf) hook.

<Example path="extras/use-gltf-animations" />

<small>
  Model: [Littlest Tokyo](https://artstation.com/artwork/1AGwX) by [Glen
  Fox](https://artstation.com/glenatron), CC Attribution.
</small>

## Examples

### With the `<GLTF>` component

Without any arguments, `useGltfAnimations` returns a store which can be bound to the `<GLTF>` component.

```svelte
<script lang="ts">
  import { GLTF, useGltfAnimations } from '@threlte/extras'

  const { gltf, actions, mixer } = useGltfAnimations<'All Animations'>()
  mixer.timeScale = 0.5

  export const triggerAnimation = () => {
    $actions['All Animations']?.play()
  }
</script>

<GLTF
  url="/path/to/model.glb"
  bind:gltf={$gltf}
/>
```

### With the `useGltf` hook

For cases where you want to reuse parts of the GLTF such as materials, nodes, or the embedded camera, `useGltfAnimations` accepts a writable store as its first argument. [`useGltf`](/docs/reference/extras/use-gltf) returns a store that can be directly passed to `useGltfAnimations`.

```svelte
<script lang="ts">
  import { T } from '@threlte/core'
  import { useGltfAnimations, useGltf } from '@threlte/extras'

  const gltf = useGltf('/path/to/model.glb')
  const { actions, mixer } = useGltfAnimations<'All Animations'>(gltf)

  $effect(() => {
    $actions['All Animations']?.play()
  })
</script>

{#await gltf then { scene }}
  <T is={scene} />
{/await}
```

## Applying Animations to a Different Root

`useGltfAnimations`'s second optional argument allows you to apply the animations to a root other than the GLTF scene.

```svelte
<script>
  import { useGltfAnimations, useGltf } from '@threlte/extras'
  import { Group } from 'three'

  const gltf = useGltf('/path/to/model.glb')

  const group = new Group()

  const { root } = useGltfAnimations(gltf, group)
  // $root === group
</script>

{#await gltf then { scene }}
  <T is={group}>
    <T is={scene} />
  </T>
{/await}
```

You can also set the root store without passing in the second argument

```svelte
<script>
  import { useGltfAnimations, useGltf } from '@threlte/extras'
  import { Group } from 'three'

  const gltf = useGltf('/path/to/model.glb')

  const { root } = useGltfAnimations(gltf)
</script>

{#await gltf then { scene }}
  <T.Group bind:ref={$root}>
    <T is={scene} />
  </T.Group>
{/await}
```


================================================
File: apps/docs/src/content/reference/extras/use-gltf.mdx
================================================
---
order: 3.1
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/hooks/useGltf.ts'
name: useGltf
type: 'hook'
---

A Hook to load glTF files and use separate object nodes and materials of it.

Use the component [`<GLTF>`](/docs/reference/extras/gltf) if you want to use a model in its entirety.

<Example path="extras/use-gltf" />

<small>
  Model: Battle Damaged Sci-fi Helmet by [theblueturtle\_](https://sketchfab.com/theblueturtle_)
</small>

## Examples

### Basic Example

`gltf` is a store which gets populated as soon as the model loaded.

```svelte
<script lang="ts">
  import { T } from '@threlte/core'
  import { useGltf } from '@threlte/extras'
  import { MeshBasicMaterial } from 'three'

  const gltf = useGltf('/path/to/model.glb')
</script>

<!-- Use an object node entirely -->
{#if $gltf}
  <T is={$gltf.nodes['node-name']} />
{/if}

<!-- or only the geometry -->
{#if $gltf}
  <T.Mesh
    geometry={$gltf.nodes['node-name'].geometry}
    material={new MeshBasicMaterial()}
  />
{/if}
```

### DRACO decoding

Use the `useDraco` hook for compressed glTF files, defaults to CDN loaded DRACO binaries.

```ts
import { useGltf, useDraco } from '@threlte/extras'

const dracoLoader = useDraco()
const gltf = useGltf('/path/to/model.glb', {
  dracoLoader
})
```

You can set a custom path to DRACO decoder binaries.

```ts
import { useGltf, useDraco } from '@threlte/extras'

const dracoLoader = useDraco('/custom/draco/decoders/path')
const gltf = useGltf('/path/to/model.glb', {
  dracoLoader
})
```

You can also provide your own instance of `DRACOLoader`.

This is especially useful when you can confidently dispose of the loader, as the default loader is indefinitely cached.

```ts
import { useGltf } from '@threlte/extras'

const dracoLoader = new DRACOLoader().setDecoderPath(path)
const gltf = useGltf('/path/to/model.glb', {
  dracoLoader
})
```

### Meshopt decoding

Use the `useMeshopt` hook for compressed glTF files, defaults to Three's included decoder.

You can also provide your own instance of MeshoptDecoder.

```ts
import { useGltf, useMeshopt } from '@threlte/extras'

const meshoptDecoder = useMeshopt()
const gltf = useGltf('/path/to/model.glb', {
  meshoptDecoder
})
```

### KTX2Loader

Use the `useKtx2` hook for [KTX 2 texture support](https://threejs.org/docs/#examples/en/loaders/KTX2Loader).

This hook requires a `transcoder` path.

```ts
import { useGltf, useKtx2 } from '@threlte/extras'

const ktx2Loader = useKtx2('path/to/transcoder/')
const gltf = useGltf('/path/to/model.glb', {
  ktx2Loader
})
```

You can also provide your own instance of `KTX2Loader`.

This is especially useful when you can confidently dispose of the loader, as the default loader is indefinitely cached.

```ts
import { useThrelte } from '@threlte/core'
import { useGltf } from '@threlte/extras'

const { renderer } = useThrelte()

const ktx2Loader = new KTX2Loader()
ktx2Loader.setTranscoderPath('path/to/transcoder/')
ktx2Loader.detectSupport(renderer)

const gltf = useGltf('/path/to/model.glb', {
  ktx2Loader
})
```

### Nodes and Materials

The hook provides a map of all objects and materials in the loaded glTF.

```svelte
<script lang="ts">
  import { useGltf } from '@threlte/extras'

  const gltf = useGltf('/path/to/model.glb')

  let nodes = $derived($gltf?.nodes)
  let materials = $derived($gltf?.materials)
</script>
```

Provide types and you will gain autocompletion for these objects and materials.

```svelte
<script lang="ts">
  import { useGltf } from '@threlte/extras'

  const gltf = useGltf<{
    nodes: {
      MeshA: THREE.Mesh
      MeshB: THREE.Mesh
      Object3DA: THREE.Object3D
    }
    materials: {
      MaterialA: THREE.MeshStandardMaterial
      MaterialB: THREE.MeshBasicMaterial
    }
  }>('/path/to/model.glb')

  $effect(() => {
    if ($gltf) {
      const objectA = $gltf.nodes['MeshA'] // -> THREE.Mesh
      const materialA = $gltf.materials['MaterialA'] // -> THREE.MeshStandardMaterial
    }
  })
</script>
```

<Tip
  type="tip"
  title="How to get the types?"
>
  On the [loading-assets](/docs/learn/basics/loading-assets) page, Threlte provides the
  `@threlte/gltf` CLI tool that can be used to generate a reusable Svelte component for your gltf as
  well as its types.
</Tip>

Types can be separated into a typescript file and imported like so if you feel the need.

```ts title=SomeGltf.ts
export type SomeGltf = {
  nodes: {
    Suzanne: THREE.Mesh
  }
  materials: {}
}
```

```svelte title=MyComponent.svelte
<script lang="ts">
  import { useGltf } from '@threlte/extras'
  import type { SomeGltf } from './SomeGltf.ts'

  useGltf<SomeGltf>('model.glb')
</script>
```


================================================
File: apps/docs/src/content/reference/extras/use-progress.mdx
================================================
---
order: 3.2
category: '@threlte/extras'
name: useProgress
sourcePath: 'packages/extras/src/lib/hooks/useProgress.ts'
type: 'hook'
---

Convenience hook that wraps `THREE.DefaultLoadingManager`.

<Example path="extras/use-progress" />

<small>
  Model: Battle Damaged Sci-fi Helmet by [theblueturtle\_](https://sketchfab.com/theblueturtle_)
</small>

### Examples

#### Basic Example

You can use and place this hook anywhere. Typically you would use this hook outside of your `<Canvas>` component to show a loading indicator in your DOM.

```svelte
<script lang="ts">
  // `useProgress` returns readable stores
  const {
    active, // Readable<boolean> – if the DefaultLoadingManager is active
    item, // Readable<string | undefined> – the currently loading item
    loaded, // Readable<number> - amount of items loaded
    total, // Readable<number> - total amount of items to load
    errors, // Readable<string[]> - all error messages
    progress, // Readable<number> - normalized (0-1) loading progress
    finishedOnce // Readable<boolean> – whether a progress of 1 has been achieved ever.
  } = useProgress()
</script>
```


================================================
File: apps/docs/src/content/reference/extras/use-suspense.mdx
================================================
---
order: 3.4
category: '@threlte/extras'
name: 'useSuspense'
type: 'hook'
sourcePath: 'packages/extras/src/lib/suspense/useSuspense.ts'
---

The hook `useSuspense` is used to mark a resource as being used in a
`<Suspense>` boundary or to get the `suspended`-state of the closest
`<Suspense>` boundary. For a complete implementation example, have a look at the
[`<Suspense>` component](/docs/reference/extras/suspense).

## Usage

### Suspend an Async Resource

The hook returns a function that allows you to mark a resource as being used in
a `<Suspense>` boundary. To suspend the closest `<Suspense>` boundary, call the
function returned by `useSuspense()` and pass a promise as the first argument.
Because [`useLoader().load()`](/docs/reference/core/use-loader) returns an
[`AsyncWritable`](/docs/reference/core/utilities#asyncwritable), the result of
`useLoader().load()` can be passed directly to the function returned by
`useSuspense()`.

```svelte
<script>
  const suspend = useSuspense()

  const promise = suspend(useTexture('/texture.png'))
</script>
```

### Get Suspended State

The hook can be used to get the `suspended`-state of the closest `<Suspense>` boundary.

```svelte
<script>
  const { suspended } = useSuspense()

  $inspect($suspended)
</script>
```


================================================
File: apps/docs/src/content/reference/extras/use-texture.mdx
================================================
---
order: 3.2
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/hooks/useTexture.ts'
name: useTexture
type: 'hook'
---

`useTexture` is a convenience hook wrapping
[`useLoader`](/docs/reference/core/hooks#useloader) that returns an
[`AsyncWritable`](/docs/reference/core/utilities#asyncwritable) store that is eventually populated
with a `THREE.Texture`. The texture is automatically assigned the
[`colorSpace`](https://threejs.org/docs/#api/en/textures/Texture.colorSpace)
that the renderer uses.

## Usage

### Basic Example

```svelte
<script>
  import { T } from '@threlte/core'
  import { useTexture } from '@threlte/extras'

  const texture = useTexture('texture.png')

  texture.then(() => {
    console.log('texture has loaded')
  })

  $inspect($texture) // eventually a Three.Texture
</script>

{#await texture then map}
  <T.Mesh>
    <T.SphereGeometry />
    <T.MeshBasicMaterial {map} />
  </T.Mesh>
{/await}
```

### Transforming the Texture

You can pass a `transform` function to transform the texture **once** its
loaded.

```svelte
<script>
  import { RepeatWrapping } from 'three'
  import { T } from '@threlte/core'
  import { useTexture } from '@threlte/extras'

  const texture = useTexture('texture.png', {
    transform: (texture) => {
      texture.wrapS = RepeatWrapping
      texture.wrapT = RepeatWrapping
      texture.repeat.set(4, 4)
      return texture
    }
  })
</script>

{#await texture then map}
  <T.Mesh>
    <T.SphereGeometry />
    <T.MeshBasicMaterial {map} />
  </T.Mesh>
{/await}
```

<Tip type="warning">
  Be aware that the transformed result will be cached for subsequent calls to `useTexture` with the
  same URL.
</Tip>


================================================
File: apps/docs/src/content/reference/extras/use-threlte-audio.mdx
================================================
---
order: 6.5
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/audio/useThrelteAudio.ts'
name: useThrelteAudio
type: 'hook'
---

When invoking the hook `useThrelteAudio` and there's no Threlte audio context yet, it will be
created and returned, otherwise, the existing audio context will be returned. The components
[`<AudioListener>`](/docs/reference/extras/audio-listener), [`<Audio>`](/docs/reference/extras/audio)
and [`<PositionalAudio>`](/docs/reference/extras/positional-audio) will create an audio context
if mounted.

```ts
const {
  audioListeners, // Map<string, AudioListener>
  getAudioListener, // (id?: string) => AudioListener | undefined
  addAudioListener, // (listener: AudioListener, id?: string) => void
  removeAudioListener // (id?: string) => void
} = useThrelteAudio()
```


================================================
File: apps/docs/src/content/reference/extras/use-viewport.mdx
================================================
---
order: 4.3
category: '@threlte/extras'
name: useViewport
sourcePath: 'packages/extras/src/lib/hooks/useViewport.ts'
type: 'hook'
---

The `useViewport` hook returns a `viewport` which provides information related to the screen.

<Example path="extras/use-viewport" />

The `width` and `height` properties provide the screen size in Three.js units. For example, the following mesh would fill the entire screen:

```svelte
<script>
  import { T } from '@threlte/core'
  import { useViewport } from '@threlte/extras'

  const viewport = useViewport() // currentWritable<Viewport>
</script>

<T.Mesh scale={[$viewport.width, $viewport.height, 1]}>
  <T.PlaneGeometry />
  <T.MeshStandardMaterial />
</T.Mesh>
```

The `factor` property is the canvas width divided by the viewport width.

The `distance` property is the camera distance from an origin point. The default origin is `0,0,0`, but
a custom origin can be passed into the hook.

```ts
const viewport = useViewport([1, 0, 1])
```


================================================
File: apps/docs/src/content/reference/extras/view.mdx
================================================
---
order: 4.31
category: '@threlte/extras'
name: '<View>'
sourcePath: 'packages/extras/src/lib/components/View/View.svelte'
type: 'component'
componentSignature:
  {
    props:
      [
        {
          name: 'dom',
          type: 'HTMLElement',
          default: '',
          description: 'The target DOM to scissor-cut and attach events. Does nothing if none given.',
          required: false
        }
      ]
  }
---

This is a port of [drei's `<View/>`
component](https://drei.docs.pmnd.rs/portals/view). It is used to display
multiple scenes using only one canvas and one renderer. Our implemenation
re-uses parts of the main context but creates new camera, scene, parent, DOM,
cache and user contexts. This ensures you can use Threlte's other components as
per normal.

The following example is equivalent to three.js's [multiple elements
example](https://threejs.org/examples/#webgl_multiple_elements).

<Example path="extras/view" />

Under the hood, this component uses the renderer's [scissor-cut
method](https://threejs.org/docs/index.html#api/en/renderers/WebGLRenderer.setScissor).
[Three.js has documentation](https://threejs.org/manual/#en/multiple-scenes) for
when using scissor-cuts as the styling of your canvas has different effects on
the renderering. You access the `canvas` to switch between the options via the
`useThrelte` hook.


================================================
File: apps/docs/src/content/reference/extras/virtual-environment.mdx
================================================
---
order: 4.143
category: '@threlte/extras'
sourcePath: 'packages/extras/src/lib/components/environment/VirtualEnvironment/VirtualEnvironment.svelte'
name: <VirtualEnvironment>
type: 'component'
componentSignature:
  {
    exports:
      [
        { name: 'restart', type: '() => void', description: 'Restarts the update task' },
        {
          name: 'update',
          type: '() => void',
          description: 'Causes the cube camera to render to its render target'
        }
      ],
    props:
      [
        {
          default: '0.1',
          description: 'The near plane of the cube camera',
          name: 'near',
          required: false,
          type: 'number'
        },
        {
          default: '1000',
          description: 'The far plane of the cube camera',
          name: 'far',
          required: false,
          type: 'number'
        },
        {
          default: 'Infinity',
          description: 'Determines how many frames the internal task will run for',
          name: 'frames',
          required: false,
          type: 'number'
        },
        {
          description: 'Callback that is ran when the internal update task is started',
          name: 'onupdatestart',
          required: false,
          type: '() => void'
        },
        {
          description: 'Callback that is ran when the internal update task is stopped',
          name: 'onupdatestop',
          required: false,
          type: '() => void'
        },
        {
          default: '256',
          description: 'The width and height of the cube cameras render target',
          name: 'resolution',
          required: false,
          type: 'number'
        },
        {
          default: 'false',
          description: 'Whether to set `scene.background` to the environment texture',
          name: 'isBackground',
          required: false,
          type: 'boolean'
        },
        {
          default: 'useThrelte().scene',
          description: 'The scene that will have its environment and/or background set',
          name: 'scene',
          required: false,
          type: 'THREE.Scene'
        },
        {
          default: 'false',
          description: 'Whether to render the virtual environment into the scene',
          name: 'visible',
          required: false,
          type: 'boolean'
        }
      ]
  }
---

<Example path="extras/virtual-environment/basic" />

`<VirtualEnvironment>` allows you to create dynamic environment maps which can
be used to light your scene and adjust reflections on your scene's objects.

It uses a cube camera to create a cubemap of its contents and applies that
cubemap texture to the scene's environment. `<VirtualEnvironment>` internally
creates a new scene to render the virtual environment into. The contents of
`<VirtualEnvironment>` may be mounted and made visible by setting the `visible`
prop to `true`.

## Controlling Updates

By default, the cube camera updates and renders to its render target every
frame. The `frames` prop is used to control the amount of updates that occur. If
your virtual scene is static, you may only need the cube camera to update once.
You can achieve this by settings `frames` to `1`:

```svelte
<VirtualEnvironment frames={1} />
```

This will cause the cube camera to update once and then stop its update task. If
you ever need to restart the task, a `restart` function is available as a
component export and through the `children` snippet.

```svelte title="As-A-Component-Export"
<script>
  let virtualEnvironment = $state()

  $effect(() => {
    // yourDependencyHere
    virtualEnvironment?.restart()
  })
</script>

<VirtualEnvironment
  frames={1}
  bind:this={virtualEnvironment}
/>
```

```svelte title="Through-Children-Snippet"
<script>
  let meshInScene = $state(true)
</script>

<VirtualEnvironment
  frames={1}
  bind:this={virtualEnvironment}
>
  {#snippet children({ restart })}
    {#if meshInScene}
      <T.Mesh>
        <T.PlaneGeometry />
      </T.Mesh>
    {/if}
  {/snippet}
</VirtualEnvironment>
```

### Manual Updates

For cases where you want full control over when the render target is updated,
use the `update` function available as a component export and through the
`children` snippet.

<Tip type="warning">
  If you use the `update` function, be sure to set `frames` to `0` to prevent the internal update
  task from starting automatically.
</Tip>

#### As a Component Export

```svelte title="Scene.svelte"
<script>
  let virtualEnvironment = $state()
  $effect(() => {
    // …
    virtualEnvironment?.update()
  })
</script>

<VirtualEnvironment
  frames={0}
  bind:this={virtualEnvironment}
>
  <!-- Your scene contents here -->
</VirtualEnvironment>
```

#### Through Children Snippet

```svelte title="Scene.svelte"
<VirtualEnvironment frames={0}>
  {#snippet children({ update })}
    <T.Mesh
      oncreate={() => {
        update()
      }}
    >
      <T.PlaneGeometry />
    </T.Mesh>
  {/snippet}
</VirtualEnvironment>
```

The example below is the same as the one above but it only updates the cube
camera's render target when the light formers are updated instead of every
frame.

<Example path="extras/virtual-environment/manual-updates" />

## Mixing Virtual and Real Environments

You can also mix `<VirtualEnvironment>` with `<Environment>` or
`<CubeEnvironment>` to create a mix of "real" and virtual environments.

```svelte title="Scene.svelte"
<VirtualEnvironment>
  <Environment
    url="…"
    isBackground
  />

  <T.Mesh>
    <T.PlaneGeometry />
  </T.Mesh>
</VirtualEnvironment>
```

<Example path="extras/virtual-environment/mix" />


================================================
File: apps/docs/src/content/reference/extras/visual-effects.mdx
================================================
---
category: '@threlte/extras'
name: Visual Effects
order: 5
isDivider: true
---


================================================
File: apps/docs/src/content/reference/flex/box.mdx
================================================
---
category: '@threlte/flex'
name: '<Box>'
order: 1
sourcePath: 'packages/flex/src/lib/Box'
type: 'component'
componentSignature:
  {
    props:
      [
        { name: order, type: 'number', required: false },
        {
          name: 'class',
          type: 'string',
          required: false,
          description: 'declared classes will be resolved by a ClassParser declared on <Flex>'
        },
        {
          name: 'alignItems',
          type: '"Auto" | "FlexStart" | "Center" | "FlexEnd" | "Stretch" | "Baseline" | "SpaceBetween" | "SpaceAround"',
          required: false
        },
        {
          name: 'alignSelf',
          type: '"Auto" | "FlexStart" | "Center" | "FlexEnd" | "Stretch" | "Baseline" | "SpaceBetween" | "SpaceAround"',
          required: false
        },
        {
          name: 'alignContent',
          type: '"Auto" | "FlexStart" | "Center" | "FlexEnd" | "Stretch" | "Baseline" | "SpaceBetween" | "SpaceAround"',
          required: false
        },
        {
          name: 'justifyContent',
          type: '"FlexStart" | "Center" | "FlexEnd" | "SpaceBetween" | "SpaceAround" | "SpaceEvenly"',
          required: false
        },
        {
          name: 'flexDirection',
          type: '"Column" | "ColumnReverse" | "Row" | "RowReverse"',
          required: false
        },
        { name: 'flexWrap', type: '"NoWrap" | "Wrap" | "WrapReverse"', required: false },
        { name: 'flex', type: 'number', required: false },
        { name: 'flexBasis', type: 'number | "auto" | `${number}%`', required: false },
        { name: 'flexGrow', type: 'number', required: false },
        { name: 'flexShrink', type: 'number', required: false },
        { name: 'height', type: 'number | "auto" | `${number}%`', required: false },
        { name: 'width', type: 'number | "auto" | `${number}%`', required: false },
        { name: 'maxHeight', type: 'number | `${number}%`', required: false },
        { name: 'maxWidth', type: 'number | `${number}%`', required: false },
        { name: 'minHeight', type: 'number | `${number}%`', required: false },
        { name: 'minWidth', type: 'number | `${number}%`', required: false },
        { name: 'top', type: 'number | `${number}%`', required: false },
        { name: 'right', type: 'number | `${number}%`', required: false },
        { name: 'bottom', type: 'number | `${number}%`', required: false },
        { name: 'left', type: 'number | `${number}%`', required: false },
        { name: 'padding', type: 'number | `${number}%`', required: false },
        { name: 'paddingTop', type: 'number | `${number}%`', required: false },
        { name: 'paddingRight', type: 'number | `${number}%`', required: false },
        { name: 'paddingBottom', type: 'number | `${number}%`', required: false },
        { name: 'paddingLeft', type: 'number | `${number}%`', required: false },
        { name: 'margin', type: 'number | "auto" | `${number}%`', required: false },
        { name: 'marginTop', type: 'number | "auto" | `${number}%`', required: false },
        { name: 'marginRight', type: 'number | "auto" | `${number}%`', required: false },
        { name: 'marginBottom', type: 'number | "auto" | `${number}%`', required: false },
        { name: 'marginLeft', type: 'number | "auto" | `${number}%`', required: false },
        { name: 'gap', type: 'number', required: false },
        { name: 'gapColumn', type: 'number', required: false },
        { name: 'gapRow', type: 'number', required: false },
        { name: 'aspectRatio', type: 'number', required: false }
      ]
  }
---

The component `<Box>` creates a flexbox item. It can be used as a direct child
of [`<Flex>`](/docs/reference/flex/flex) or as a child of another `<Box>` to
create a nested flex layout.

## Usage

```svelte
<script lang="ts">
  import { Flex, Box } from '@threlte/flex'
  import Model from './Model.svelte'
</script>

<Flex
  width={100}
  height={100}
  justifyContent="Center"
>
  <Box
    flex={1}
    width="auto"
  >
    {#snippet children({ width })}
      <Model {width} />
    {/snippet}
  </Box>
</Flex>
```

### Content Sizing

The `<Box>` component controls element positions only. However, if you wish to
handle element dimensions based on the layout calculated by Yoga, you'll need to
manually adapt the content's size. This is because `@threlte/flex` lacks
knowledge about the inner content's sizing mechanisms. For this purpose,
`@threlte/flex` offers the _computed dimensions_ in three ways:

- Using the `width` and `height` snippet props

```svelte
<Box>
  {#snippet children({ width, height })}
    <T.Mesh
      scale.x={width}
      scale.y={height}
    />
  {/snippet}
</Box>
```

- Using the [`useDimensions`](/docs/reference/flex/use-dimensions) hook in a child component to `<Box>`:

```svelte title="Child.svelte"
<script lang="ts">
  import { useDimensions } from '@threlte/flex'
  const { width, height } = useDimensions()
</script>

<T.Mesh
  scale.x={$width}
  scale.y={$height}
/>
```

- Using the `reflow` event

```svelte
<Box
  onreflow={({ width, height }) => {
    console.log(width, height)
  }}
>
  <!-- … -->
</Box>
```

### Layout Reflow

To trigger a [layout reflow](/docs/reference/flex/flex#layout-reflow), you can use the `reflow` slot prop:

```svelte
<script lang="ts">
  import { Box } from '@threlte/flex'
  import { Text } from '@threlte/extras'
</script>

<Box>
  {#snippet children({ reflow })}
    <Text text="Hello World" onsync={reflow}>
  {/snippet}
</Box>
```

### Item Ordering

By default, the order of a flex item is determined by the order of insertion in
the component tree. If for any reason you need to change the order of a flex
item manually, you can use the `order` prop:

```svelte
<script lang="ts">
  import { Box } from '@threlte/flex'
</script>

<Flex
  width={100}
  height={100}
>
  <Box order={2} />
  <Box order={1} />
  <Box order={3} />
</Flex>
```


================================================
File: apps/docs/src/content/reference/flex/components.mdx
================================================
---
category: '@threlte/flex'
name: Components
order: -0.5
isDivider: true
---


================================================
File: apps/docs/src/content/reference/flex/create-class-parser.mdx
================================================
---
order: 10.5
category: '@threlte/flex'
sourcePath: 'packages/flex/src/lib/parsers/createClassParser.ts'
name: createClassParser
---

The prop `class` can be used on `<Box>` and `<Flex>` to easily configure the
flexbox with predefined class names just as you would do in CSS. In order to use
the prop, you need to create a `ClassParser` which accepts a single string and
returns `NodeProps`. The function `createClassParser` is a helper function that
provides the proper types.

Let's assume, you want to create a parser that
supports the following class names but in 3D space:

```css
.container {
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: stretch;
  gap: 10px;
  padding: 10px;
}
.item {
  width: auto;
  height: auto;
  flex: 1;
}
```

You then need to create a `ClassParser` which returns the corresponding props:

```ts
import { createClassParser } from '@threlte/flex'

const classParser = createClassParser((string, props) => {
  const classNames = string.split(' ')
  for (const className of classNames) {
    switch (className) {
      case 'container':
        props.flexDirection = 'Row'
        props.justifyContent = 'Center'
        props.alignItems = 'Stretch'
        props.gap = 10
        props.padding = 10
        break
      case 'item':
        props.width = 'auto'
        props.height = 'auto'
        props.flex = 1
    }
  }
  return props
})
```

Now you can use the prop `class` on `<Flex>` and `<Box>` to configure the flexbox:

<Example
  path="flex/create-class-parser"
  expandCode
  showFile="Scene.svelte"
/>


================================================
File: apps/docs/src/content/reference/flex/examples.mdx
================================================
---
order: -1
category: '@threlte/flex'
name: Examples
---

The package `@threlte/flex` is well suited for building responsive layouts.
Especially in an XR context, where using the [DOM is (currently) not
possible](https://www.w3.org/TR/webxr-dom-overlays-1/) you have to rely on
solutions that are native to WebGL.

The following examples show how to use the `@threlte/flex` package to build
responsive layouts in WebGL.

The left side is the CSS implementation, the right side is using `@threlte/flex`.

<Example path="flex/examples" />


================================================
File: apps/docs/src/content/reference/flex/flex.mdx
================================================
---
category: '@threlte/flex'
name: '<Flex>'
order: 0
type: 'component'
sourcePath: 'packages/flex/src/lib/Flex'
componentSignature:
  {
    props:
      [
        {
          name: 'reflowStage',
          type: 'Stage',
          required: false,
          description: 'The stage used for reflowing the layout.'
        },
        { name: 'width', type: 'number', required: false },
        { name: 'height', type: 'number', required: false },
        { name: 'plane', type: 'FlexPlane', required: false },
        { name: 'direction', type: 'keyof typeof Direction', required: false },
        { name: 'scaleFactor', type: 'number', required: false },
        {
          name: 'classParser',
          type: 'ClassParser',
          required: false,
          description: 'A ClassParser can be used to resolve Yoga Node Props based on classes passed to <Box> and <Flex> components.'
        },
        { name: order, type: 'number', required: false },
        {
          name: 'class',
          type: 'string',
          required: false,
          description: 'declared classes will be resolved by a ClassParser declared on <Flex>'
        },
        {
          name: 'alignItems',
          type: '"Auto" | "FlexStart" | "Center" | "FlexEnd" | "Stretch" | "Baseline" | "SpaceBetween" | "SpaceAround"',
          required: false
        },
        {
          name: 'alignSelf',
          type: '"Auto" | "FlexStart" | "Center" | "FlexEnd" | "Stretch" | "Baseline" | "SpaceBetween" | "SpaceAround"',
          required: false
        },
        {
          name: 'alignContent',
          type: '"Auto" | "FlexStart" | "Center" | "FlexEnd" | "Stretch" | "Baseline" | "SpaceBetween" | "SpaceAround"',
          required: false
        },
        {
          name: 'justifyContent',
          type: '"FlexStart" | "Center" | "FlexEnd" | "SpaceBetween" | "SpaceAround" | "SpaceEvenly"',
          required: false
        },
        {
          name: 'flexDirection',
          type: '"Column" | "ColumnReverse" | "Row" | "RowReverse"',
          required: false
        },
        { name: 'flexWrap', type: '"NoWrap" | "Wrap" | "WrapReverse"', required: false },
        { name: 'flex', type: 'number', required: false },
        { name: 'flexBasis', type: 'number | "auto" | `${number}%`', required: false },
        { name: 'flexGrow', type: 'number', required: false },
        { name: 'flexShrink', type: 'number', required: false },
        { name: 'height', type: 'number | "auto" | `${number}%`', required: false },
        { name: 'width', type: 'number | "auto" | `${number}%`', required: false },
        { name: 'maxHeight', type: 'number | `${number}%`', required: false },
        { name: 'maxWidth', type: 'number | `${number}%`', required: false },
        { name: 'minHeight', type: 'number | `${number}%`', required: false },
        { name: 'minWidth', type: 'number | `${number}%`', required: false },
        { name: 'top', type: 'number | `${number}%`', required: false },
        { name: 'right', type: 'number | `${number}%`', required: false },
        { name: 'bottom', type: 'number | `${number}%`', required: false },
        { name: 'left', type: 'number | `${number}%`', required: false },
        { name: 'padding', type: 'number | `${number}%`', required: false },
        { name: 'paddingTop', type: 'number | `${number}%`', required: false },
        { name: 'paddingRight', type: 'number | `${number}%`', required: false },
        { name: 'paddingBottom', type: 'number | `${number}%`', required: false },
        { name: 'paddingLeft', type: 'number | `${number}%`', required: false },
        { name: 'margin', type: 'number | "auto" | `${number}%`', required: false },
        { name: 'marginTop', type: 'number | "auto" | `${number}%`', required: false },
        { name: 'marginRight', type: 'number | "auto" | `${number}%`', required: false },
        { name: 'marginBottom', type: 'number | "auto" | `${number}%`', required: false },
        { name: 'marginLeft', type: 'number | "auto" | `${number}%`', required: false },
        { name: 'gap', type: 'number', required: false },
        { name: 'gapColumn', type: 'number', required: false },
        { name: 'gapRow', type: 'number', required: false },
        { name: 'aspectRatio', type: 'number', required: false }
      ],
    events:
      [
        {
          name: 'reflow',
          payload: '{ width: number, height: number }',
          description: 'Fired as soon as a reflow happened with the resulting width and height.'
        }
      ]
  }
---

The component `<Flex>` is used to create the root of a flex layout. It creates
the root node for [Yoga](https://yogalayout.com) and provides a context for all
child [`<Box>`](/docs/reference/flex/box) components to resolve their layout.

## Usage

The `<Flex>` component resembles the root `display: flex` container in CSS. It
can be used to create a flex layout with the child components `<Box>`.

Since there's no viewport to fill, you must specify the size of the container
with the props `width` and `height`.

```svelte
<script lang="ts">
  import { Flex } from '@threlte/flex'
</script>

<div style="display: flex; width: 100px; height: 100px">
  <!-- ... -->
</div>

<!-- translates to this -->

<Flex
  width={100}
  height={100}
>
  <!-- ... -->
</Flex>
```

### Layout Direction

Layout direction specifies the direction in which children and text in a
hierarchy should be laid out. Layout direction also effects what edge `start` and
`end` refer to. By default Yoga lays out with LTR layout direction.

```svelte
<Flex direction="RTL">
  <!-- ... -->
</Flex>
```

### Layout precision

Yoga uses integers for layout computation. Because in Three.js we're dealing
with floating point numbers, all values are internally multiplied by a
`scaleFactor` of `1000` to increase precision which is suitable for most use
cases. Depending on the size of your layout, you might need to increase the
`scaleFactor` to `10000` or `100000` to avoid layout issues.

```svelte
<Flex scaleFactor={100000}>
  <!-- ... -->
</Flex>
```

### Using CSS Classes

A `classParser` can be used to resolve Yoga Node Props based on classes passed
to `<Box>` and `<Flex>` components. This is useful if you want to use a CSS-like
syntax to define your layout. You can define your own `ClassParser` using the
method [`createClassParser`](/docs/reference/flex/create-class-parser) or by
using a parser provided, for instance the Tailwind CSS parser
[`tailwindParser`](/docs/reference/flex/tailwind-parser).

```svelte
<script lang="ts">
  import { Flex, tailwindParser } from '@threlte/flex'
</script>

<Flex classParser={tailwindParser}>
  <!-- ... -->
</Flex>
```

### Layout Orientationu

Yoga computes the layout on a 2D plane. The elements will be positioned in the
2D plane given by the two axes. By default, the layout plane is the `xy` plane.
You can change the layout plane to `yz` or `xz` by setting the prop `plane`.

```svelte
<Flex plane="yz">
  <!-- ... -->
</Flex>
```

### Layout Reflow

[Yoga](https://yogalayout.com) is a layout engine that computes the layout of a
node tree. If a node (i.e. a [`<Box>`](/docs/reference/flex/box) component) is added or removed
from the tree, or if a node changes its properties, the layout of the component
tree needs to be recomputed. This is called a **reflow**.

A reflow is triggered automatically when:

- `<Flex>` props changes (`width`, `height`, `justifyContent`, …)
- `<Box>` props changes (`justifyContent`, `flex`, …)
- A `<Box>` component mounts or unmounts

Because the width and height of a flex layout item may be calculated from its
bounding box, the initial layout may be incorrect, for instance if a model loads
into view after the initial layout has been computed. To manually request a
reflow, you can use the snippet prop `reflow`:

```svelte
<script lang="ts">
  import { Flex, Box } from '@threlte/flex'
  import { GLTF } from '@threlte/extras'
</script>

<Flex>
  {#snippet children({ reflow })}
    <Box>
      <GLTF
        src="/model.glb"
        onload={() => reflow()}
      />
    </Box>
  {/snippet}
</Flex>
```

<Tip type="tip">
  The `reflow` snippet prop is also available on `<Box>` components to enable
  encapsulated child components to easily request a reflow.
</Tip>

You may also use the hook [`useReflow`](/docs/reference/flex/use-reflow) to request
a reflow.

### Reflow Stage

By default, the reflow of the layout is happening in [Threlte's
mainStage](/docs/learn/basics/scheduling-tasks#default-stages). To change in
what stage the layout should reflow, use the prop `reflowStage`:

```svelte
<script lang="ts">
  import { useStage, useThrelte } from '@threlte/core'
  import { Flex } from '@threlte/flex'

  const { mainStage, renderStage } = useThrelte()

  const reflowStage = useStage('reflow-stage', {
    after: mainStage,
    before: renderStage
  })
</script>

<Flex {reflowStage}>
  <!-- ... -->
</Flex>
```

### Content Dimensions

Although the width and the height of the `<Flex>` component are required, the
**dimensions of the contents** of the `<Flex>` component will be measured after a
[layout reflow](#layout-reflow) and can be retrieved using the following methods:

- Using the hook [`useDimensions`](/docs/reference/flex/use-dimensions)
- Using the snippet props `width` and `height`

```svelte
<script lang="ts">
  import { Flex } from '@threlte/flex'
</script>

<Flex>
  {#snippet children({ width, height })}
    <!-- ... -->
  {/snippet}
</Flex>
```

- Using the `reflow` event

```svelte
<script lang="ts">
  import { Flex } from '@threlte/flex'
</script>

<Flex
  onreflow={({ width, height }) => {
    console.log(width, height)
  }}
>
  <!-- ... -->
</Flex>
```


================================================
File: apps/docs/src/content/reference/flex/getting-started.mdx
================================================
---
order: -2
category: '@threlte/flex'
name: Getting Started
---

Placing content and making layouts in 3D is hard. The flexbox engine
[`Yoga`](https://yogalayout.com/) is a cross-platform layout engine which
implements the flexbox spec. The package `@threlte/flex` provides components to
easily use `Yoga` in Threlte.

<Example
  path="flex/intro"
  showFile="Scene.svelte"
/>

<small>MatCap textures from https://github.com/emmelleppi/matcaps</small>

## Installation

```bash
npm install @threlte/flex
```

## Usage

### Basic Example

Use the component [`<Flex>`](/docs/reference/flex/flex) to create a flexbox
container. Since there's no viewport to fill, you must specify the size of the
container. Add flex items with the component [`<Box>`](/docs/reference/flex/box).

```svelte
<script lang="ts">
  import { Flex } from '@threlte/flex'
  import Plane from './Plane.svelte'
</script>

<Flex
  width={100}
  height={100}
>
  <Box>
    <Plane
      width={20}
      height={20}
    />
  </Box>

  <Box>
    <Plane
      width={20}
      height={20}
    />
  </Box>
</Flex>
```

### Flex Props

The components `<Flex>` and `<Box>` accept props to configure the flexbox. If no
width or height is specified on `<Box>` components, a bounding box is used to
determine the size of the flex item. The computed width or height may be
different from what is specified on the `<Box>` component, depending on the
flexbox configuration. To make use of the calculated dimensions of a flex item, use the slot props `width` and `height`.

```svelte
<Flex
  width={100}
  height={100}
  flexDirection="Column"
  justifyContent="SpaceEvenly"
  alignItems="Stretch"
>
  <Box
    width="auto"
    height="auto"
    flex={1}
  >
    {#snippet children({ width, height })}
      <Plane
        {width}
        {height}
      />
    {/snippet}
  </Box>

  <Box
    width="auto"
    height="auto"
    flex={1}
  >
    {#snippet children({ width, height })}
      <Plane
        {width}
        {height}
      />
    {/snippet}
  </Box>
</Flex>
```

### Nested Flex

Every `<Box>` component is also a flex container. Nesting `<Box>` components
allows you to create complex layouts.

```svelte
<Flex
  width={100}
  height={100}
  flexDirection="Column"
  justifyContent="SpaceEvenly"
  alignItems="Stretch"
>
  <Box
    width="auto"
    height="auto"
    flex={1}
    justifyContent="SpaceEvenly"
    alignItems="Stretch"
    padding={20}
    margin={20}
    gap={20}
  >
    {#snippet children({ width, height })}
      <Plane
        color="orange"
        {width}
        {height}
        depth={1}
      />
      <Box
        height="auto"
        flex={1}
      >
        {#snippet children({ width, height })}
          <Plane
            color="blue"
            {width}
            {height}
            depth={2}
          />
        {/snippet}
      </Box>

      <Box
        height="auto"
        flex={1}
      >
        {#snippet children({ width, height })}
          <Plane
            color="red"
            {width}
            {height}
            depth={2}
          />
        {/snippet}
      </Box>
    {/snippet}
  </Box>

  <Box
    height="auto"
    width="auto"
    flex={1}
  >
    {#snippet children({ width, height })}
      <Plane
        depth={1}
        {width}
        {height}
      />
    {/snippet}
  </Box>
</Flex>
```

### Align Flex Container

The component [`<Align>`](/docs/reference/extras/align) can be used to align the resulting flex container.

```svelte
<script lang="ts">
  import { Align } from '@threlte/extras'
  import { Flex } from '@threlte/flex'
  import Plane from './Plane.svelte'
</script>

<Align y={1}>
  {#snippet children({ align })}
    <Flex
      width={100}
      height={100}
      onreflow={align}
    >
      <Box>
        <Plane
          width={20}
          height={20}
        />
      </Box>

      <Box>
        <Plane
          width={20}
          height={20}
        />
      </Box>
    </Flex>
  {/snippet}
</Align>
```

### Using the Prop `class`

The prop `class` can be used on `<Box>` and `<Flex>` to easily configure the
flexbox with predefined class names just as you would do in CSS. In order to use
the prop, you need to create a `ClassParser` using the utility
[`createClassParser`](/docs/reference/flex/create-class-parser) which accepts a
single string and returns `NodeProps`. Let's assume, you want to create a parser
that supports the following class names:

```css
.container {
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: stretch;
  gap: 10px;
  padding: 10px;
}
.item {
  width: auto;
  height: auto;
  flex: 1;
}
```

You then need to create a `ClassParser` which returns the corresponding props:

```ts
import { createClassParser } from '@threlte/flex'

const classParser = createClassParser((string, props) => {
  const classNames = string.split(' ')
  for (const className of classNames) {
    switch (className) {
      case 'container':
        props.flexDirection = 'Row'
        props.justifyContent = 'Center'
        props.alignItems = 'Stretch'
        props.gap = 10
        props.padding = 10
        break
      case 'item':
        props.width = 'auto'
        props.height = 'auto'
        props.flex = 1
    }
  }
  return props
})
```

Now you can use the prop `class` on `<Flex>` and `<Box>` to configure the flexbox:

```svelte
<Flex
  width={100}
  height={100}
  {classParser}
  class="container"
>
  <Box class="item">
    <Plane
      width={20}
      height={20}
    />
  </Box>

  <Box class="item">
    <Plane
      width={20}
      height={20}
    />
  </Box>
</Flex>
```

`@threlte/flex` ships with a [default `ClassParser` which supports Tailwind-like
class names](/docs/reference/flex/tailwind-parser).


================================================
File: apps/docs/src/content/reference/flex/hooks.mdx
================================================
---
category: '@threlte/flex'
name: Hooks
order: 20
isDivider: true
---


================================================
File: apps/docs/src/content/reference/flex/tailwind-parser.mdx
================================================
---
order: 11
category: '@threlte/flex'
sourcePath: 'packages/flex/src/lib/parsers/tailwindParser.ts'
name: tailwindParser
---

`@threlte/flex` ships with a default parser for Tailwind-like classes on
[`<Flex>`](/docs/reference/flex/flex) and [`<Box>`](/docs/reference/flex/box)
components. If you are familiar with Tailwind, you will feel right at home.

```svelte
<Flex
  width={300}
  height={300}
  classParser={tailwindParser}
  class="flex-col items-center justify-center gap-10 p-10"
>
  <Box class="w-100 h-full shrink-0">
    {#snippet children({ width, height })}
      <Plane
        {width}
        {height}
        color="yellow"
        depth={1}
      />
    {/snippet}
  </Box>

  <Box class="flex-1">
    {#snippet children({ width })}
      <Plane
        color="blue"
        {width}
        height={44}
        depth={1}
      />
    {/snippet}
  </Box>
</Flex>
```

## Usage

Add the `classParser` prop to your `<Flex>` or `<Box>` component and pass in the `tailwindParser` function.

```svelte {2}m {8}+
<script>
  import { Flex, Box, Plane, tailwindParser } from '@threlte/flex'
</script>

<Flex
  width={300}
  height={300}
  classParser={tailwindParser}
  class="flex-col items-center justify-center gap-10 p-10"
>
  <Box class="h-100 w-100">
    {#snippet children({ width, height })}
      <!-- … -->
    {/snippet}
  </Box>
</Flex>
```

## Differences to Tailwind

The syntax is very similar to Tailwind, with a few differences:

- If a value is a number, it is interpreted as a unit in Three.js. For example,
  `gap-10` will set the gap to 10 Three.js units.
- As opposed to Tailwind, you are not limited to the default set of values. You
  can use any value: `gap-17.5` will set the gap to 17.5 Three.js units. `p-56%`
  will set the padding to 56% of the parent's width. **Do not wrap the value in
  brackets** as you would do with custom values in Tailwind CSS.

## Supported Props

The following props are supported by the Tailwind parser:

<Card>

### Flex Direction

| Class              | CSS Properties                   |
| ------------------ | -------------------------------- |
| `flex-row`         | `flex-direction: row`            |
| `flex-col`         | `flex-direction: column`         |
| `flex-row-reverse` | `flex-direction: row-reverse`    |
| `flex-col-reverse` | `flex-direction: column-reverse` |

</Card>

<Card>

### Flex Wrap

| Class               | CSS Properties            |
| ------------------- | ------------------------- |
| `flex-wrap`         | `flex-wrap: wrap`         |
| `flex-wrap-reverse` | `flex-wrap: wrap-reverse` |
| `flex-nowrap`       | `flex-wrap: nowrap`       |

</Card>

<Card>

### Justify Content

| Class             | CSS Properties                   |
| ----------------- | -------------------------------- |
| `justify-start`   | `justify-content: flex-start`    |
| `justify-end`     | `justify-content: flex-end`      |
| `justify-center`  | `justify-content: center`        |
| `justify-between` | `justify-content: space-between` |
| `justify-around`  | `justify-content: space-around`  |
| `justify-evenly`  | `justify-content: space-evenly`  |

</Card>

<Card>

### Align Items

| Class            | CSS Properties            |
| ---------------- | ------------------------- |
| `items-start`    | `align-items: flex-start` |
| `items-end`      | `align-items: flex-end`   |
| `items-center`   | `align-items: center`     |
| `items-baseline` | `align-items: baseline`   |
| `items-stretch`  | `align-items: stretch`    |

</Card>

<Card>

### Align Content

| Class              | CSS Properties                 |
| ------------------ | ------------------------------ |
| `content-normal `  | `align-content: normal`        |
| `content-start`    | `align-content: flex-start`    |
| `content-end`      | `align-content: flex-end`      |
| `content-center`   | `align-content: center`        |
| `content-between`  | `align-content: space-between` |
| `content-around`   | `align-content: space-around`  |
| `content-stretch`  | `align-content: stretch`       |
| `content-baseline` | `align-content: baseline`      |

</Card>

<Card>

### Gap

`value` is a number (e.g. `10`)

| Class           | CSS Properties | Examples   |
| --------------- | -------------- | ---------- |
| `gap-{value}`   | `gap`          | `gap-10`   |
| `gap-x-{value}` | `column-gap`   | `gap-x-10` |
| `gap-y-{value}` | `row-gap`      | `gap-y-10` |

</Card>

<Card>

### Flex Grow

`value` is a number (e.g. `1`)

| Class          | CSS Properties | Examples           |
| -------------- | -------------- | ------------------ |
| `grow-{value}` | `flex-grow`    | `grow-1`, `grow-0` |

</Card>

<Card>

### Flex Shrink

`value` is a number (e.g. `1`)

| Class            | CSS Properties | Examples               |
| ---------------- | -------------- | ---------------------- |
| `shrink-{value}` | `flex-shrink`  | `shrink-1`, `shrink-0` |

</Card>

<Card>

### Flex Basis

`value` can be `auto`, `full`, a percentage (e.g. `55%`) or a number (e.g. `10`).

| Class           | CSS Properties | Examples                                            |
| --------------- | -------------- | --------------------------------------------------- |
| `basis-{value}` | `flex-basis`   | `basis-10`, `basis-full`, `basis-55%`, `basis-auto` |

</Card>

<Card>

### Flex

`value` is a number (e.g. `1`)

| Class          | CSS Properties | Examples             |
| -------------- | -------------- | -------------------- |
| `flex-{value}` | `flex`         | `flex-1`, `flex-0.5` |

</Card>

<Card>

### Align Self

| Class           | CSS Properties           |
| --------------- | ------------------------ |
| `self-auto`     | `align-self: auto`       |
| `self-start`    | `align-self: flex-start` |
| `self-end`      | `align-self: flex-end`   |
| `self-center`   | `align-self: center`     |
| `self-stretch`  | `align-self: stretch`    |
| `self-baseline` | `align-self: baseline`   |

</Card>

<Card>

### Padding

`value` can be `full`, a percentage (e.g. `55%`) or a number (e.g. `10`).

| Class        | CSS Properties                      | Examples                     |
| ------------ | ----------------------------------- | ---------------------------- |
| `p-{value}`  | `padding`                           | `p-10`, `p-full`, `p-55%`    |
| `pt-{value}` | `padding-top`                       | `pt-10`, `pt-full`, `pt-55%` |
| `pr-{value}` | `padding-right`                     | `pr-10`, `pr-full`, `pr-55%` |
| `pb-{value}` | `padding-bottom`                    | `pb-10`, `pb-full`, `pb-55%` |
| `pl-{value}` | `padding-left`                      | `pl-10`, `pl-full`, `pl-55%` |
| `px-{value}` | `padding-left`<br />`padding-right` | `px-10`, `px-full`, `px-55%` |
| `py-{value}` | `padding-top`<br />`padding-bottom` | `py-10`, `py-full`, `py-55%` |

</Card>

<Card>

### Margin

`value` can be `full`, a percentage (e.g. `55%`) or a number (e.g. `10`).

| Class        | CSS Properties                    | Examples                     |
| ------------ | --------------------------------- | ---------------------------- |
| `m-{value}`  | `margin`                          | `m-10`, `m-full`, `m-55%`    |
| `mt-{value}` | `margin-top`                      | `mt-10`, `mt-full`, `mt-55%` |
| `mr-{value}` | `margin-right`                    | `mr-10`, `mr-full`, `mr-55%` |
| `mb-{value}` | `margin-bottom`                   | `mb-10`, `mb-full`, `mb-55%` |
| `ml-{value}` | `margin-left`                     | `ml-10`, `ml-full`, `ml-55%` |
| `mx-{value}` | `margin-left`<br />`margin-right` | `mx-10`, `mx-full`, `mx-55%` |
| `my-{value}` | `margin-top`<br />`margin-bottom` | `my-10`, `my-full`, `my-55%` |

</Card>

<Card>

### Width

`value` can be `auto`, `full`, a percentage (e.g. `55%`) or a number (e.g. `10`).

| Class       | CSS Properties | Examples                            |
| ----------- | -------------- | ----------------------------------- |
| `w-{value}` | `width`        | `w-10`, `w-full`, `w-55%`, `w-auto` |

</Card>

<Card>

### Height

`value` can be `auto`, `full`, a percentage (e.g. `55%`) or a number (e.g. `10`).

| Class       | CSS Properties | Examples                            |
| ----------- | -------------- | ----------------------------------- |
| `h-{value}` | `height`       | `h-10`, `h-full`, `h-55%`, `h-auto` |

</Card>

<Card>

### Top, Right, Bottom, Left

`value` can be a percentage (e.g. `55%`) or a number (e.g. `10`).

| Class            | CSS Properties | Examples                  |
| ---------------- | -------------- | ------------------------- |
| `top-{value}`    | `top`          | `top-10`, `top-55%`       |
| `right-{value}`  | `right`        | `right-10`, `right-55%`   |
| `bottom-{value}` | `bottom`       | `bottom-10`, `bottom-55%` |
| `left-{value}`   | `left`         | `left-10`, `left-55%`     |

</Card>

<Card>

### Aspect Ratio

`value` can be `square`, `portrait`, `landscape` or an arbitrary ratio (e.g. `32/9`).

| Class              | CSS Properties          | Examples                    |
| ------------------ | ----------------------- | --------------------------- |
| `aspect-square `   | `aspect-ratio: 1 / 1`   |
| `aspect-portrait`  | `aspect-ratio: 9 / 16`  |
| `aspect-landscape` | `aspect-ratio: 16 / 9`  |
| `aspect-{value}`   | `aspect-ratio: {value}` | `aspect-32/9`, `aspect-2/1` |

</Card>


================================================
File: apps/docs/src/content/reference/flex/use-dimensions.mdx
================================================
---
order: 22
category: '@threlte/flex'
sourcePath: 'packages/flex/src/lib/hooks/useDimensions.ts'
name: useDimensions
type: 'hook'
---

The hook `useDimensions` can be used to retrieve the _computed_ width and
height of a `<Flex>` or `<Box>` component as
[CurrentWritable](https://threlte.xyz/docs/reference/core/utilities#currentwritable)
stores.

<Tip type="tip">
	The computed width and height is also available as slot props
	on the components [`<Flex>`](/docs/reference/flex/flex#content-dimensions) and
	[`<Box>`](/docs/reference/flex/box#content-sizing).
</Tip>

## In a `<Flex>` component

Because there's no viewport to measure, the width and height of a `<Flex>`
component need to be set manually. Nevertheless, the dimensions of the
contents of the `<Flex>` component will be measured after a layout reflow and
can be retrieved using `useDimensions` in a direct child component to
`<Flex>`.

## In a `<Box>` component

The `<Box>` component controls element positions only. However, if you wish to
handle element dimensions based on the layout calculated by Yoga, you'll need to
manually adapt the content's size. This is because `@threlte/flex` lacks
knowledge about the inner content's sizing mechanisms. You can do this by using
`useDimensions` hook in a direct child component to `<Box>`.

```svelte title="Parent.svelte"
<script>
  import { Flex, Box } from '@threlte/flex'
  import Model from './Model.svelte'
</script>

<Flex
  width={100}
  height={100}
  justifyContent="Center"
  alignItems="Stretch"
>
  <Box
    width="auto"
    height="auto"
    flex={1}
  >
    <Model />
  </Box>
</Flex>
```

```svelte title="Model.svelte"
<script>
  import { useDimensions } from '@threlte/flex'

  const { width, height } = useDimensions()
</script>

<T.Mesh
  scale.x={$width}
  scale.y={$height}
>
  <T.BoxGeometry />
  <T.MeshBasicMaterial color="red" />
</T.Mesh>
```


================================================
File: apps/docs/src/content/reference/flex/use-reflow.mdx
================================================
---
order: 21
category: '@threlte/flex'
sourcePath: 'packages/flex/src/lib/hooks/useReflow.ts'
name: useReflow
type: 'hook'
---

The hook `useReflow` allows you to manually request a layout reflow, for
instance when a [`<Text>`](/docs/reference/extras/text) component finished
synchronizing or when a model has loaded into view and there's no easy access to
the `reflow` slot prop of the components `<Flex>` or `<Box>` because of
component composition. Calls to `reflow` will be limited to once per frame, so
it's safe to call it from multiple components at a time.

```svelte title="Scene.svelte"
<script lang="ts">
  import { Flex, Box } from '@threlte/flex'
  import Label from './Label.svelte'
</script>

<Flex width={100}>
  <Box>
    <Label text="Hello World">
  </Box>
</Flex>
```

```svelte title="Label.svelte"
<script lang="ts">
  import { Text } from '@threlte/extras'
  import { useReflow } from '@threlte/flex/hooks'

  export let text: string

  const reflow = useReflow()
</script>

<Text
  {text}
  onsync={() => {
    reflow()
  }}
/>
```


================================================
File: apps/docs/src/content/reference/flex/utilities.mdx
================================================
---
category: '@threlte/flex'
name: Utilities
order: 10
isDivider: true
---


================================================
File: apps/docs/src/content/reference/gltf/getting-started.mdx
================================================
---
order: 0
category: '@threlte/gltf'
name: Getting Started
---

A small command-line tool that turns GLTF assets into declarative and re-usable Threlte components.

## The GLTF workflow on the web is not ideal.

- GLTF is thrown wholesale into the scene which prevents re-use, in threejs objects can only be mounted once
- Contents can only be found by traversal which is cumbersome and slow
- Changes to queried nodes are made by mutation, which alters the source data and prevents re-use
- Re-structuring content, making nodes conditional or adding/removing is cumbersome
- Model compression is complex and not easily achieved
- Models often have unnecessary nodes that cause extra work and matrix updates

## `@threlte/gltf` fixes that.

- It creates a **virtual graph** of all objects and materials. Now you can easily alter contents and re-use.
- The graph gets pruned (empty groups, unnecessary transforms, ...) for **better performance**.
- It will optionally compress your model with up to **70%-90% size reduction**.

## Usage

```bash
npx @threlte/gltf@latest /path/to/Model.glb [options]
```

<Tip type="warning">The CLI supports only `npx` at this moment.</Tip>

### Options

| Option                                                                | Description                                                          |
| --------------------------------------------------------------------- | -------------------------------------------------------------------- |
| `--output, -o`                                                        | Output file name/path                                                |
| `--types, -t`                                                         | Add Typescript definitions                                           |
| `--keepnames, -k`                                                     | Keep original names                                                  |
| `--meta, -m`                                                          | Include metadata (as `userData`)                                     |
| `--shadows, -s`                                                       | Let meshes cast and receive shadows                                  |
| `--printwidth, -w`                                                    | Prettier `printWidth` (default: 120)                                 |
| `--precision, -p`                                                     | Number of fractional digits (default: 2)                             |
| `--draco, -d`                                                         | Draco binary path                                                    |
| `--preload -P`                                                        | Add preload method to module script                                  |
| `--suspense -u`                                                       | Make the component [suspense-ready](/docs/reference/extras/suspense) |
| `--isolated, -i`                                                      | Output as isolated module (No `$$restProps` usage)                   |
| `--root, -r`                                                          | Sets directory from which .gltf file is served                       |
| `--transform, -T`                                                     | Transform the asset for the web (draco, prune, resize)               |
| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`--resolution, -R`                      | Transform resolution for texture resizing (default: 1024)            |
| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`--simplify, -S`                        | Transform simplification (default: false, experimental)              |
| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`--weld`  | Weld tolerance (default: 0.0001)                                     |
| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`--ratio` | Simplifier ratio (default: 0.75)                                     |
| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`--error` | Simplifier error threshold (default: 0.001)                          |
| `--debug, -D`                                                         | Debug output                                                         |

## Example

<Tip type="note">
  This example assumes you have your model set up and exported from an application like
  [Blender](https://www.blender.org/) as a GLTF file.
</Tip>

First you run your model through `@threlte/gltf`. `npx` allows you to use npm packages without installing them.

```bash
npx @threlte/gltf@latest model.gltf --transform
```

This will create a `Model.svelte` file that plots out all of the assets contents.

```svelte
<!--
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@0.0.1 ./stacy.glb
-->
<script>
  import { Group } from 'three'
  import { T } from '@threlte/core'
  import { useGltf, useGltfAnimations } from '@threlte/extras'

  let {
    ref = $bindable(),
    actions = $bindable(),
    mixer = $bindable(),
    children,
    ...props
  } = $props()

  const gltf = useGltf('/stacy.glb')
  const animations = useGltfAnimations(gltf, ref)
  actions = animations.actions
  mixer = animations.mixer
</script>

{#if $gltf}
  <T.Group
    bind:ref
    {...props}
  >
    <T.Group name="Scene">
      <T.Group
        name="Stacy"
        rotation={[Math.PI / 2, 0, 0]}
        scale={0.01}
      >
        <T is={$gltf.nodes.mixamorigHips} />
        <T.SkinnedMesh
          name="stacy"
          geometry={$gltf.nodes.stacy.geometry}
          material={$gltf.nodes.stacy.material}
          skeleton={$gltf.nodes.stacy.skeleton}
          rotation={[-Math.PI / 2, 0, 0]}
          scale={100}
        />
      </T.Group>
    </T.Group>

    {@render children?.({ ref })}
  </T.Group>
{/if}
```

Add your model to your `/static` folder as you would normally do. With the `--transform` flag it has created a compressed copy of it (in the above case `model-transformed.glb`). Without the flag just copy the original model.

```text
static/
  model-transformed.glb
```

The component can now be dropped into your scene.

```svelte
<script>
  import { Canvas } from '@threlte/core'
  import Model from './Model.svelte'
</script>

<Canvas>
  <Model />
</Canvas>
```

You can re-use it, it will re-use geometries and materials out of the box:

```svelte
<Model position={[0, 0, 0]} />
<Model position={[10, 0, -10]} />
```

Or make the model dynamic. Change its colors for example:

```svelte
<T.Mesh
  geometry={$gltf.nodes.robot.geometry}
  material={$gltf.materials.metal}
  material.color="green"
/>
```

Or exchange materials:

```svelte
<T.Mesh geometry={$gltf.nodes.robot.geometry}>
  <T.MeshPhysicalMaterial color="hotpink" />
</T.Mesh>
```

Make contents conditional:

```svelte
{#if condition}
  <T.Mesh
    geometry={$gltf.nodes.robot.geometry}
    material={$gltf.materials.metal}
  />
{/if}
```

## DRACO Compression

You don't need to do anything if your models are draco compressed, since `useGltf` defaults to a [draco CDN](https://www.gstatic.com/draco/v1/decoders/). By adding the `--draco` flag you can refer to [local binaries](https://github.com/mrdoob/three.js/tree/dev/examples/js/libs/draco/gltf) which must reside in your /public folder.

## Auto-Transform

With the `--transform` flag it creates a binary-packed, draco-compressed, texture-resized (1024x1024), webp compressed, deduped, instanced and pruned \*.glb ready to be consumed on a web site. It uses [glTF-Transform](https://github.com/donmccurdy/glTF-Transform). This can reduce the size of an asset by 70%-90%.

It will not alter the original but create a copy and append `[modelname]-transformed.glb`.

## Type-Safety

Add the `--types` flag and your component will be typesafe.

```svelte
<!--
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@0.0.1 ./stacy.glb -t
-->
<script lang="ts">
  import type * as THREE from 'three'
  import { Group } from 'three'
  import { T, type Props } from '@threlte/core'
  import { useGltf, useGltfAnimations } from '@threlte/extras'
  import type { Snippet } from 'svelte'

  type Props = {
    ref?: Group
    actions?: ReturnType<typeof useGltfAnimations>['actions']
    mixer?: ReturnType<typeof useGltfAnimations>['mixer']
    children?: Snippet<[{ ref: Group }]>
  }

  let {
    ref = $bindable(),
    actions = $bindable(),
    mixer = $bindable(),
    children,
    ...props
  }: Props = $props()

  const group = new Group()

  type ActionName =
    | 'pockets'
    | 'rope'
    | 'swingdance'
    | 'jump'
    | 'react'
    | 'shrug'
    | 'wave'
    | 'golf'
    | 'idle'
  type GLTFResult = {
    nodes: {
      stacy: THREE.SkinnedMesh
      mixamorigHips: THREE.Bone
    }
    materials: {}
  }

  const { actions, mixer } = useGltfAnimations<ActionName>(gltf, ref)
  const gltf = useGltf<GLTFResult>('/stacy.glb')

  actions = animations.actions
  mixer = animations.mixer
</script>

{#if $gltf}
  <T
    bind:ref
    is={group}
    {...props}
  >
    <T.Group name="Scene">
      <T.Group
        name="Stacy"
        rotation={[Math.PI / 2, 0, 0]}
        scale={0.01}
      >
        <T is={$gltf.nodes.mixamorigHips} />
        <T.SkinnedMesh
          name="stacy"
          geometry={$gltf.nodes.stacy.geometry}
          material={$gltf.nodes.stacy.material}
          skeleton={$gltf.nodes.stacy.skeleton}
          rotation={[-Math.PI / 2, 0, 0]}
          scale={100}
        />
      </T.Group>
    </T.Group>

    {@render children?.({ ref })}
  </T>
{/if}
```

## Animations

If your GLTF contains animations it will add [@threlte/extras's `useGltfAnimations`](/docs/reference/extras/use-gltf-animations) hook, which extracts all clips and prepares them as actions:

```svelte
const gltf = useGltf('/stacy.glb') export const {(actions, mixer)} = useGltfAnimations(gltf, ref)
```

If you want to play an animation you can do so at any time:

```ts
const onEvent = () => {
  $actions.jump.play()
}
```

## Suspense

If you want to use the component [`<Suspense>`](/docs/reference/extras/suspense) to suspend the rendering of loading components (and therefore models) and optionally show a fallback in a parent component component, you can do so by passing the flag `--suspense` to make the generated Threlte component _suspense-ready_:

```svelte
<script>
  import Model from './Model.svelte'
  import Fallback from './Fallback.svelte'
  import { Suspense } from '@threlte/extras'
</script>

<Suspense>
  {#snippet fallback()}
    <Fallback />
  {/snippet}
  <Model />
</Suspense>
```

## Asset Pipeline

In larger projects with a lot of models and assets, it's recommended to set up an asset pipeline with tools like [`npm-watch`](https://www.npmjs.com/package/npm-watch) and Node.js scripts to automatically transform models to Threlte components and copy them to the right place as this makes iterating over models and assets much faster.


================================================
File: apps/docs/src/content/reference/rapier/about-joints.mdx
================================================
---
order: 11
category: '@threlte/rapier'
name: 'About Joints'
---

One of the most appealing features of a physics engine is to simulate articulations. Articulations, aka. joints, allow the restriction of the motion of one body relative to another body. For example, one well-known joint is the ball-in-socket joint also known as the spherical joint: it allows one object to rotate freely with regard to the other but not to translate. This is typically used to simulate shoulders of a ragdoll.

To start off, get yourself comfortable with the [basic concepts of Joints](https://rapier.rs/docs/user_guides/javascript/joints#basic-concepts).

Currently Rapier supports these joints:

- **Fixed joint**
  - [`useFixedJoint` hook](/docs/reference/rapier/use-fixed-joint)
  - [Rapier Documentation](https://rapier.rs/docs/user_guides/javascript/joints#fixed-joint)
  - [Rapier Reference](https://rapier.rs/javascript3d/classes/FixedImpulseJoint.html)
- **Revolute joint**
  - [`useRevoluteJoint` hook](/docs/reference/rapier/use-revolute-joint)
  - [Rapier Documentation](https://rapier.rs/docs/user_guides/javascript/joints#revolute-joint)
  - [Rapier Reference](https://rapier.rs/javascript3d/classes/RevoluteImpulseJoint.html)
- **Prismatic joint**
  - [`usePrismaticJoint` hook](/docs/reference/rapier/use-prismatic-joint)
  - [Rapier Documentation](https://rapier.rs/docs/user_guides/javascript/joints#prismatic-joint)
  - [Rapier Reference](https://rapier.rs/javascript3d/classes/PrismaticImpulseJoint.html)
- **Spherical joint**
  - [`useSphericalJoint` hook](/docs/reference/rapier/use-spherical-joint)
  - [Rapier Documentation](https://rapier.rs/docs/user_guides/javascript/joints#spherical-joint)
  - [Rapier Reference](https://rapier.rs/javascript3d/classes/SphericalImpulseJoint.html)

### Why hooks?

Joints need two rigid bodies which the joint operates on. These two rigid bodies cannot always be infered from a component tree. See the following example:

```svelte
<script>
  import { RigidBody, Collider } from '@threlte/rapier'
</script>

<!-- A -->
<RigidBody>
  <Collider
    shape="cuboid"
    args={[1, 1, 1]}
  />
</RigidBody>

<!-- B -->
<RigidBody>
  <Collider
    shape="cuboid"
    args={[1, 1, 1]}
  />
</RigidBody>

<!-- C -->
<RigidBody>
  <Collider
    shape="cuboid"
    args={[1, 1, 1]}
  />
</RigidBody>
```

There's no way to wrap `<RigidBody>` **A** and **B** in an imaginary component `<Joint>` as well as to wrap **A** and **C** in a separate component `<Joint>` to generate two joints which both act on `<RigidBody>` **A**.


================================================
File: apps/docs/src/content/reference/rapier/attractor.mdx
================================================
---
order: 6
category: '@threlte/rapier'
sourcePath: 'packages/rapier/src/lib/components/Attractor/Attractor.svelte'
name: '<Attractor>'
type: 'component'
componentSignature:
  {
    extends: { type: 'Group', url: 'https://threejs.org/docs/index.html#api/en/objects/Group' },
    props:
      [
        { name: 'strength', type: 'number', default: '1', required: false },
        { name: 'range', type: 'number', default: '10', required: false },
        { name: 'gravityType', type: "'static' | 'linear' | 'newtonian'", required: false },
        { name: 'gravitationalConstant', type: 'number', default: '6.673e-11', required: false }
      ]
  }
---

An attractor simulates a source of gravity. Any rigid-body within range will be "pulled" toward the attractor's center.

The force applied to rigid-bodies within range is calculated differently, depending on the `gravityType`.

## Basic Example

<Example path="rapier/attractor" />

## Gravity Types

### Static (Default)

Static gravity means that the same force (`strength`) is applied on all rigid-bodies within range, regardless of distance.

### Linear

Linear gravity means that force is calculated as `strength * distance / range`. That means the force applied increases as a rigid-body moves closer to the attractor's center.

### Newtonian

Newtonian gravity uses the traditional method of calculating gravitational force (`F = GMm/r^2`) and as such force is calculated as `gravitationalConstant * mass1 * mass2 / Math.pow(distance, 2)`.

- `gravitationalConstant` defaults to 6.673e-11 but you can provide your own
- `mass1` here is the "mass" of the Attractor, which is just the `strength` property
- `mass2` is the mass of the rigid-body at the time of calculation. Note that rigid-bodies with colliders will use the mass provided to the collider. This is not a value you can control from the attractor, only from wherever you're creating rigid-body components in the scene.
- `distance` is the distance between the attractor and rigid-body at the time of calculation

## Debugging

The `<Debug />` component will activate a wireframe helper to visualize the attractor's range.


================================================
File: apps/docs/src/content/reference/rapier/auto-colliders.mdx
================================================
---
order: 4
category: '@threlte/rapier'
name: '<AutoColliders>'
sourcePath: 'packages/rapier/src/lib/components/Colliders/AutoColliders/AutoColliders.svelte'
type: 'component'
componentSignature:
  {
    pretext: "If a <code>&lt;AutoColliders&gt;</code> component is not a child of a <code>&lt;RigidBody&gt;</code> component, the transform properties are reactive.<br /><br />If you don't provide any of the properties <code>density</code>, <code>mass</code> or <code>massProperties</code>, Rapier will figure that out for you.<br /><br />You can provide either a property <code>density</code>, <code>mass</code> <strong>or</strong> <code>massProperties</code>.",
    props:
      [
        {
          name: 'shape',
          required: false,
          type: "'cuboid' | 'ball' | 'capsule' | 'trimesh' | 'convexHull'",
          default: "'convexHull'"
        },
        { name: 'density', required: false, type: 'number' },
        { name: 'mass', required: false, type: 'number' },
        { name: 'massProperties', required: false, type: '{
            mass: number,
            centerOfMass: Position,
            principalAngularInertia: Position,
            angularInertiaLocalFrame: Rotation,
            }' },
        { name: 'restitution', required: false, type: 'number' },
        { name: 'restitutionCombineRule', required: false, type: 'CoefficientCombineRule' },
        { name: 'friction', required: false, type: 'number' },
        { name: 'frictionCombineRule', required: false, type: 'CoefficientCombineRule' },
        { name: 'sensor', required: false, type: 'boolean' },
        { name: 'contactForceEventThreshold', required: false, type: 'number' }
      ],
    exports:
      [
        {
          name: 'refresh',
          type: '() => void',
          description: 'Invoke this function to update the colliders shapes and transforms.'
        }
      ],
    events: [{ name: 'create', payload: 'ref: Collider[]' }, { name: 'collisionenter', payload: '{
            targetCollider: Collider,
            targetRigidBody: RigidBody | null,
            manifold: TempContactManifold,
            flipped: boolean
            }' }, { name: 'collisionexit', payload: '{
            targetCollider: Collider,
            targetRigidBody: RigidBody | null
            }' }, { name: 'sensorenter', payload: '{
            targetCollider: Collider,
            targetRigidBody: RigidBody | null
            }' }, { name: 'sensorexit', payload: '{
            targetCollider: Collider
            targetRigidBody: RigidBody | null
            }' }, { name: 'contact', payload: '{
            targetCollider: Collider,
            targetRigidBody: RigidBody | null,
            manifold: TempContactManifold,
            flipped: boolean,
            maxForceDirection: Vector,
            maxForceMagnitude: number,
            totalForce: Vector,
            totalForceMagnitude: number,
            }' }],
    bindings:
      [
        {
          name: 'colliders',
          type: { name: 'Collider[]', url: 'https://rapier.rs/javascript3d/classes/Collider.html' }
        }
      ]
  }
---

The `<AutoColliders>` component generates colliders based on its children. Currently these shapes are available:

1. `cuboid` – uses each child mesh bounding box and generates a cuboid collider
2. `ball` – uses each child mesh bounding box and generates a ball collider
3. `capsule` – uses each child mesh bounding box and generates a capsule collider
4. `trimesh` – uses each child mesh geometry and generates a polygonal collider which resembles the geometry
5. `convexHull` – uses each child mesh geometry and generates a collider which resembles a convex hull around the geometry

The resulting colliders can be transformed (i.e. positioned, rotated and scaled) as well as given regular collider properties such as `mass` or `centerOfMass`.

<Example path="rapier/auto-colliders" />

<small>
  Model: Battle Damaged Sci-fi Helmet by [theblueturtle\_](https://sketchfab.com/theblueturtle_)
</small>


================================================
File: apps/docs/src/content/reference/rapier/collider.mdx
================================================
---
order: 3
category: '@threlte/rapier'
sourcePath: 'packages/rapier/src/lib/components/Colliders/Collider/Collider.svelte'
name: '<Collider>'
type: 'component'
componentSignature:
  {
    pretext: "If a <code>&lt;Collider&gt;</code> component is not a child of a <code>&lt;RigidBody&gt;</code> component, the transform properties are reactive.<br /><br />If you don't provide any of the properties <code>density</code>, <code>mass</code> or <code>massProperties</code>, Rapier will figure that out for you.<br /><br />You can provide either a property <code>density</code>, <code>mass</code> <strong>or</strong> <code>massProperties</code>.",
    props:
      [
        {
          name: 'shape',
          type: "'ball' | 'capsule' | 'segment' | 'triangle' | 'roundTriangle' | 'polyline' | 'trimesh' | 'cuboid' | 'roundCuboid' | 'heightfield' | 'cylinder' | 'roundCylinder' | 'cone' | 'roundCone' | 'convexHull' | 'convexMesh' | 'roundConvexHull' | 'roundConvexMesh'",
          required: true
        },
        { name: 'args', type: 'Parameters<typeof ColliderDesc[Shape]>', required: true },
        { name: 'density', required: false, type: 'number' },
        { name: 'mass', required: false, type: 'number' },
        { name: 'massProperties', required: false, type: '{
            mass: number,
            centerOfMass: Position,
            principalAngularInertia: Position,
            angularInertiaLocalFrame: Rotation,
            }' },
        { name: 'restitution', required: false, type: 'number' },
        { name: 'restitutionCombineRule', required: false, type: 'CoefficientCombineRule' },
        { name: 'friction', required: false, type: 'number' },
        { name: 'frictionCombineRule', required: false, type: 'CoefficientCombineRule' },
        { name: 'sensor', required: false, type: 'boolean' },
        { name: 'contactForceEventThreshold', required: false, type: 'number' }
      ],
		exports:
      [
        {
          name: 'refresh',
          type: '() => void',
          description: 'Invoke this function to update the colliders transforms.'
        }
      ],
    events: [{ name: 'create', payload: 'ref: Collider' }, { name: 'collisionenter', payload: '{
            targetCollider: Collider,
            targetRigidBody: RigidBody | null,
            manifold: TempContactManifold,
            flipped: boolean
            }' }, { name: 'collisionexit', payload: '{
            targetCollider: Collider,
            targetRigidBody: RigidBody | null
            }' }, { name: 'sensorenter', payload: '{
            targetCollider: Collider,
            targetRigidBody: RigidBody | null
            }' }, { name: 'sensorexit', payload: '{
            targetCollider: Collider,
            targetRigidBody: RigidBody | null
            }' }, { name: 'contact', payload: '{
            targetCollider: Collider,
            targetRigidBody: RigidBody | null
            manifold: TempContactManifold
            flipped: boolean
            maxForceDirection: Vector
            maxForceMagnitude: number
            totalForce: Vector
            totalForceMagnitude: number
            }' }],
    bindings:
      [
        {
          name: 'collider',
          type: { name: 'Collider', url: 'https://rapier.rs/javascript3d/classes/Collider.html' }
        }
      ]
  }
---

Colliders represent the geometric shapes that generate contacts and collision events when they touch. Attaching one or multiple colliders to a rigid body allow the rigid-body to be affected by contact forces.

<Example path="rapier/collider" />


================================================
File: apps/docs/src/content/reference/rapier/collision-groups.mdx
================================================
---
order: 5
category: '@threlte/rapier'
sourcePath: 'packages/rapier/src/lib/components/CollisionGroups/CollisionGroups.svelte'
name: '<CollisionGroups>'
type: 'component'
componentSignature:
  {
    pretext: 'Provide either the shorthand property <code>groups</code> to set both <code>memberships</code> and <code>filter</code> to the same value or set them up individually.',
    props:
      [
        { name: 'groups', type: 'CollisionGroupsBitMask', required: true },
        { name: 'filter', type: 'CollisionGroupsBitMask', required: true },
        { name: 'memberships', type: 'CollisionGroupsBitMask', required: true }
      ]
  }
---

The most efficient way of preventing some pairs of colliders from interacting with each other is to use a `<CollisionGroups>` component.

Each collider that is a child (direct or indirect) of the component `<CollisionGroups>` is applied a `memberships` and `filters` attribute. The shorthand `groups` sets both properties at once.

For general usage instructions, see the relevant documentation [here](https://rapier.rs/docs/user_guides/javascript/colliders#collision-groups-and-solver-groups).

### Example

- <span style="color: red">Collider A</span> is affected by <span style="color: limegreen">
    Collider B
  </span> and not by <span style="color: blue">Collider C</span>
- <span style="color: limegreen">Collider B</span> is affected by <span style="color: red">
    Collider A
  </span> and <span style="color: blue">Collider C</span>
- <span style="color: blue">Collider C</span> is affected by <span style="color: limegreen">
    Collider B
  </span> and not by <span style="color: red">Collider A</span>

<Example path="rapier/collision-groups" />

```svelte
<!-- Collider A -->
<CollisionGroups
  memberships={[1]}
  filter={[2]}
>
  <RigidBody>
    <AutoColliders shape={'cuboid'}>
      <Mesh
        castShadow
        {geometry}
        {material}
      />
    </AutoColliders>
  </RigidBody>
</CollisionGroups>

<!-- Collider B -->
<CollisionGroups
  memberships={[2]}
  filter={[1, 3]}
>
  <RigidBody>
    <AutoColliders shape={'cuboid'}>
      <Mesh
        castShadow
        {geometry}
        {material}
      />
    </AutoColliders>
  </RigidBody>
</CollisionGroups>

<!-- Collider C -->
<CollisionGroups
  memberships={[3]}
  filter={[2]}
>
  <RigidBody>
    <AutoColliders shape={'cuboid'}>
      <Mesh
        castShadow
        {geometry}
        {material}
      />
    </AutoColliders>
  </RigidBody>
</CollisionGroups>
```


================================================
File: apps/docs/src/content/reference/rapier/components.mdx
================================================
---
order: 0.5
category: '@threlte/rapier'
name: 'Components'
isDivider: true
---


================================================
File: apps/docs/src/content/reference/rapier/concepts.mdx
================================================
---
order: 0.1
category: '@threlte/rapier'
name: 'Concepts'
isDivider: true
---


================================================
File: apps/docs/src/content/reference/rapier/debug.mdx
================================================
---
order: 7
category: '@threlte/rapier'
sourcePath: 'packages/rapier/src/lib/components/Debug/Debug.svelte'
name: '<Debug>'
type: 'component'
componentSignature:
  {
    extends:
      {
        type: 'LineBasicMaterial',
        url: 'https://threejs.org/docs/index.html#api/en/materials/LineBasicMaterial'
      }
  }
---

Use the Debug component to see live representations of all colliders in a scene.

```svelte
<Canvas>
  <World>
    <Debug />

    <RigidBody>
      <AutoColliders>
        <Mesh
          {geometry}
          {material}
        />
      </AutoColliders>
    </RigidBody>
  </World>
</Canvas>
```


================================================
File: apps/docs/src/content/reference/rapier/framerate.mdx
================================================
---
order: 0.2
category: '@threlte/rapier'
name: 'Physics Framerate'
---

import frameRate1 from './framerate-1.svg?url'
import frameRate2 from './framerate-2.svg?url'

Threlte's `<World>` component has a `framerate` prop that can be used to control
the framerate of the physics simulation.

## `requestAnimationFrame` Timing

By default, the physics framerate is set to vary depending on the timestamp
passed as the argument to the callback of `requestAnimationFrame`. Take this
trivial example:

```ts
const render = (time: number) => {
  console.log(time)
  requestAnimationFrame(render)
}
requestAnimationFrame(render)
```

Unlucky for us, the time delta between frames varies depending on several
factors such as the refresh rate of the monitor and the general load of your
computer or application. When using a `varying` framerate, this time delta is
used to _advance the physics simulation_ and while you would think that this
wouldn't make much of a difference, computers are really bad at floating point
arithmetic (`console.log(0.1 + 0.2)`): Realistically no two executions of the
same physics simulation will yield the same result. In short: it's **not
deterministic**.

For most applications, this is still the best choice since it doesn't require
you to think about the aspects of handling different framerates for physics and
rendering.

Sometimes, however, whether you're developing a game or wish to have more
control art directing the outcome, you want a physics simulation to **always
yield the same result**, e.g. to be **deterministic**. In this case, you can set
the `framerate` prop to a fixed number. A fixed framerate of `50` for example
will _step_ the physics simulation 50 times per second with a delta of exactly
`1 / 50 = 0.02` seconds – no matter the timestamp passed to
`requestAnimationFrame`.

The following example illustrates the difference:

<Example
  path="rapier/framerate"
  hideCode
  hideStackblitz
/>

## Fixed Framerate

In order to efficiently use a fixed framerate, it's important to understand how
Threlte is able to advance the physics simulation in a deterministic fashion
while keeping the visual output smooth and in sync.

First, let's have a look at the timing of the `requestAnimationFrame` API:

<img
  src={frameRate1}
  width="100%"
  alt="Frame rate 1"
/>

In this example we're looking at two invokations of `requestAnimationFrame`.

- **A** receives a delta of 16.35ms
- **B** receives a delta of 16.1ms

<Tip type="info">
  Threlte is making use of [the scheduler's
  ability](http://localhost:4321/docs/learn/basics/scheduling-tasks#creating-a-stage) to run the
  tasks of a stage multiple times per frame and with a fixed delta.
</Tip>

We'd like to advance the physics simulation 200 times per second, so 5ms per step.

<img
  src={frameRate2}
  width="100%"
  alt="Frame rate 2"
/>

In this example, the physics simulation is advanced 4 times as part of
`requestAnimationFrame` **A**. The simulation then runs **ahead of the visual
output.** After advancing the physics simulation, the visual state of the
objects is rolled back from 20ms to 16.35ms while internally maintaining the
physics state of after the 4th simulation step.

This cycle repeats in the next frame **B**: The simulation is advanced 3 times
as part of `requestAnimationFrame` **B** in order to slightly run ahead of the
render time and subsequently rolled back to match the time of the render.

The following example visualizes how the framerate correlates with the physics
simulation running ahead of the visual output.

<Example
  path="rapier/framerate-debug"
  hideCode
  hideStackblitz
/>

## `usePhysicsTask`

Use the hook [`usePhysicsTask`](/docs/reference/rapier/use-physics-task) to
interact with the physics simulation. It's a wrapper around the [`useTask`
hook](/docs/reference/core/use-task) that automatically adds the handler to the
`simulation` stage and always runs _before_ the physics world is stepped.


================================================
File: apps/docs/src/content/reference/rapier/getting-started.mdx
================================================
---
order: 0
category: '@threlte/rapier'
name: 'Getting Started'
---

[Rapier](https://rapier.rs/) is a fast physics engine written in Rust. This package provides easy to use components and hooks to use the Rapier physics engine in Threlte.

To start off, it's best to get yourself comfortable with the [basic concepts of rapier](https://rapier.rs/docs/).

<Tip type="experimental">
  This package is under heavy development and its API is subject to change. Also be aware that
  currently only one Rapier-enabled Threlte instance is possible.
</Tip>

### Installation

Make sure to have `@threlte/core` installed.

```bash copy
npm install @threlte/rapier @dimforge/rapier3d-compat
```


================================================
File: apps/docs/src/content/reference/rapier/hooks.mdx
================================================
---
order: 7.5
category: '@threlte/rapier'
name: 'Hooks'
isDivider: true
---


================================================
File: apps/docs/src/content/reference/rapier/joints.mdx
================================================
---
order: 10.5
category: '@threlte/rapier'
name: 'Joints'
isDivider: true
---


================================================
File: apps/docs/src/content/reference/rapier/rigid-body.mdx
================================================
---
order: 2
category: '@threlte/rapier'
sourcePath: 'packages/rapier/src/lib/components/RigidBody/RigidBody.svelte'
name: '<RigidBody>'
type: 'component'
componentSignature:
  {
    props:
      [
        {
          name: type,
          type: "'fixed' | 'dynamic' | 'kinematicPosition' | 'kinematicVelocity'",
          default: "'dynamic'",
          required: false
        },
        { name: 'canSleep', type: 'boolean', default: 'true', required: false },
        { name: 'linearVelocity', type: 'Position', default: '{}', required: false },
        { name: 'angularVelocity', type: 'Rotation', default: '{}', required: false },
        { name: 'gravityScale', type: 'number', default: '1', required: false },
        { name: 'ccd', type: 'boolean', default: 'false', required: false },
        { name: 'lockRotations', type: 'boolean', default: 'false', required: false },
        { name: 'lockTranslations', type: 'boolean', default: 'false', required: false },
        {
          name: 'enabledRotations',
          type: 'Boolean3Array',
          default: '[true, true, true]',
          required: false
        },
        {
          name: 'enabledTranslations',
          type: 'Boolean3Array',
          default: '[true, true, true]',
          required: false
        },
        { name: 'dominance', type: 'number', default: '0', required: false },
        { name: 'linearDamping', type: 'number', default: '0', required: false },
        { name: 'angularDamping', type: 'number', default: '0', required: false },
        { name: 'userData', type: 'Record<string, any>', default: '{}', required: false }
      ],
    events:
      [
        { name: 'create', payload: 'ref: RigidBody' },
        { name: 'sleep', payload: 'void' },
        { name: 'wake', payload: 'void' },
        { name: 'collisionenter', payload: '{
            targetCollider: Collider,
            targetRigidBody: RigidBody | null,
            manifold: TempContactManifold,
            flipped: boolean
            }' },
        { name: 'collisionexit', payload: '{
            targetCollider: Collider,
            targetRigidBody: RigidBody | null
            }' },
        { name: 'sensorenter', payload: '{
            targetCollider: Collider,
            targetRigidBody: RigidBody | null
            }' },
        { name: 'sensorexit', payload: '{
            targetCollider: Collider,
            targetRigidBody: RigidBody | null
            }' },
        { name: 'contact', payload: '{
            targetCollider: Collider,
            targetRigidBody: RigidBody | null,
            manifold: TempContactManifold,
            flipped: boolean,
            maxForceDirection: Vector,
            maxForceMagnitude: number,
            totalForce: Vector,
            totalForceMagnitude: number
            }' }
      ],
    bindings:
      [
        {
          name: 'rigidBody',
          type: { name: 'RigidBody', url: 'https://rapier.rs/javascript3d/classes/RigidBody.html' }
        }
      ]
  }
---

The real-time simulation of rigid bodies subjected to forces and contacts is the main feature of a physics engine for videogames, robotics, or animation. Rigid bodies are typically used to simulate the dynamics of non-deformable solids as well as to integrate the trajectory of solids which velocities are controlled by the user (e.g. moving platforms).

Note that rigid-bodies are only responsible for the dynamics and kinematics of the solid. Colliders can be attached to a rigid-body to specify its shape and enable collision-detection. A rigid-body without collider attached to it will not be affected by contacts (because there is no shape to compute contact against).

<Example path="rapier/rigid-body" />


================================================
File: apps/docs/src/content/reference/rapier/use-collision-groups.mdx
================================================
---
order: 9
category: '@threlte/rapier'
name: 'useCollisionGroups'
sourcePath: 'packages/rapier/src/lib/hooks/useCollisionGroups.ts'
type: 'hook'
---

This hook can be used in conjunction with the component [`<CollisionGroups>`](/docs/reference/rapier/collision-groups). It uses the collision groups provided by a parent `<CollisionGroups>` component and lets you easily apply them to colliders.

```svelte
<script>
  import { useRapier, useCollisionGroups } from '@threlte/rapier'

  const { world } = useRapier()
  const { registerColliders, removeColliders } = useCollisionGroups()

  const collider = world.createCollider(colliderDesc)

  // collider will be assigned the collision groups
  // provided by a parent `<CollisionGroups>` component.
  registerColliders([collider])

  onDestroy(() => {
    removeColliders([collider])
  })
</script>
```

### Types

```ts
const {
  registerColliders, // (colliders: RAPIER.Collider[]) => void
  removeColliders // (colliders: RAPIER.Collider[]) => void
} = useCollisionGroups()
```


================================================
File: apps/docs/src/content/reference/rapier/use-fixed-joint.mdx
================================================
---
order: 13
category: '@threlte/rapier'
sourcePath: 'packages/rapier/src/lib/hooks/useFixedJoint.ts'
name: 'useFixedJoint'
type: 'hook'
---

Use this hook to initialize a [`FixedImpulseJoint`](https://rapier.rs/docs/user_guides/javascript/joints#fixed-joint).

```svelte
<script>
  import { useFixedJoint, RigidBody, Collider } from '@threlte/rapier'

  const { joint, rigidBodyA, rigidBodyB } = useFixedJoint({ x: 1 }, {}, { x: -1 }, {})
</script>

<RigidBody bind:rigidBody={$rigidBodyA}>
  <Collider
    shape="cuboid"
    args={[1, 1, 1]}
  />
</RigidBody>

<RigidBody bind:rigidBody={$rigidBodyB}>
  <Collider
    shape="cuboid"
    args={[1, 1, 1]}
  />
</RigidBody>
```

### Signature

```ts
const {
	joint: Writable<FixedImpulseJoint>
	rigidBodyA: Writable<RAPIER.RigidBody>
	rigidBodyB: Writable<RAPIER.RigidBody>
} = useFixedJoint(
	anchorA,  // Position
  frameA,   // Rotation
  anchorB,  // Position
  frameB    // Rotation
)
```


================================================
File: apps/docs/src/content/reference/rapier/use-joint.mdx
================================================
---
order: 12
category: '@threlte/rapier'
name: 'useJoint'
sourcePath: 'packages/rapier/src/lib/hooks/useJoint.ts'
type: 'hook'
---

Use this hook to initialize any [Rapier joint](https://rapier.rs/docs/user_guides/javascript/joints).

<Tip type="tip">
  This example initializes a `RevoluteImpulseJoint` manually. Most of the times you'd want to use a
  shortcut hook (like ['useRevoluteJoint'](/docs/reference/rapier/use-revolute-joint)) to initialize
  a joint. This hook is used internally to initialize the currently available joints.
</Tip>

```svelte
<script>
  import { useJoint, RigidBody, Collider } from '@threlte/rapier'

  const { joint, rigidBodyA, rigidBodyB } = useJoint((rbA, rbB, { world, rapier }) => {
    const params = rapier.JointData.revolute(
      { x: 0, y: 10, z: 1 },
      { x: 0, y: 0, z: 0 },
      { x: 0, y: 1, z: 0 }
    )
    return world.createImpulseJoint(params, rbA, rbB, true)
  })
</script>

<RigidBody bind:rigidBody={$rigidBodyA}>
  <Collider
    shape="cuboid"
    args={[1, 1, 1]}
  />
</RigidBody>

<RigidBody bind:rigidBody={$rigidBodyB}>
  <Collider
    shape="cuboid"
    args={[1, 1, 1]}
  />
</RigidBody>
```

The callback to initialize the Joint is called when both `rigidBodyA` and `rigidBodyB` are defined.

### Signature

```ts
const {
	joint: Writable<T>
	rigidBodyA: Writable<RAPIER.RigidBody>
	rigidBodyB: Writable<RAPIER.RigidBody>
} = useJoint<T extends RAPIER.ImpulseJoint | RAPIER.MultiBodyJoint>(
	initializeJoint: (rigidBodyA: RAPIER.RigidBody, rigidBodyB: RAPIER.RigidBody, RapierContext) => T
)
```


================================================
File: apps/docs/src/content/reference/rapier/use-physics-task.mdx
================================================
---
order: 8.1
category: '@threlte/rapier'
sourcePath: 'packages/rapier/src/lib/hooks/usePhysicsTask.ts'
name: 'usePhysicsTask'
type: 'hook'
---

This hook acts just like the `useTask` hook, but automatically adds the handler
to the `simulation` stage and always runs _before_ the `simulationTask`, so
before the physics world is stepped.

Depending on your [choice of framerate](/docs/reference/rapier/framerate) the
provided callback will be called differently:

### Varying Framerate

When you're using a varying framerate for your physics simulation, the hook
essentially behaves like a regular `useTask` with the benefit that it's added to
the physics stage automatically and is guaranteed to run _before_ the physics
world is stepped.

```svelte
<World framerate="varying">
```

```ts
usePhysicsTask((delta) => {
  console.log(delta) // ~0.016
})
```

### Fixed Framerate

When you're using a fixed framerate for your physics simulation, the callback
will be called with the fixed delta time between frames.

```svelte
<World framerate={200}>
```

```ts
usePhysicsTask((delta) => {
  console.log(delta) // 0.005
})
```


================================================
File: apps/docs/src/content/reference/rapier/use-prismatic-joint.mdx
================================================
---
order: 16
category: '@threlte/rapier'
sourcePath: 'packages/rapier/src/lib/hooks/usePrismaticJoint.ts'
name: 'usePrismaticJoint'
type: 'hook'
---

Use this hook to initialize a [`PrismaticImpulseJoint`](https://rapier.rs/docs/user_guides/javascript/joints#prismatic-joint).

```svelte
<script>
  import { usePrismaticJoint, RigidBody, Collider } from '@threlte/rapier'

  const { joint, rigidBodyA, rigidBodyB } = usePrismaticJoint({ x: 1 }, {}, { y: 1 }, [0, 1])
</script>

<RigidBody bind:rigidBody={$rigidBodyA}>
  <Collider
    shape="cuboid"
    args={[1, 1, 1]}
  />
</RigidBody>

<RigidBody bind:rigidBody={$rigidBodyB}>
  <Collider
    shape="cuboid"
    args={[1, 1, 1]}
  />
</RigidBody>
```

### Signature

```ts
const {
	joint: Writable<PrismaticImpulseJoint>
	rigidBodyA: Writable<RAPIER.RigidBody>
	rigidBodyB: Writable<RAPIER.RigidBody>
} = usePrismaticJoint(
	anchorA,  // Position
  anchorB,  // Position
  axis,     // Rotation
  limits    // [min, max] | undefined
)
```


================================================
File: apps/docs/src/content/reference/rapier/use-rapier.mdx
================================================
---
order: 8
category: '@threlte/rapier'
sourcePath: 'packages/rapier/src/lib/hooks/useRapier.ts'
name: 'useRapier'
type: 'hook'
---

This hook provides access to the underlying `RAPIER.World` as well as the means to add and remove colliders and rigid bodies from the events system.

```svelte
<script>
  import { useRapier } from '@threlte/rapier'

  const { world } = useRapier()

  const noGravity = () => (world.gravity = { x: 0, y: 0, z: 0 })
  const normalGravity = () => (world.gravity = { x: 0, y: 9.81, z: 0 })
</script>
```

### Types

```ts
// type RapierContext
const {
  rapier, // RAPIER
  world, // RAPIER.World
  colliderObjects, // Map<number, Object3D<Event>>
  rigidBodyObjects, //Map<number, Object3D<Event>>
  rigidBodyEventDispatchers, //RigidBodyEventDispatchers
  colliderEventDispatchers, //ColliderEventDispatchers
  addColliderToContext, // (collider: Collider, object: Object3D<Event>, eventDispatcher: ColliderEventDispatcher) => void
  removeColliderFromContext, // (collider: Collider) => void
  addRigidBodyToContext, // (rigidBody: RigidBody, object: Object3D<Event>, eventDispatcher: RigidBodyEventDispatcher) => void
  removeRigidBodyFromContext // (rigidBody: RigidBody) => void
} = useRapier()
```


================================================
File: apps/docs/src/content/reference/rapier/use-revolute-joint.mdx
================================================
---
order: 14
category: '@threlte/rapier'
sourcePath: 'packages/rapier/src/lib/hooks/useRevoluteJoint.ts'
name: 'useRevoluteJoint'
type: 'hook'
---

Use this hook to initialize a [`RevoluteImpulseJoint`](https://rapier.rs/docs/user_guides/javascript/joints#revolute-joint).

```svelte
<script>
  import { useRevoluteJoint, RigidBody, Collider } from '@threlte/rapier'

  const { joint, rigidBodyA, rigidBodyB } = useRevoluteJoint({ x: 1 }, {}, { y: 1 })
</script>

<RigidBody bind:rigidBody={$rigidBodyA}>
  <Collider
    shape="cuboid"
    args={[1, 1, 1]}
  />
</RigidBody>

<RigidBody bind:rigidBody={$rigidBodyB}>
  <Collider
    shape="cuboid"
    args={[1, 1, 1]}
  />
</RigidBody>
```

### Signature

```ts
const {
	joint: Writable<RevoluteImpulseJoint>
	rigidBodyA: Writable<RAPIER.RigidBody>
	rigidBodyB: Writable<RAPIER.RigidBody>
} = useRevoluteJoint(
	anchorA,  // Position
  anchorB,  // Position
  axis,     // Rotation
  limits    // [min, max] | undefined
)
```


================================================
File: apps/docs/src/content/reference/rapier/use-rigid-body.mdx
================================================
---
order: 10
category: '@threlte/rapier'
sourcePath: 'packages/rapier/src/lib/hooks/useRigidBody.ts'
name: 'useRigidBody'
type: 'hook'
---

This hook provides access to the `RAPIER.RigidBody` from a parent [`<RigidBody>`](/docs/reference/rapier/rigid-body) component.

Use this hook to e.g. add custom colliders to a `RAPIER.RigidBody` defined by a parent `<RigidBody>` component.

```svelte
<script>
  import { useRapier, useRigidBody } from '@threlte/rapier'

  const { world } = useRapier()

  // rigidBody is undefined if there's
  // no parent `<RigidBody>` component
  const rigidBody = useRigidBody()

  const collider = world.createCollider(colliderDesc, rigidBody)

  onDestroy(() => {
    world.removeCollider(collider, true)
  })
</script>
```

### Types

```ts
const rigidBody = useRigidBody() // RAPIER.RigidBody | undefined
```


================================================
File: apps/docs/src/content/reference/rapier/use-rope-joint.mdx
================================================
---
order: 14
category: '@threlte/rapier'
sourcePath: 'packages/rapier/src/lib/hooks/useRopeJoint.ts'
name: 'useRopeJoint'
type: 'hook'
---

<Example path="rapier/joints/rope/basic" />

Use this hook to initialize a `RopeImpulseJoint`. A rope joint limits the max
distance between two bodies.

```svelte
<script>
  import { useRopeJoint, RigidBody, Collider } from '@threlte/rapier'

  const { joint, rigidBodyA, rigidBodyB } = useRopeJoint({ x: 1 }, { y: 1 }, 2)
</script>

<RigidBody bind:rigidBody={$rigidBodyA}>
  <Collider
    shape="cuboid"
    args={[1, 1, 1]}
  />
</RigidBody>

<RigidBody bind:rigidBody={$rigidBodyB}>
  <Collider
    shape="cuboid"
    args={[1, 1, 1]}
  />
</RigidBody>
```

### Signature

```ts
const {
	joint: Writable<RopeImpulseJoint>
	rigidBodyA: Writable<RAPIER.RigidBody>
	rigidBodyB: Writable<RAPIER.RigidBody>
} = useRopeJoint(
	anchorA,  // Position
  anchorB,  // Position
	length    // Length of the rope
)
```


================================================
File: apps/docs/src/content/reference/rapier/use-spherical-joint.mdx
================================================
---
order: 15
category: '@threlte/rapier'
name: 'useSphericalJoint'
sourcePath: 'packages/rapier/src/lib/hooks/useSphericalJoint.ts'
type: 'hook'
---

Use this hook to initialize a [`SphericalImpulseJoint`](https://rapier.rs/docs/user_guides/javascript/joints#spherical-joint).

```svelte
<script>
  import { useSphericalJoint, RigidBody, Collider } from '@threlte/rapier'

  const { joint, rigidBodyA, rigidBodyB } = useSphericalJoint({ x: 1 }, { x: -1 })
</script>

<RigidBody bind:rigidBody={$rigidBodyA}>
  <Collider
    shape="cuboid"
    args={[1, 1, 1]}
  />
</RigidBody>

<RigidBody bind:rigidBody={$rigidBodyB}>
  <Collider
    shape="cuboid"
    args={[1, 1, 1]}
  />
</RigidBody>
```

### Signature

```ts
const {
	joint: Writable<SphericalImpulseJoint>
	rigidBodyA: Writable<RAPIER.RigidBody>
	rigidBodyB: Writable<RAPIER.RigidBody>
} = useSphericalJoint(
	anchorA,  // Position
  anchorB,  // Position
)
```


================================================
File: apps/docs/src/content/reference/rapier/world.mdx
================================================
---
order: 1
category: '@threlte/rapier'
sourcePath: 'packages/rapier/src/lib/components/World/World.svelte'
name: '<World>'
type: 'component'
componentSignature:
  {
    props:
      [
        { name: 'gravity', type: 'Position', default: '{ y: -9.81 }', required: false },
        { name: 'rawIntegrationParameters', type: 'RawIntegrationParameters', required: false },
        { name: 'rawIslands', type: 'RawIslandManager', required: false },
        { name: 'rawBroadPhase', type: 'RawBroadPhase', required: false },
        { name: 'rawNarrowPhase', type: 'RawNarrowPhase', required: false },
        { name: 'rawBodies', type: 'RawRigidBodySet', required: false },
        { name: 'rawColliders', type: 'RawColliderSet', required: false },
        { name: 'rawImpulseJoints', type: 'RawImpulseJointSet', required: false },
        { name: 'rawMultibodyJoints', type: 'RawMultibodyJointSet', required: false },
        { name: 'rawCCDSolver', type: 'RawCCDSolver', required: false },
        { name: 'rawQueryPipeline', type: 'RawQueryPipeline', required: false },
        { name: 'rawPhysicsPipeline', type: 'RawPhysicsPipeline', required: false },
        { name: 'rawSerializationPipeline', type: 'RawSerializationPipeline', required: false },
        { name: 'rawDebugRenderPipeline', type: 'RawDebugRenderPipeline', required: false }
      ]
  }
---

This component provides the basic physics context and loads [rapier](https://rapier.rs/).

<Tip type="tip">
	All components that rely on physics (e.g. `<RigidBody>` or `<Collider>`) must be a child of `<World>`.
</Tip>

## Structure

A typical structure of a physics-enabled wrapper component might look like this:

```svelte title="Wrapper.svelte"
<script lang="ts">
  import { Canvas } from '@threlte/core'
  import { World } from '@threlte/rapier'
  import Scene from './Scene.svelte'
</script>

<Canvas>
  <World>
    <Scene />
    <!-- Everything is happening inside this component -->
  </World>
</Canvas>
```

This structure ensures that all components inside the component `<Scene>` have access to the physics context.

## Fallback

[rapier](https://rapier.rs/) is a Rust-based physics engine and as such bundled and used as a WASM module. If loading of rapier fails for any reason, a slot with the name `fallback` is mounted to e.g. display a fallback scene without physics.

```svelte title="Wrapper.svelte"
<script lang="ts">
  import { Canvas } from '@threlte/core'
  import { World } from '@threlte/rapier'
  import Scene from './Scene.svelte'
  import FallbackScene from './FallbackScene.svelte'
</script>

<Canvas>
  <World>
    <Scene />
    {#snippet fallback()}
      <FallbackScene />
    {/snippet}
  </World>
</Canvas>
```


================================================
File: apps/docs/src/content/reference/studio/advanced.mdx
================================================
---
category: '@threlte/studio'
name: Advanced
order: 100
isDivider: true
---


================================================
File: apps/docs/src/content/reference/studio/authoring-extensions.mdx
================================================
---
order: 101
category: '@threlte/studio'
name: 'Authoring Extensions'
---

_All_ Studio functionality is provided by **Studio Extensions**. To make the
Studio suit your workflow, you may add your own Studio Extensions which may add
toolbar items, custom panes, have access to the scene and may access the state
of other extensions and run their actions.

<Tip type="warning">
  While it's technically possible to access and extend the Studio from anywhere within your app,
  it's highly recommended to follow this pattern to easily remove the Studio **including all
  extensions** from your app in production.
</Tip>

## Example

Let's create a simple extension that increments and decrements a counter.

### Extension Directory Structure

In its simplest form, an extension consists of a single Svelte file. If you're
using TypeScript, you can define the types for the extension state and actions
in a separate file. Additionally, you can create a hook to interact with the
extension from outside and define the public API.

```plaintext
extensions/
  my-extension/
    MyExtension.svelte
    (types.ts)
    (useMyExtension.ts)
```

### (Optional) Type Definitions

This file provides type definitions for the extension state and actions.

```ts title="types.ts"
export const extensionScope = 'my-extension'

export type ExtensionState = {
  enabled: boolean
  count: number
}

export type ExtensionActions = {
  setEnabled: (enabled: boolean) => void
  toggleEnabled: () => void
  increment: () => void
  decrement: () => void
}
```

### Svelte Extension File

This file implements the extension. Furthermore, it has full access to the Threlte app.

```svelte title="MyExtension.svelte"
<script lang="ts">
  import {
    useStudio,
    ToolbarItem,
    HorizontalButtonGroup,
    ToolbarButton
  } from '@threlte/studio/extend'
  import { extensionScope, type ExtensionState, type ExtensionActions } from './types'

  const { createExtension } = useStudio()

  const extension = createExtension<ExtensionState, ExtensionActions>({
    scope: extensionScope,
    state({ persist }) {
      return {
        enabled: persist(true),
        count: persist(0)
      }
    },
    actions: {
      toggleEnabled({ state }) {
        state.enabled = !state.enabled
      },
      setEnabled({ state }, enabled) {
        state.enabled = enabled
      },
      increment({ state }) {
        state.count++
      },
      decrement({ state }) {
        state.count--
      }
    },
    keyMap({ shift }) {
      return {
        increment: shift('+'),
        decrement: shift('-')
      }
    }
  })
</script>

<!-- Extension UI -->
<ToolbarItem position="left">
  <HorizontalButtonGroup>
    <ToolbarButton
      label="Decrement"
      icon="mdiMinus"
      on:click={extension.decrement}
      tooltip="Decrement (-)"
    />
    <ToolbarButton
      label="Increment"
      icon="mdiPlus"
      on:click={extension.increment}
      tooltip="Increment (+)"
    />
  </HorizontalButtonGroup>
</ToolbarItem>

<slot />
```

<Tip type="warning">Extensions must include a slot element to render the scene.</Tip>

Let's look at creating the extension step by step:

1. Every extension is created using the `createExtension` function. If you're
   using TypeScript, you should provide the types for the extension state and
   actions.

```ts
createExtension<ExtensionState, ExtensionActions>({
```

2. An extension is registered with a unique scope (i.e. a string). This scope is
   used to identify the extensions state and actions.

```ts
  scope: extensionScope,
```

3. The `state` function is used to define the initial state of the extension.
   The `persist` function is used to automatically persist the state of the
   extension across sessions.

```ts
  state({ persist }) {
    return {
      enabled: persist(true),
      count: persist(0)
    }
  },
```

4. To mutate the state of the extension, you must define actions. Actions are
   functions that receive the extension state and can mutate it.

```ts
  actions: {
    toggleEnabled({ state }) {
      state.enabled = !state.enabled
    },
    setEnabled({ state }, enabled) {
      state.enabled = enabled
    },
    increment({ state }) {
      state.count++
    },
    decrement({ state }) {
      state.count--
    }
  },
```

5. You can define key mappings for the extension. Key mappings are used to
   trigger actions when a key combination is pressed. Key modifiers (`shift`,
   `alt`, `ctrl`, `meta`) are provided as arguments to the `keyMap` function,
   and they can be combined. The key mappings are defined as an object where the
   keys are the action names and the values are the key combinations.

```ts
  keyMap({ shift }) {
    return {
      increment: shift('+')
      decrement: shift('-')
    }
  }
```

### (Optional) Hook

This file exposes a hook to interact with the extension. It should be the only
way to interact with the extension and defines the public API that can be used
by other extensions.

```ts title="useMyExtension.ts"
import { useStudio } from '@threlte/studio/extend'
import { extensionScope, type ExtensionState, type ExtensionActions } from './types'

export const useMyExtension = () => {
  const { useExtension } = useStudio()

  const extension = useExtension<ExtensionState, ExtensionActions>(extensionScope)

  return {
    get enabled() {
      return extension.state.enabled
    },
    get count() {
      return extension.state.count
    },
    setEnabled: extension.setEnabled,
    toggleEnabled: extension.toggleEnabled,
    increment: extension.increment,
    decrement: extension.decrement
  }
}
```

### Usage

Adding the extension to the Studio is as simple as importing the extension file
and passing it to the `Studio` component.

```svelte
<script lang="ts">
  import { Canvas } from '@threlte/core'
  import { Studio } from '@threlte/studio'
  import MyExtension from './MyExtension.svelte'
</script>

<Canvas>
  <Studio extensions={[MyExtension]}>
    <Scene />
  </Studio>
</Canvas>
```


================================================
File: apps/docs/src/content/reference/studio/components.mdx
================================================
---
category: '@threlte/studio'
name: Components
order: 5
isDivider: true
---


================================================
File: apps/docs/src/content/reference/studio/deploying-to-production.mdx
================================================
---
order: 1
category: '@threlte/studio'
name: 'Deploying To Production'
---

## Common Pattern

Typically you would want to remove the Studio from your app in production. This
can be done by wrapping the Studio component in a conditional statement that
checks if the app is in development mode:

```svelte title=App.svelte
<script>
  import { Canvas } from '@threlte/core'
  import Scene from './Scene.svelte'
</script>

<Canvas>
  {#if import.meta.env.MODE === 'development'}
    {#await import('@threlte/studio') then { Studio }}
      <Studio>
        <Scene />
      </Studio>
    {/await}
  {:else}
    <Scene />
  {/if}
</Canvas>
```

This way, the Studio will only be included in your app when it is in
[development mode](https://vitejs.dev/guide/env-and-mode.html#modes).

### Vite Plugin

The Threlte Studio vite plugin is only enabled in development mode.


================================================
File: apps/docs/src/content/reference/studio/extensions.mdx
================================================
---
order: 200
category: '@threlte/studio'
name: Extensions
isDivider: true
---


================================================
File: apps/docs/src/content/reference/studio/getting-started.mdx
================================================
---
order: 0
category: '@threlte/studio'
name: 'Getting Started'
---

Threlte Studio is a **spatial programming toolset**.

It consists of two main parts: A GUI to inspect and edit your scene and a
vite plugin to sync the changes in real-time to your code. It is made to be
[extendable](./authoring-extensions), so you can create your own custom
components to interact with your scene and hook into the Threlte Studio API and
GUI.

<Example
  path="studio/getting-started"
  hideStackblitz
  hideCode
  previewClass="!aspect-[4/3.2] !h-auto"
/>

### Installation

```bash copy
npm install @threlte/studio
```

### Quick Start

To get started, encapsulate your whole scene in the [`<Studio>`](./studio) component.

```svelte title=App.svelte {3,8,10}+
<script lang="ts">
  import { Canvas } from '@threlte/core'
  import { Studio } from '@threlte/studio'
  import Scene from './Scene.svelte'
</script>

<Canvas>
  <Studio>
    <Scene />
  </Studio>
</Canvas>
```

To use auto-sync, in your vite config, insert the Threlte Studio vite plugin
**before any other plugin**.

```js title=vite.config.js {2}+ {5}m
import { sveltekit } from '@sveltejs/kit/vite'
import { threlteStudio } from '@threlte/studio/vite'

export default {
  plugins: [threlteStudio(), sveltekit()]
}
```


================================================
File: apps/docs/src/content/reference/studio/static-state.mdx
================================================
---
category: '@threlte/studio'
name: Static State
order: 101
---

Extend the `StaticState` class to create a new class that holds scene
configuration or any other static values **that won't change in production**
(i.e. are _static_). Properties added within such a class are automatically
integrated into the Studio UI, allowing for **easy manipulation and
visualization**. Changes to these properties will **automatically be reflected
in the scene** and **written back to the disk**.

<Tip type="info">
  This feature is available for classes defined in `*.svelte`, `*.svelte.ts` and `*.svelte.js`
  files.
</Tip>

For example, you can create a class `SceneConfig` that extends `StaticState` and
define various properties like `directionalLightIntensity`,
`ambientLightIntensity`, `color`, `opacity`, and `showBox`. These properties will then be
available in the Studio UI for configuration.

Here is an example:

```ts
class SceneConfig extends StaticState {
  /**
   * @min 0
   * @max 10
   * @step 0.1
   */
  directionalLightIntensity = $state(3.1)
  /**
   * @min 0
   * @max 1
   */
  ambientLightIntensity = $state(0.13)
  color = $state('#fe3d00')
  /**
   * @min 0
   * @max 1
   */
  opacity = $state(1)
  showBox = $state(true)
}
```

Using it in your scene yields the following UI:

<Example
  path="studio/static-state"
  hideStackblitz
  showFile="Scene.svelte"
/>

## Example

### Scenario

You want to create a scene that hosts three objects and you want to dial in the
gap between the objects.

```svelte title="Scene.svelte"
<script>
  import Icosahedron from './Icosahedron.svelte'
  import Sphere from './Sphere.svelte'
  import Box from './Box.svelte'
</script>

<Icosahedron position={[-2, 0, 0]} />
<Sphere position={[0, 0, 0]} />
<Box position={[2, 0, 0]} />
```

### Implementation

#### Create a State Container

Create a new class `SceneConfig` that extends `StaticState` and define a
`gap` property. It must use `$state` to be reactive in order for the
changes to be reflected in the scene.

```svelte title="Scene.svelte" {2,7-9}+
<script>
  import { StaticState } from '@threlte/studio'
  import Icosahedron from './Icosahedron.svelte'
  import Sphere from './Sphere.svelte'
  import Box from './Box.svelte'

  class SceneConfig extends StaticState {
    gap = $state(1.5)
  }
</script>

<Icosahedron position={[-2, 0, 0]} />
<Sphere position={[0, 0, 0]} />
<Box position={[2, 0, 0]} />
```

#### Create an Instance

Create a new instance of `SceneConfig` and use it to update the position of the
objects.

```svelte title="Scene.svelte" {11}+ {14-18}m
<script>
  import { StaticState } from '@threlte/studio'
  import Icosahedron from './Icosahedron.svelte'
  import Sphere from './Sphere.svelte'
  import { StaticState } from '@threlte/studio'

  class SceneConfig extends StaticState {
    gap = $state(1.5)
  }

  const sceneConfig = new SceneConfig()
</script>

<Icosahedron position={[-sceneConfig.gap, 0, 0]} />
<Sphere position={[0, 0, 0]} />
<Box position={[sceneConfig.gap, 0, 0]} />
```

#### Bonus: Use UI Modifiers

To tweak the resulting UI, you can use JSDoc tags to add modifiers. For example,
you can add `@min` and `@max` to the `gap` property to restrict the range of
values that can be entered. This will yield a slider in the Studio UI.

```ts {2-5}+
class SceneConfig extends StaticState {
  /**
   * @min 1.5
   * @max 5
   */
  gap = $state(2)
}
```

You're done! Changes to the `gap` property in the Studio UI will automatically be
reflected in the scene and written back to the disk.

<Example
  path="studio/static-state-gap"
  hideStackblitz
  showFile="Scene.svelte"
/>


================================================
File: apps/docs/src/content/reference/studio/studio.mdx
================================================
---
order: 6
category: '@threlte/studio'
sourcePath: 'packages/studio/src/lib/components/Studio/Studio.svelte'
name: '<Studio>'
type: 'component'
componentSignature:
  {
    props:
      [
        {
          name: 'extensions',
          type: { name: 'SvelteComponent[]', url: './authoring-extensions' },
          required: false
        },
        { name: 'transient', type: 'boolean', required: false, default: 'false' },
        {
          name: 'namespace',
          type: 'boolean',
          required: false,
          default: "'default'",
          description: 'The namespace to use for persisting the Studio state such as the editor camera position or the working space. Useful if you work on more than one Threlte app in the same origin.'
        }
      ]
  }
---


================================================
File: apps/docs/src/content/reference/studio/use-object-selection.mdx
================================================
---
order: 201
category: '@threlte/studio'
sourcePath: 'packages/studio/src/lib/extensions/object-selection/useObjectSelection.svelte.ts'
name: 'useObjectSelection'
type: 'hook'
---

## Examples

```ts
import { useObjectSelection } from '@threlte/studio/extensions'

const selection = useObjectSelection()

// select an object
selection.selectObjects([object])

// select multiple objects
selection.selectObjects([object1, object2])

// clear the selection
selection.clearSelection()

// add an object to the selection
selection.addToSelection(object)

// remove an object from the selection
selection.removeFromSelection(object)

// toggle the selection of an object
selection.toggleSelection([object])

// toggle the selection of multiple objects
selection.toggleSelection([object1, object2])

// get the selected objects
console.log(selection.selectedObjects) // [object1, object2]
```


================================================
File: apps/docs/src/content/reference/studio/use-snapping.mdx
================================================
---
order: 205
category: '@threlte/studio'
sourcePath: 'packages/studio/src/lib/extensions/snapping/useSnapping.svelte.ts'
name: 'useSnapping'
type: 'hook'
---

## Examples

```ts
import { useSnapping } from '@threlte/studio/extensions'

const snapping = useSnapping()

// enable snapping
snapping.setEnabled(true)

// toggle snapping
snapping.toggleEnabled()

// set the translate snapping value
snapping.setTranslate(10)

// set the rotate snapping value
snapping.setRotate(15)

// set the scale snapping value
snapping.setScale(0.1)

// get the enabled state
console.log(snapping.enabled) // true

// get the translate snapping value
console.log(snapping.translate) // 10

// get the rotate snapping value
console.log(snapping.rotate) // 15

// get the scale snapping value
console.log(snapping.scale) // 0.1
```


================================================
File: apps/docs/src/content/reference/studio/use-space.mdx
================================================
---
order: 204
category: '@threlte/studio'
sourcePath: 'packages/studio/src/lib/extensions/space/useSpace.ts'
name: 'useSpace'
type: 'hook'
---

## Examples

```ts
import { useSpace } from '@threlte/studio/extensions'

const space = useSpace()

// toggle the working space
space.toggleSpace()

// set the working space to local
space.setSpace('local')

// set the working space to world
space.setSpace('world')

// get the working space
console.log(space.space) // 'world'
```


================================================
File: apps/docs/src/content/reference/studio/use-studio-objects-registry.mdx
================================================
---
order: 202
category: '@threlte/studio'
sourcePath: 'packages/studio/src/lib/extensions/studio-objects-registry/useStudioObjectsRegistry.svelte.ts'
name: 'useStudioObjectsRegistry'
type: 'hook'
---

## Examples

```ts
import { useStudioObjectsRegistry } from '@threlte/studio/extensions'

const registry = useStudioObjectsRegistry()

// get all currently registered studio objects
console.log(registry.objects)

// add a studio object to the registry
registry.addObject(object)

// remove a studio object from the registry
registry.removeObject(object)

// check if an object is or is a child of a studio object
console.log(registry.isOrIsChildOfStudioObject(object)) // true | false
```

### Creating a studio object reference

```svelte
<script lang="ts">
  import { useStudioObjectsRegistry } from '@threlte/studio/extensions'

  const registry = useStudioObjectsRegistry()
  const studioObject = registry.studioObjectRef()
</script>

<T.Mesh bind:ref={studioObject.ref} />
```


================================================
File: apps/docs/src/content/reference/studio/use-transactions.mdx
================================================
---
order: 203
category: '@threlte/studio'
sourcePath: 'packages/studio/src/lib/extensions/transactions/useTransactions.ts'
name: 'useTransactions'
type: 'hook'
---

## Examples

```ts
import { useTransactions } from '@threlte/studio/extensions'

const transactions = useTransactions()

// convenience method for building a transaction
const transaction = transactions.buildTransaction({
  object: mesh,
  propertyPath: 'material.color',
  value: 'red',
  createHistoryRecord: true,
  sync: true
})

// commit a set of changes to the transaction queue
transactions.commit([
  transaction,
  {
    object: mesh,
    write: (object, value) => {
      object.position.set(value[0], value[1], value[2])
    },
    read(root) {
      return root.position.toArray()
    },
    value: [1, 2, 3],
    createHistoryRecord: true
  }
])

// undo the last transaction
transactions.undo()

// redo the last transaction
transactions.redo()

// subscribe to events
transactions.onTransaction(() => {
  // called when a transaction is committed, undone, or redone
  console.log('transaction')
})
transactions.onCommit(() => {
  // called when a transaction is committed
  console.log('commit')
})
transactions.onUndo(() => {
  // called when a transaction is undone
  console.log('undo')
})
transactions.onRedo(() => {
  // called when a transaction is redone
  console.log('redo')
})

// Clean up subscriptions
const unsubscribe = transactions.onTransaction(() => {
  /* ... */
})
unsubscribe()

// open the editor for the given object
transactions.openInEditor(mesh)

// open the editor for the selected object
transactions.openSelectedInEditor()

// check if the Vite plugin is enabled
transactions.vitePluginEnabled // true
```


================================================
File: apps/docs/src/content/reference/studio/use-transform-controls.mdx
================================================
---
order: 206
category: '@threlte/studio'
sourcePath: 'packages/studio/src/lib/extensions/transform-controls/useTransformControls.ts'
name: 'useTransformControls'
type: 'hook'
---

## Examples

```ts
import { useTransformControls } from '@threlte/studio/extensions'

const tc = useTransformControls()

// Enable the transform controls
tc.enable()

// Disable the transform controls
tc.disable()

// Toggle the transform controls
tc.toggle()

// Set the mode of the transform controls
tc.setMode('translate') // 'translate', 'rotate', 'scale'

// Translate the object
tc.translate()

// Rotate the object
tc.rotate()

// Scale the object
tc.scale()

// check if the transform controls are in use
console.log(tc.inUse)

// get the current mode
console.log(tc.mode)
```


================================================
File: apps/docs/src/content/reference/theatre/actions.mdx
================================================
---
order: 7
category: '@threlte/theatre'
name: 'actions'
isDivider: true
---


================================================
File: apps/docs/src/content/reference/theatre/components.mdx
================================================
---
order: 1
category: '@threlte/theatre'
name: 'Components'
isDivider: true
---


================================================
File: apps/docs/src/content/reference/theatre/declare.mdx
================================================
---
order: 4.4
category: '@threlte/theatre'
sourcePath: 'packages/theatre/src/lib/sheetObject/declare/Declare.svelte'
name: '<Declare>'
type: 'component'
componentSignature:
  {
    props:
      [
        {
          name: props,
          type:
            {
              name: 'UnknownShorthandCompoundProps',
              url: 'https://www.theatrejs.com/docs/latest/manual/prop-types'
            },
          required: true
        }
      ]
  }
---

Sometimes we want our declarations to be closer to the place where we use them.

Use the component `<Declare>` to from the [`<SheetObject>`](./sheet-object) slot prop to colocate
an object and its properties with manual property declaration.

```svelte
<SheetObject>
  {#snippet children({ Declare })}
    <Declare props={{ transparent: false }}>
      {#snippet children({ values })}
        <T.MeshBasicMaterial transparent={values.transparent} />
      {/snippet}
    </Declare>
  {/snippet}
</SheetObject>
```

<Tip type="tip">
  This can also be used to pass the prop declaration API to child components using a slot prop.
</Tip>


================================================
File: apps/docs/src/content/reference/theatre/getting-started.mdx
================================================
---
order: 0
category: '@threlte/theatre'
name: 'Getting Started'
---

[Theatre.js](https://www.theatrejs.com/) is a javascript animation library with a professional motion design toolset. It helps you create any animation, from cinematic scenes in 3D, to delightful UI interactions.

### Concepts

As with the rest of Threlte, `@threlte/theatre` provides an idiomatic yet transparent Svelte wrapper. The core concepts of `@threlte/theatre` are:

| @threlte/theatre Component        | Description                                                             | Corresponding Theatre.js Concept(s)                                                                                                                                                           |
| --------------------------------- | ----------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [\<Project\>](./project)          | Contains your project's animation sheets                                | [Project](https://www.theatrejs.com/docs/latest/manual/projects)                                                                                                                              |
| [\<Sheet\>](./sheet)              | Binds to an animation _sheet_ that contains animation sequences         | [Sheet](https://www.theatrejs.com/docs/latest/manual/sheets)                                                                                                                                  |
| [\<Sequence\>](./sequence)        | Binds to an animation _sequence_ and contains the animated components   | [Sequence](https://www.theatrejs.com/docs/latest/manual/sequences)                                                                                                                            |
| [\<Studio\>](./studio)            | Enables the Theatre.js in-browser studio _interface_ during development | [Studio](https://www.theatrejs.com/docs/latest/manual/Studio)                                                                                                                                 |
| [\<SheetObject\>](./sheet-object) | Enables editing and animating its parent in the studio interface        | [Sheet Object](https://www.theatrejs.com/docs/latest/manual/objects)                                                                                                                          |
| [\<Theatre\>](./theatre)          | A helper component providing a project with a single sheet and a studio | [Project](https://www.theatrejs.com/docs/latest/manual/projects), [Sheet](https://www.theatrejs.com/docs/latest/manual/sheets), [Studio](https://www.theatrejs.com/docs/latest/manual/Studio) |

The `@threlte/theatre` documentation cross-references [the Theatre.js documentation](https://www.theatrejs.com/docs/latest), allowing you to get a deeper understanding of the underlying concepts.

### Workflow

Theatre.js combines programming in your IDE with editing in a browser-based GUI. The core workflow looks something like this:

1. **Create** your scene as usual, placing a `<Project>` and one or more `<Sheets>` in your `<Canvas>`.
2. **Identify** the elements and props you wish to edit in the `<Studio>`, and place an `<SheetObject>` component around them, then use the slotted components `<Sync>`, `<Declare>` or `<Transform>` to add editable props.
3. **Edit** props and animations of elements in the `<Studio>` in the browser; [config state](https://www.theatrejs.com/docs/latest/manual/projects#state) is autosaved to local storage.
4. **Export** the updated state [as a JSON file](https://www.theatrejs.com/docs/latest/manual/projects#state) by selecting your project in the studio and clicking export (top-right corner).
5. **Import** your scene's `state.json` and use it in your `<Project>`'s `config` prop.

### Installation

```bash copy
npm install @threlte/theatre @theatre/core @theatre/studio
```

### Quick Start

To get started quickly, encapsulate your whole scene in the component [`<Theatre>`](./theatre).

<Tip type="tip">
  The component `<Theatre>` provides a default [`<Project>`](/theatre/project) and [`<Sheet>`](/theatre/sheet) and implements [`<Studio>`](/theatre/studio). For a more flexible structure please consider using `<Project>`, `<Sheet>` and `<Studio>` on their own.
</Tip>

```svelte title=App.svelte {3,8,10}+
<script lang="ts">
  import { Canvas } from '@threlte/core'
  import { Theatre } from '@threlte/theatre'
  import Scene from './Scene.svelte'
</script>

<Canvas>
  <Theatre>
    <Scene />
  </Theatre>
</Canvas>
```

In your Scene, add the component `<SheetObject>` as a parent of any component you'd wish to edit or animate. The component `<SheetObject>` provides the components `<Sync>`, `<Declare>` and `<Transform>` that allow you to manipulate properties in Theatre.js based on your Threlte markup.

<Tip type="tip">
  The component `<Transform>` is a shortcut to add `position`, `scale` and `rotation` at once as
  well as mount handy `<TransformControls>` whenever the respective Sheet Object is selected in the studio.
</Tip>

```svelte title=Scene.svelte
<script lang="ts">
  import { T } from '@threlte/core'
  import { OrbitControls } from '@threlte/extras'
  import { SheetObject } from '@threlte/theatre'
</script>

<T.PerspectiveCamera
  position={[0, 5, 10]}
  makeDefault
>
  <OrbitControls target={{ y: 1.5 }} />
</T.PerspectiveCamera>

<!-- Box -->
<SheetObject key="Box">
  {#snippet children({ Transform, Sync })}
    <Transform>
      <T.Mesh
        receiveShadow
        castShadow
        position.y={0.5}
      >
        <T.BoxGeometry args={[1, 1, 1]} />
        <T.MeshStandardMaterial color="#b00d03">
          <Sync
            color
            roughness
            metalness
          />
        </T.MeshStandardMaterial>
      </T.Mesh>
    </Transform>
  {/snippet}
</SheetObject>
```

You will now see the Theatre.js studio interface. Make yourself comfortable with the controls and if you haven't done yet, please read the Theatre.js [studio manual](https://www.theatrejs.com/docs/0.5/manual/Studio) and [keyboard shortcuts](https://www.theatrejs.com/docs/0.5/manual/keyboard-shortcuts).


================================================
File: apps/docs/src/content/reference/theatre/hooks.mdx
================================================
---
order: 6
category: '@threlte/theatre'
name: 'hooks'
isDivider: true
---


================================================
File: apps/docs/src/content/reference/theatre/project.mdx
================================================
---
order: 1.2
category: '@threlte/theatre'
sourcePath: 'packages/theatre/src/lib/project/Project.svelte'
name: '<Project>'
type: 'component'
componentSignature:
  {
    props:
      [
        {name: 'name', type: 'string', default: 'default', required: false},
        {name: 'config', type: 'IProjectConfig', required: false},
      ],
	bindings:
	  [
	    {name: 'project', type: 'IProject'},
		{name: 'isReady', type: 'boolean'},
	  ]
  }
---

Theatre.js work is organized into projects that group animation [\<Sheet\>](./sheet)s.

Projects also provide the means to inject configuration state exported as a JSON file from the [\<Studio\>](./studio) back into your code through a prop: `<Project config={{ state }}>`.

While multiple projects may be created, one is usually sufficient for a whole Threlte application.

#### Theatre.js Docs

| &nbsp;      | &nbsp;                                                                  | &nbsp;                                                                          |
| ----------- | ----------------------------------------------------------------------- | ------------------------------------------------------------------------------- |
| **Project** | [Project Manual](https://www.theatrejs.com/docs/latest/manual/projects) | [Project API Reference](https://www.theatrejs.com/docs/latest/api/core#project) |

### Creating a Project

```svelte
<script>
  import { Project, Sheet, SheetObject } from '@threlte/theatre'
</script>

<!-- Will create a project with the name "Project A" -->
<Project name="Project A">
  <Sheet name="Sheet A">
    <SheetObject key="ObjectA" />
  </Sheet>
</Project>
```

### Loading a Saved State

The state of a project edited in the [\<Studio\>](./studio) is saved in your browser's local storage, and can be [exported from within the studio interface](https://www.theatrejs.com/docs/latest/manual/projects#state). It's a JSON file containing all animated and static properties of all sheets of the project.

```svelte
<script>
  import { Project, Sheet, SheetObject } from '@threlte/theatre'
  import state from './state.json'
</script>

<!--
	Will create a project with the name "Project A",
	load its state and mount all children when
	finished loading
-->
<Project
  config={{ state }}
  name="Project A"
>
  <Sheet
    name="Sheet A"
    autoplay
  >
    <SheetObject key="ObjectA" />
  </Sheet>
</Project>
```


================================================
File: apps/docs/src/content/reference/theatre/sequence.mdx
================================================
---
order: 1.4
category: '@threlte/theatre'
name: '<Sequence>'
sourcePath: 'packages/theatre/src/lib/sequence/Sequence.svelte'
type: 'component'
componentSignature:
  {
    props:
      [
        {
          name: 'rate',
          type: 'number',
          default: '1',
          required: false,
          description: 'Set the speed of playback (Theatre.js)'
        },
        {
          name: 'range',
          type: '[number, number] | undefined',
          default: '[0, length]',
          required: false,
          description: 'Choose what part of the animation is played (Theatre.js)'
        },
        {
          name: 'iterationCount',
          type: 'number',
          default: '1',
          required: false,
          description: 'Control how often the animation is played. Set Infinity to keep looping (Theatre.js)'
        },
        {
          name: 'direction',
          type: '"normal" | "reverse" | "alternate" | "alternateReverse"',
          default: 'normal',
          required: false,
          description: 'Choose the direction of animation playback (Theatre.js)'
        },
        {
          name: 'autoplay',
          type: 'boolean',
          default: 'false',
          required: false,
          description: 'Choose whether to automatically play the animation when the component is mounted (Threlte)'
        },
        {
          name: 'delay',
          type: 'number',
          default: '0',
          required: false,
          description: 'When using autoplay, how many milliseconds to wait before starting playback (Threlte)'
        },
        {
          name: 'autoreset',
          type: '"always" | "onMount" | "onDestroy" | undefined',
          default: 'undefined',
          required: false,
          description: 'Reset the playhead when the component is mounted, unmounted**, both or neither (Threlte)'
        },
        {
          name: 'autopause',
          type: 'boolean',
          default: 'false',
          required: false,
          description: 'Whether to pause playback when the component is unmounted (Threlte)'
        },
        {
          name: 'audio',
          type: "{source: AudioBuffer; audioContext: AudioContext; destinationNode: AudioContext['destination'];}",
          default: '{}',
          required: false,
          description: 'Syncronize an audio track to the sequence; see the audio section below (Theatre.js)'
        }
      ],
    bindings:
      [
        { name: 'position', type: 'number | undefined' },
        {
          name: play,
          type: '(opts?) => Promise<boolean> (see Theatre.js Sequence API docs for options)'
        },
        { name: pause, type: '() => void' },
        { name: sequence, type: 'ISequence' },
        { name: sheet, type: 'ISheet' }
      ]
  }
---

Sequences are the heart of the Theatre.js animation system. The sequence represents the animation timeline and provides an API for controlling its playback.
In Threlte 7, you can reactively control animations through the `<Sequence>` component, which you place inside a [`<Sheet>`](/docs/reference/theatre/sheet).

Currently, you can only have one sequence in each sheet. Future versions of Theatre.js are expected to support multisequence sheets.

#### Theatre.js Docs

| &nbsp;       | &nbsp;                                                                    | &nbsp;                                                                         |
| ------------ | ------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| **Sequence** | [Sequence Manual](https://www.theatrejs.com/docs/latest/manual/sequences) | [Sequence API Reference](https://www.theatrejs.com/docs/0.5/api/core#sequence) |

## Usage

The following example shows how `<Sequence>` can be used to build a simple playback controller.

<Example path="theatre/sequence" />

## Lifecycle

Threlte provides lifecycle props to allow you to configure how the sequence playback is connected to the Svelte component lifecycle. See the `autoplay`, `autoreset` and `autopause` props below.

Note that the underlying Theatre.js sheets are persisted even when unmounting a `<Sheet>` component. That's why the sequence doesn't reset automatically when unmounting a `<Sheet>`, and why the `autoreset` options is required.

## Audio

The audio options allow you to attach a soundtrack to your animation sequence. Theatre.js achieves this using the [Web Audio API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API). For more details, see [audio manual](https://www.theatrejs.com/docs/0.5/manual/audio) and [attach audio API reference](https://www.theatrejs.com/docs/0.5/api/core#sequence.attachaudio_opts_)

## Snippet Prop

When using the sequence in a child component, a snippet prop can come in handy.

```svelte
<script lang="ts">
  import { T } from '@threlte/core'
  import { Sheet, Sequence, SheetObject } from '@threlte/theatre'
</script>

<Sheet>
  <Sequence>
    {#snippet children({ play })}
      <SheetObject key="Cube">
        {#snippet children({ Transform })}
          <Transform>
            <T.Mesh onclick={play}>
              <T.BoxGeometry />
              <T.MeshStandardMaterial />
            </T.Mesh>
          </Transform>
        {/snippet}
      </SheetObject>
    {/snippet}
  </Sequence>
</Sheet>
```


================================================
File: apps/docs/src/content/reference/theatre/sheet-object-action.mdx
================================================
---
order: 7.1
category: '@threlte/theatre'
name: 'sheetObjectAction'
sourcePath: 'packages/theatre/src/lib/sheet/createSheetObjectAction.ts'
---

When Theatre.js represents the animated elements on a page as **Sheet Objects** which have _props_ you can animate. A Sheet Object can be a ThreeJS element or a DOM element.

The `createSheetObjectAction` hook allows you to animate DOM elements through a Svelte Action.

#### Theatre.js Docs

| &nbsp;           | &nbsp;                                                                       | &nbsp;                                                                                 |
| ---------------- | ---------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- |
| **Sheet Object** | [Sheet Object Manual](https://www.theatrejs.com/docs/latest/manual/objects)  | [Sheet Object API Reference](https://www.theatrejs.com/docs/0.5/api/core#sheet.object) |
| **Prop Types**   | [Prop Types Manual](https://www.theatrejs.com/docs/latest/manual/prop-types) | [Prop Types API reference](https://www.theatrejs.com/docs/0.5/api/core#prop-types)     |

## Usage

This hook must be initialized inside a child component of `<Sheet>`:

```svelte
// Scene.svelte
<script lang="ts">
  import { createSheetObjectAction, useSequence } from '@threlte/theatre'

  const sheetObjectAction = createSheetObjectAction()
</script>

<div
	use:sheetObjectAction={{
		key: 'foo',
		props: { width: 230 },
		callback: {node, { width }} => {
			node.style.width = `${width}px`;
		}
	}}
>
	I Am Animated!
</div>
```

Where the parent component looks something like this:

```svelte
<script lang="ts">
  import { Project, Sheet, Sequence, Studio } from '@threlte/theatre'

  import Scene from './Scene.svelte'
  import state from './state.json'
</script>

// App.svelte
<Project config={{ state }}>
  <Sheet>
    <Sequence />
    <Scene />
  </Sheet>
</Project>
```

This is because under the hood we must first retrieve the _sheet context_ so we can instantiate the object in it.

### Example

<Example path="theatre/action-sheet-object" />

## Action

The action takes the following arguments:

| arg      | type                                      | description                                                                                                                                                                                                    |
| -------- | ----------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| key      | string                                    | The key of the object, shown in the studio UI (may be [namespaced with slashes](https://www.theatrejs.com/docs/latest/manual/objects#namespacing-objects))                                                     |
| props    | Props                                     | Declaration of your props and their types (see Theatre.js [manual entry](https://www.theatrejs.com/docs/latest/manual/prop-types) and [API reference](https://www.theatrejs.com/docs/0.5/api/core#prop-types)) |
| callback | (node: HTMLElement, props: Props) => void | A callback function called to update the HTMLElement node whenever the prop changes.                                                                                                                           |


================================================
File: apps/docs/src/content/reference/theatre/sheet-object-section.mdx
================================================
---
order: 4
category: '@threlte/theatre'
name: 'Sheet Object'
isDivider: true
---


================================================
File: apps/docs/src/content/reference/theatre/sheet-object.mdx
================================================
---
order: 4.1
category: '@threlte/theatre'
sourcePath: 'packages/theatre/src/lib/sheetObject/SheetObject.svelte'
name: '<SheetObject>'
type: 'component'
componentSignature:
  {
    props:
      [
        { name: 'key', type: 'string', required: true },
        {
          name: props,
          type:
            {
              name: 'UnknownShorthandCompoundProps',
              url: 'https://www.theatrejs.com/docs/latest/manual/prop-types'
            },
          required: false
        },
        { name: 'detach', type: 'boolean', required: false, default: 'false' }
      ]
  }
---

The `<SheetObject>` component allows you to pool the properties of a **logical entity** which can be a anything from a single material, multiple meshes or a complete scene. The component `<SheetObject>` and
make them editable and animatable in the Theatre.js studio. It's a great choice if you are making a reusable Threlte component which
you want to make editable in the Theatre.js studio.

#### Theatre.js Docs

| &nbsp;           | &nbsp;                                                                      | &nbsp;                                                                              |
| ---------------- | --------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| **Sheet Object** | [Sheet Object Manual](https://www.theatrejs.com/docs/latest/manual/objects) | [Sheet Object API Reference](https://www.theatrejs.com/docs/latest/api/core#object) |

## Overview

The `<SheetObject>` component offers several distinct ways to declare and syncronize props in the Theatre.js studio. Convenient [auto prop APIs](#auto-props) address common usecases and allow
quick and easy prop declaration. Meanwhile, [manual props APIs](#manual-prop) allow full customization of prop declaration. Many of these are offered through [slot props](https://svelte.dev/docs/special-elements#slot-slot-key-value).

<Example path="theatre/sheet-object" />

## Auto Props

The [`<Sync>`](./sync) component automatically infers and synchronizes props of its parent component. Meanwhile the [`<Transform>`](./transform) component creates position and rotation props for its
child components, and adds transform controls to the them.

## Manual Props

Sometimes we want to control prop declaration manually for better control when implementing custom domain
specific props. We can achieve this using _manual prop declaration_. Provide the `props` property to the component
`<SheetObject>` for a manual property declaration.

```svelte
<SheetObject props={{ x: 0 }}>
  {#snippet children({ values })}
    <T.Mesh position.x={values.x} />
  {/snippet}
</SheetObject>
```

You can also use the [`<Declare>`](./declare) prop slot component to colocate your manual declaration with other code.

## Selection

The `<SheetObject>` component offers a slot prop based API for controlling selection in the Theatre.js studio. Simply
declare the `select` and `deselect` methods and the `selected` variables to use it. You then need to use these in the
mesh of your choice; see the example above for a demonstration.


================================================
File: apps/docs/src/content/reference/theatre/sheet.mdx
================================================
---
order: 1.3
category: '@threlte/theatre'
name: '<Sheet>'
sourcePath: 'packages/theatre/src/lib/sheet/Sheet.svelte'
type: 'component'
componentSignature:
  {
    props:
      [
        { name: 'name', type: 'string', default: 'default', required: false },
        { name: 'instance', type: 'string | undefined', default: 'undefined', required: false }
      ],
    bindings: [{ name: project, type: 'IProject' }, { name: sheet, type: 'ISheet' }]
  }
---

Theatre.js sheets contain one or more Theatre.js objects and optionally a [`<Sequence>`](/docs/reference/theatre/sequence) component that allows controlling the animation.
The animated objects can adjusted in the [`<Studio>`](/docs/reference/theatre/studio) using the [`<Editable>`](/docs/reference/theatre/editable) component.

#### Theatre.js Docs

| &nbsp;    | &nbsp;                                                              | &nbsp;                                                                   |
| --------- | ------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| **Sheet** | [Sheet Manual](https://www.theatrejs.com/docs/latest/manual/sheets) | [Sheet API Reference](https://www.theatrejs.com/docs/0.5/api/core#sheet) |

## Creating Sheets

You can create a sheet by placing the component `<Sheet>` as a child of a [`<Project>`](/theatre/project) component. If a sheet with the given name already exists, it will represent the existing sheet instead of creating a new one.

```svelte
<script>
  import { Project, Sheet, SheetObject } from '@threlte/theatre'
</script>

<Project>
  <!-- Will create a sheet with the name "Sheet A" -->
  <Sheet name="Sheet A">
    <SheetObject key="ObjectA" />
  </Sheet>

  <!-- Will create a sheet with the name "Sheet B" -->
  <Sheet name="Sheet B">
    <SheetObject key="ObjectB" />
  </Sheet>

  <!-- Will NOT create a sheet but reference "Sheet A" -->
  <Sheet name="Sheet A">
    <SheetObject key="ObjectC" />
  </Sheet>
</Project>
```

## Playing a Sheet's animation

Each Theatre.js sheet has a sequence attached to it. The sequence is the heart of the Theatre.js API: it determines where we are in the animation timeline, and
provides and API to play and pause the animation in a variety of ways.

#### Using the `<Sequence>` component

The first way to control the sequence is using a reactive API with the [`<Sequence>`](/docs/reference/theatre/sequence) component.

#### Using the `useSequence` hook

xxx


================================================
File: apps/docs/src/content/reference/theatre/studio.mdx
================================================
---
order: 1.5
category: '@threlte/theatre'
sourcePath: 'packages/theatre/src/lib/studio/Studio.svelte'
name: '<Studio>'
type: 'component'
componentSignature:
  { props: [{ name: 'enabled', type: 'boolean', default: 'true', required: false }] }
---

The `<Studio>` component enables the Theatre.js studio interface in your browser. It is intended for use in development.

See the Theatre.js docs for extended instructions for using the studio interface.

#### Theatre.js Docs

| &nbsp;     | &nbsp;                                                               | &nbsp;                                                                                       | &nbsp;                                                                   |
| ---------- | -------------------------------------------------------------------- | -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| **Studio** | [Studio Manual](https://www.theatrejs.com/docs/latest/manual/Studio) | [Studio keyboard Shortcuts](https://www.theatrejs.com/docs/latest/manual/keyboard-shortcuts) | [Studio API Reference](https://www.theatrejs.com/docs/latest/api/studio) |

### Example

In most cases, you want the interface while editing animations or laying out scenes. While other parts of Theatre.js are performant and built for production, `@theatre/studio` is currently not, and shouldn't be included in your production bundle.

```svelte
<script lang="ts">
  import { Canvas } from '@threlte/core'
  import { Studio } from '@threlte/theatre'
  import Scene from './Scene.svelte'

  // Using SvelteKit
  import { dev } from '$app/environment'
</script>

<Studio enabled={dev} />

<Canvas>
  <Scene />
</Canvas>
```

### Exporting State

When editing your project in the studio, state is automatically saved to your browser's local storage. To export the state, select your project from the outline panel (top-left) and click the export in the details panel (top-right). For more information and a video, see [the Theatre.js state docs](https://www.theatrejs.com/docs/latest/manual/projects#state).


================================================
File: apps/docs/src/content/reference/theatre/sync.mdx
================================================
---
order: 4.2
category: '@threlte/theatre'
sourcePath: 'packages/theatre/src/lib/sheetObject/sync/Sync.svelte'
name: '<Sync>'
type: 'component'
componentSignature: { props: [{ name: type, type: 'any', required: false }] }
---

Use the component `<Sync>` from the [`<SheetObject>`](./sheet-object) slot prop to automatically pick up properties from its parent.

```svelte
<SheetObject>
  {#snippet children({ Sync })}
    <T.MeshBasicMaterial>
      <Sync
        color
        roughness
        rotation
      />
    </T.MeshBasicMaterial>
  {/snippet}
</SheetObject>
```

<Tip type="info">
  #### Special Properties Note that some properties are treated differently. The `rotation` prop and
  other properties with type `THREE.Euler` are automatically converted from radians to degrees.
  Properties like `color` which have a type of `THREE.Color` receive a color picker in the studio
  automatically.
</Tip>

## Labeled Prop

To label an auto prop, just provide a string instead of a boolean value.

```svelte
<script>
  import { T } from '@threlte/core'
  import { SheetObject } from '@threlte/theatre'
</script>

<SheetObject key="cube">
  {#snippet children({ Sync })}
    <T.Mesh>
      <T.BoxGeometry />
      <T.MeshStandardMaterial>
        <!-- labeled prop: rename color to tone in the studio -->
        <Sync color="tone" />
      </T.MeshStandardMaterial>
    </T.Mesh>
  {/snippet}
</SheetObject>
```

## Pierced Prop

Similarly to the pierced props of [`<T>`](/docs/reference/core/t), the props of the component `<Sync>` can be anotated in the same fashion.

```svelte
<script>
  import { T } from '@threlte/core'
  import { SheetObject } from '@threlte/theatre'
</script>

<SheetObject key="cube">
  {#snippet children({ Sync })}
    <T.Mesh>
      <!-- pierced prop: edit only x coord. in the studio -->
      <Sync position.x />
      <T.BoxGeometry />
      <T.MeshStandardMaterial />
    </T.Mesh>
  {/snippet}
</SheetObject>
```

## Transformers

The component `<Sync>` uses transformers to provide the best possible editing
experience in the Theatre.js studio based on the type of the property. Sometimes
this is not desireable and you may want to go further. One example is the
property `intensity` on lights. By default, it's a regular numerical input, but
in practice it makes sense to have a range slider that lets you select numbers from 0 to e.g. 10.

To create a transformer that can be reused, you are provided a utility function:

```ts
import { createTransformer } from '@threlte/theatre'
import { types } from '@theatre/core'

const intensity = createTransformer({
  transform(value) {
    return types.number(value, {
      range: [0, 10]
    })
  },
  apply(target, path, value) {
    target[path] = value
  }
})
```

The `transform` function is used to transform the value of a certain Three.js objects proerty to a property that Theatre.js can use in an `ISheetObject`. To ensure compatibility with the rest of the package, the return value must be any one of the functions available at Theatre.js' `types`.

The `apply` function is used to apply the value to the target. `target` is the parent object of the property (usually a Three.js object), `path` is the name of the property and `value` is the value to apply.

You may also declare transformers directly in the markup:

```svelte
<script>
  import { T } from '@threlte/core'
  import { SheetObject } from '@threlte/theatre'
  import { createTransformer, types } from '@threlte/theatre'
</script>

<SheetObject key="light">
  {#snippet children({ Sync })}
    <T.DirectionalLight>
      <Sync
        intensity={{
          transformer: {
            transform(value) {
              // use the initial value and provide a range
              // slider UI that goes from 0 to 2.
              return types.number(value, {
                range: [0, 2]
              })
            },
            apply(target, path, value) {
              // whenever the value changes, apply it back
              // to the target.
              target[path] = value
            }
          }
        }}
      />
    </T.DirectionalLight>
  {/snippet}
</SheetObject>
```

<Tip type="info" title="Built-in components use transformers internally">

`<Sync>` uses transformers to transform arbitrary props that are _discovered_ by a property path to a value that Theatre.js can handle.
`<Transform>` uses transformers to transform the properties `position`, `rotation` and `scale` of a Three.js object to a value that Theatre.js can handle.

</Tip>


================================================
File: apps/docs/src/content/reference/theatre/theatre.mdx
================================================
---
order: 1.1
category: '@threlte/theatre'
name: '<Theatre>'
sourcePath: 'packages/theatre/src/lib/theatre/Theatre.svelte'
type: 'component'
componentSignature:
  {
    props:
      [
        {
          name: 'studio',
          type: '{ enabled?: boolean, hide?: boolean }',
          default: '{}',
          required: false
        },
        { name: 'config', type: 'IProjectConfig', required: false }
      ]
  }
---

The component `<Theatre>` is a convenience shortcut and provides a default `<Project>` and `<Sheet>` to get you set up as fast as possible. It also includes a `<Studio>` which can be disabled with the property `studio`: `<Theatre studio={false} />`

### Example

The component `<Theatre>` is a good choice if you want to test the waters or to quickly spin up an experiment.

```svelte
<script lang="ts">
  import { Canvas, T } from '@threlte/core'
  import { SheetObject, Theatre } from '@threlte/theatre'
</script>

<Canvas>
  <Theatre>
    <SheetObject key="Camera">
      {#snippet children({ Transform })}
        <Transform>
          <T.PerspectiveCamera
            makeDefault
            position={[5, 10, 3]}
          />
        </Transform>
      {/snippet}
    </SheetObject>

    <SheetObject key="Cube">
      {#snippet children({ Transform })}
        <Transform>
          <T.Mesh position.y={0.5}>
            <T.BoxGeometry />
            <T.MeshBasicMaterial color="hotpink" />
          </T.Mesh>
        </Transform>
      {/snippet}
    </SheetObject>

    <T.GridHelper />
  </Theatre>
</Canvas>
```


================================================
File: apps/docs/src/content/reference/theatre/transform.mdx
================================================
---
order: 4.3
category: '@threlte/theatre'
sourcePath: 'packages/theatre/src/lib/sheetObject/transform/Transform.svelte'
name: '<Transform>'
type: 'component'
componentSignature:
  {
    props:
      [
        { name: 'label', type: 'string', required: false },
        { name: 'key', type: 'string', required: false },
        { name: 'mode', type: 'translate | rotate | scale', required: false, default: 'translate' },
        { name: 'space', type: 'world | local', required: false, default: 'world' },
        { name: 'translationSnap', type: 'number', required: false },
        { name: 'rotationSnap', type: 'number', required: false },
        { name: 'scaleSnap', type: 'number', required: false }
      ]
  }
---

One of the most common usecases in the studio is repositioning objects or groups of objects in the canvas.

Use the component `<Transform>` from the [`<SheetObject>`](./sheet-object) slot props to add the transform properties of an object to the sheet object.

```svelte
<SheetObject>
  {#snippet children({ Transform, Sync })}
    <Transform>
      <T.Mesh />
    </Transform>
  {/snippet}
</SheetObject>
```


================================================
File: apps/docs/src/content/reference/theatre/use-sequence.mdx
================================================
---
order: 6.3
category: '@threlte/theatre'
sourcePath: 'packages/theatre/src/lib/sequence/useSequence.ts'
name: 'useSequence'
---

The `useSequence` hook allows you to access a sequence's playback controls using a store API.

## Usage

The hook can be used within the [`<Sheet>`](/docs/reference/theatre/sheet) context or withing the [`<Sequence>`](/docs/reference/theatre/sequence) context:

```svelte
<!-- child of a <Sheet> or <Sequence> -->
<script lang="ts">
  import { useSequence } from '@threlte/theatre'
  const { position, playing, length, play, pause, config } = useSequence()
</script>
```

### Example

This example uses the `useSequence` hook to allow you to control the feather's animation using the feather itself. Hover will pause the animation and clicking and dragging the feather up and down allow you to wind back and forth in time.

<Example path="theatre/use-sequence" />

## Output

The following values are returned by the hook:

| store    | type                                           | description                                                |
| -------- | ---------------------------------------------- | ---------------------------------------------------------- |
| length   | number                                         | The length of the sequence, which is set within the studio |
| position | Writable\<number\>                             | The sequence playhead position                             |
| playing  | Writable\<boolean\>                            | The sequence state (playing or paused)                     |
| play     | (opts?: SequenceOptions) => Promise\<boolean\> | Method for playing the sequence                            |
| pause    | () => void                                     | Method for pausing the sequence                            |
| config   | (opts: SequenceOptions) => void                | Method for updating the sequence's options                 |


================================================
File: apps/docs/src/content/reference/theatre/use-studio.mdx
================================================
---
order: 6.2
category: '@threlte/theatre'
name: 'useStudio'
sourcePath: 'packages/theatre/src/lib/studio/useStudio.ts'
---

The `useStudio` hook allows you to access the Theatre.js studio object.

## Usage

Unlike most Threlte hooks, this is _not_ a context hook, which means it can be used anywhere in your app.

```svelte
<script lang="ts">
  import { useStudio } from '@threlte/theatre'
  const studio = useStudio()
</script>
```


================================================
File: apps/docs/src/content/reference/xr/button-ar.mdx
================================================
---
category: '@threlte/xr'
name: '<ARButton>'
order: 2
type: 'component'
componentSignature:
  {
    events:
      [
        {
          name: 'click',
          payload: "CustomEvent<'unsupported' | 'insecure' | 'blocked' | 'supported'>",
          description: 'Fired when a user clicks the VR button.'
        },
        {
          name: 'error',
          payload: 'CustomEvent<Error>',
          description: 'Fired when an enter / exit session error occurs.'
        }
      ]
  }
---

`<ARButton />` is an HTML `<button />` that can be used to init an AR session. It will also display info about browser support.


================================================
File: apps/docs/src/content/reference/xr/button-vr.mdx
================================================
---
category: '@threlte/xr'
name: '<VRButton>'
order: 1.5
type: 'component'
componentSignature:
  {
    events:
      [
        {
          name: 'click',
          payload: "CustomEvent<'unsupported' | 'insecure' | 'blocked' | 'supported'>",
          description: 'Fired when a user clicks the VR button.'
        },
        {
          name: 'error',
          payload: 'CustomEvent<Error>',
          description: 'Fired when an enter / exit session error occurs.'
        }
      ]
  }
---

`<VRButton />` is an HTML `<button />` that can be used to init a VR session. It will also display info about browser support.

<Example path="xr/vr-button" />


================================================
File: apps/docs/src/content/reference/xr/button-xr.mdx
================================================
---
category: '@threlte/xr'
name: '<XRButton>'
order: 2
type: 'component'
componentSignature:
  {
    props:
      [
        {
          name: 'mode',
          type: "'inline' | 'immersive-vr' | 'immersive-ar'",
          required: true,
          description: 'The type of XRSession to create.'
        },
        {
          name: 'sessionInit',
          type: 'XRSessionInit',
          required: false,
          description: 'XRSession configuration options.'
        },
        {
          name: 'force',
          type: "'enter' | 'exit'",
          required: false,
          description: 'Whether this button should only enter / exit an `XRSession`. Default is to toggle both ways'
        }
      ],
    events:
      [
        {
          name: 'click',
          payload: "CustomEvent<'unsupported' | 'insecure' | 'blocked' | 'supported'>",
          description: 'Fired when a user clicks the VR button.'
        },
        {
          name: 'error',
          payload: 'CustomEvent<Error>',
          description: 'Fired when an enter / exit session error occurs.'
        }
      ]
  }
---

`<XRButton />` is an HTML `<button />` that can be used to init a WebXR session. It will also display info about XR session browser support.

This is aliased by the more commonly used `ARButton` and `VRButton` which provide sensible session defaults.


================================================
File: apps/docs/src/content/reference/xr/components.mdx
================================================
---
category: '@threlte/xr'
name: Components
order: -0.5
isDivider: true
---


================================================
File: apps/docs/src/content/reference/xr/controller.mdx
================================================
---
category: '@threlte/xr'
name: '<Controller>'
order: 2
type: 'component'
componentSignature:
  {
    events:
      [
        {
          name: 'connected',
          payload: "XRControllerEvent<'connected'>",
          description: 'Fired when the controller connects.'
        },
        {
          name: 'disconnected',
          payload: "XRControllerEvent<'disconnected'>",
          description: 'Fired when the controller disconnects.'
        },
        {
          name: 'select',
          payload: "XRControllerEvent<'select'>",
          description: 'Fired when a the user has completed a primary action.'
        },
        {
          name: 'selectstart',
          payload: "XRControllerEvent<'selectstart'>",
          description: 'Fired when a the user begins a primary action.'
        },
        {
          name: 'selectend',
          payload: "XRControllerEvent<'selectend'>",
          description: 'Fired when a the user ends a primary action or when the controller that is in the process of handling an ongoing primary action is disconnected without successfully completing the action.'
        },
        {
          name: 'squeeze',
          payload: "XRControllerEvent<'squeeze'>",
          description: 'Fired when the controller has completed a primary squeeze action.'
        },
        {
          name: 'squeezestart',
          payload: "XRControllerEvent<'squeezestart'>",
          description: 'Fired when the user begins a primary squeeze action.'
        },
        {
          name: 'squeezeend',
          payload: "XRControllerEvent<'squeezeend'>",
          description: 'Fired when a the user ends a primary squeeze action or when the controller that is in the process of handling an ongoing primary squeeeze action is disconnected without successfully completing the action.'
        }
      ]
  }
---

`<Controller />` represents a `THREE.XRTargetRaySpace`, a `THREE.XRGripSpace`, and a controller model for a specified hand.

```svelte
<Controller left />
<Controller right />
```

It will by default load a controller model that attempts to match the physical controller.

<Tip type="warning">
  Default controller models are fetched from the immersive web group's [webxr input profile
  repo](https://github.com/immersive-web/webxr-input-profiles). If you are developing an offline
  app, you should download and provide any anticipated models.
</Tip>

`<Controller>` can accept three snippets.

If a children snippet is provided, the default controller model will not be rendered, and will be replaced with the children content.

```svelte {2-5}+
<Controller left>
  <T.Mesh>
    <T.IcosahedronGeometry args={[0.2]} />
    <T.MeshStandardMaterial color="turquoise" />
  </T.Mesh>
</Controller>
```

Two additional snippets exist to place children in the controller's [grip space](https://developer.mozilla.org/en-US/docs/Web/API/XRInputSource/gripSpace) and the controller's [target ray space](https://developer.mozilla.org/en-US/docs/Web/API/XRInputSource/targetRaySpace).

```svelte
<Controller left>
  {#snippet grip()}
    <T.Mesh>
      <T.IcosahedronGeometry args={[0.2]} />
      <T.MeshStandardMaterial color="hotpink" />
    </T.Mesh>
  {/snippet}

  {#snippet targetRay()}
    <T.Mesh>
      <T.IcosahedronGeometry args={[0.2]} />
      <T.MeshStandardMaterial color="orange" />
    </T.Mesh>
  {/snippet}
</Controller>
```

<Example path="xr/controller" />


================================================
File: apps/docs/src/content/reference/xr/controls.mdx
================================================
---
category: '@threlte/xr'
name: Controls
order: 3
isDivider: true
---


================================================
File: apps/docs/src/content/reference/xr/getting-started.mdx
================================================
---
order: -2
category: '@threlte/xr'
name: Getting Started
---

The package `@threlte/xr` provides tools and abstractions to more easily create
VR and AR experiences.

## Installation

```bash title="Terminal"
npm install @threlte/xr
```

## Usage

<Tip type="experimental">
  `@threlte/xr` is in beta. Major API changes at this point are not expected, but some breaking
  changes may occur before it reaches 1.0.0.
</Tip>

### Setup

The following adds a button to start your session and controllers inside an XR
manager to prepare your scene for WebXR rendering and interaction.

```svelte title="Scene.svelte" {3,11}+
<script>
  import { Canvas } from '@threlte/core'
  import { VRButton } from '@threlte/xr'
  import Scene from './scene.svelte'
</script>

<Canvas>
  <Scene />
</Canvas>
<VRButton />
```

Then, in `scene.svelte`:

```svelte
<script>
  import { XR, Controller, Hand } from '@threlte/xr'
</script>

<XR />
<Controller left />
<Controller right />
<Hand left />
<Hand right />
```

This will set up your project to be able to enter a VR session with controllers
and hand inputs added.

If you want hands, controllers, or any other objects to be added to your
`THREE.Scene` only when the XR session starts, make them children of the `<XR>`
component:

```svelte
<script>
  import { XR, Controller, Hand } from '@threlte/xr'
</script>

<XR>
  <Controller left />
  <Controller right />
  <Hand left />
  <Hand right />
</XR>
```

The `<XR>`, `<Controller>`, and `<Hand>` components can provide a powerful
foundation when composed with other Threlte components.

For example, it doesn't take much more to get to the point of a simple
BeatSaber-inspired experience:

<Example path="xr/bonksaber" />

### HTML

HTML cannot be rendered inside an XR environment, this is just a limitation of
the WebXR API. An alternative approach for creating an HTML-like UI within your
XR session is to use the
[threlte-uikit](https://github.com/michealparks/threlte-uikit) package.


================================================
File: apps/docs/src/content/reference/xr/hand.mdx
================================================
---
category: '@threlte/xr'
name: '<Hand>'
order: 2
type: 'component'
componentSignature:
  {
    events:
      [
        {
          name: 'connected',
          payload: "XRHandEvent<'connected', null>",
          description: 'Fired when the hand connects.'
        },
        {
          name: 'disconnected',
          payload: "XRHandEvent<'connected', null>",
          description: 'Fired when the hand disconnects.'
        },
        {
          name: 'pinchstart',
          payload: "XRHandEvent<'pinchstart', THREE.XRHandSpace>",
          description: 'Fired when a pinch gesture begins.'
        },
        {
          name: 'pinchend',
          payload: "XRHandEvent<'pinchend', THREE.XRHandSpace>",
          description: 'Fired when a pinch gesture ends.'
        }
      ]
  }
---

`<Hands />` instantiates [XRHand](https://developer.mozilla.org/en-US/docs/Web/API/XRHand) inputs for devices that allow hand tracking.

```svelte
<Hand left />
<Hand right />
```

It will by default load a hand model.

<Tip type="warning">
  Default hand models are fetched from the immersive web group's [webxr input profile
  repo](https://github.com/immersive-web/webxr-input-profiles). If you are developing an offline
  app, you should download and provide any anticipated models.
</Tip>

`<Hand>` can accept a snippet to replace the default model.

```svelte {2-5}+
<Hand left>
  <T.Mesh>
    <T.IcosahedronGeometry args={[0.2]} />
    <T.MeshStandardMaterial color="turquoise" />
  </T.Mesh>
</Hand>
```

A snippet, `wrist`, will place any children within the wrist space of the hand:

```svelte
<Hand left>
  {#snippet wrist()}
    <T.Mesh>
      <T.IcosahedronGeometry args={[0.2]} />
      <T.MeshStandardMaterial color="hotpink" />
    </T.Mesh>
  {/snippet}
</Hand>
```

To trigger reactive changes based on whether hand input is or is not present, the `useXR` hook provides a [`currentWritable`](https://localhost:4321/docs/reference/core/utilities#currentwritable) store:

```ts
const { isHandTracking } = useXR()
```

Hand tracking can serve as a powerful input device, as any joint position, and not just the wrist, can be read from in real time:

<Example path="xr/hands" />


================================================
File: apps/docs/src/content/reference/xr/headset.mdx
================================================
---
category: '@threlte/xr'
name: '<Headset>'
order: 2
type: 'component'
componentSignature: {}
---

`<Headset />` provides the ability to attach objects to the pose of the user's headset.

```svelte
<script>
  import { Headset } from '@threlte/xr'
  import { AudioListener } from '@threlte/extras'
</script>

<Headset>
  <AudioListener />
</Headset>
```

If you need to only read from the current headset pose, the [useHeadset](/docs/reference/xr/use-headset) hook is available.

Like a [Portal](/docs/reference/extras/portal), you can place it anywhere in your Threlte application.

`<Headset>` will sync position and rotation with the current camera when not in an immersive XR session.

<Example path="xr/headset" />


================================================
File: apps/docs/src/content/reference/xr/hooks.mdx
================================================
---
category: '@threlte/xr'
name: Hooks
order: 5
isDivider: true
---


================================================
File: apps/docs/src/content/reference/xr/pointer-controls.mdx
================================================
---
category: '@threlte/xr'
name: 'pointerControls'
order: 3
type: 'plugin'
---

The `pointerControls` plugin adds pointer events to an immersive XR session. This means that pointing at any mesh with your hand or a controller will trigger DOM-like pointer events.

To get started, import and call the plugin in a component within your app.

```svelte
<script>
  import { pointerControls } from '@threlte/xr'
  pointerControls('left' | 'right')
</script>
```

Any mesh **within this component and all child components** will now receive events if the controller or hand with the specified handedness points at it.

```svelte
<T.Mesh
  onclick={() => {
    console.log('clicked')
  }}
>
  <T.BoxGeometry />
  <T.MeshStandardMaterial color="red" />
</T.Mesh>
```

If you wish to add pointer controls for both hands / controllers, simply call the plugin for both hands.

```svelte
<script>
  import { pointerControls } from '@threlte/xr'
  pointerControls('left')
  pointerControls('right')
</script>
```

Pointer controls can be enabled or disabled when initialized or during runtime.

```svelte
<script>
  import { pointerControls } from '@threlte/xr'
  // "enabled" is a currentWritable
  const { enabled } = pointerControls('left', { enabled: false })

  // At some later time...
  enabled.set(true)
</script>
```

### Available Events

The following events are available:

```svelte
<T.Mesh
  onclick={(e) => console.log('click')}
  onpointerup={(e) => console.log('up')}
  onpointerdown={(e) => console.log('down')}
  onpointerover={(e) => console.log('over')}
  onpointerout={(e) => console.log('out')}
  onpointerenter={(e) => console.log('enter')}
  onpointerleave={(e) => console.log('leave')}
  onpointermove={(e) => console.log('move')}
/>
```

While a controller or hand is pointed at this mesh...

- `click` fires when a user selects the primary action input. This usually means pulling a primary trigger with a controller or pinching with a hand.
- `pointerdown` fires when a primary action begins, and `pointerup` fires when it ends.
- `pointerover` and `pointerout` fire when the ray of the pointing device is moved onto an object, or onto one of its children. It bubbles, meaning it can trigger on the object that the pointer is over or any of its ancestor objects.
- `pointerenter` and `pointerleave` fire when the ray of the pointing device enters / leaves the boundaries of an object, and does not bubble. It only triggers on the exact element the pointer has entered / left.

To replace the default ray and cursor that are created by the plugin, the following snippets can be added to a `<Controller>` or a `<Hand>`:

```svelte
<script>
  import { Hand, Controller } from '@threlte/xr'
  import CustomRay from './CustomRay.svelte'
  import CustomCursor from './CustomCursor.svelte'
</script>

<Controller left>
  {#snippet pointerRay()}
    <CustomRay>
  {/snippet}

  {#snippet pointerCursor()}
    <CustomCursor>
  {/snippet}
</Controller>
```

This plugin can be used with the `teleportControls` plugin to allow both teleporting and interaction.

```svelte
<script>
  import { pointerControls, teleportControls } from '@threlte/xr'
  teleportControls('left')
  pointerControls('right')
</script>
```

Since the default behavior of pointer and teleport controls have no overlap, they can be added to the same hand.

If these two plugins are added to the same hand, `pointerControls` will take over when pointing at a mesh with events, and `teleportControls` will take over otherwise.

`pointerControls` can also be used with `interactivity` to allow pointer events within and outside an immersive session.

```svelte
<script>
  import { interactivity } from '@threlte/extras'
  import { pointerControls, teleportControls } from '@threlte/xr'
  interactivity()
  pointerControls('left')
</script>
```

The will be a few subtle differences when events are fired within an immersive session:

- Pointers / cursors will be `THREE.Vector3`s instead of `THREE.Vector2`s. In XR, the cursor that intersects with the object that you interact with can be anywhere within a 3d space.
- There will be no `camera` property on the event, since raycasting will originate from hands or controllers.
- The `nativeEvent` property on event objects will be a `XRControllerEvent` or `XRHandEvent` rather than a `DomEvent`. In the case of hover events such as `pointerMove`, there will be no native event.

<Example path="xr/pointer-controls" />


================================================
File: apps/docs/src/content/reference/xr/teleport-controls.mdx
================================================
---
category: '@threlte/xr'
name: 'teleportControls'
order: 3
type: 'plugin'
---

The `teleportControls` plugin creates teleportation controls similar to many native XR experiences: **pressing the thumbstick forward** on a controller will create a visible ray to a teleport destination, and when the the thumbstick is released the user will be teleported to the end of the ray.

```svelte
<script>
  import { teleportControls } from '@threlte/xr'
  teleportControls('left' | 'right')
</script>
```

Any mesh **within this component and all child components** can now be treated as a navigation mesh to which the user can teleport to.

To register a mesh with `teleportControls`, add a `teleportSurface` property.

```svelte
<T.Mesh teleportSurface>
  <T.CylinderGeometry args={[20, 0.01]} />
  <T.MeshStandardMaterial />
</T.Mesh>
```

If you wish to add teleport controls for both hands / controllers, simply call the plugin for both hands.

```svelte
<script>
  import { teleportControls } from '@threlte/xr'
  teleportControls('left')
  teleportControls('right')
</script>
```

Teleport controls can be enabled or disabled when initialized or during runtime.

```svelte
<script>
  import { teleportControls } from '@threlte/xr'
  // "enabled" is a currentWritable
  const { enabled } = teleportControls('left', { enabled: false })

  // At some later time...
  enabled.set(true)
</script>
```

A mesh can also be registered as a `teleportBlocker`, meaning that it will prevent teleportation through it.
This can be useful when creating walls and doors that the user must navigate around.

```svelte
<T.Mesh teleportBlocker>
  <T.BoxGeometry args={[0.8, 2, 0.1]} />
  <T.MeshStandardMaterial />
</T.Mesh>
```

This plugin can be composed with the `teleportControls` plugin to allow both teleporting and interaction.

```svelte
<script>
  import { pointerControls, teleportControls } from '@threlte/xr'
  teleportControls('left')
  pointerControls('right')
</script>
```

This will result in `pointerControls` taking over when pointing at a mesh with events, and `teleportControls` taking over otherwise.

<Example path="xr/teleport-controls" />


================================================
File: apps/docs/src/content/reference/xr/use-controller.mdx
================================================
---
order: 15
category: '@threlte/xr'
name: 'useController'
type: 'hook'
---

Provides a reference to a current XRController, filtered by handedness.

```svelte
<script>
  import { useController } from '@threlte/xr'

  const leftController = useController('left')
  const rightController = useController('right')
  const gazeController = useController('gaze')
</script>
```

### Signature

```ts
// CurrentWritable<XRController | undefined> - The current XRController
const controller = useController('left')
```


================================================
File: apps/docs/src/content/reference/xr/use-hand-joint.mdx
================================================
---
order: 17
category: '@threlte/xr'
name: 'useHandJoint'
type: 'hook'
---

Provides a reference to a requested hand joint, once available.

```svelte
<script>
  import { useHandJoint } from '@threlte/xr'

  const wristJoint = useHandJoint('left', 'wrist')
</script>
```

Reading hand joint positions in real time can be very useful, for example in providing rigid bodies for hands:

<Example path="xr/use-hand-joint" />


================================================
File: apps/docs/src/content/reference/xr/use-hand.mdx
================================================
---
order: 16
category: '@threlte/xr'
name: 'useHand'
type: 'hook'
---

Provides a reference to a current XRHand, filtered by handedness.

```svelte
<script>
  import { useHand } from '@threlte/xr'

  const leftHand = useHand('left')
  const rightHand = useHand('right')
</script>
```

### Signature

```ts
// CurrentWritable<XRHand | undefined> - The current XRHand
const hand = useHand('left')
```


================================================
File: apps/docs/src/content/reference/xr/use-headset.mdx
================================================
---
order: 17
category: '@threlte/xr'
name: 'useHeadset'
type: 'hook'
---

Provides a reference to the user's headset pose.

```svelte
<script>
  import { useTask } from '@threlte/core'
  import { useHeadset } from '@threlte/xr'

  const headset = useHeadset()

  useTask(() => {
    // Read the current headset position and rotation.
    console.log(headset.position, headset.quaternion)
  })
</script>
```

If you would like to attach objects to the headset, the [`<Headset>`](/docs/reference/xr/headset) component is available.

### Signature

```ts
// THREE.Group - A group representing the headset pose.
const headset = useHeadset()
```


================================================
File: apps/docs/src/content/reference/xr/use-hit-test.mdx
================================================
---
order: 17
category: '@threlte/xr'
name: 'useHitTest'
type: 'hook'
---

Provides a [hit test result](https://developer.mozilla.org/en-US/docs/Web/API/XRHitTestResult) on each frame during an `immersive-ar` session.

Hit testing lets you position virtual items in a real-world view.

```svelte
<script>
  import { useHitTest } from '@threlte/xr'

  let ref

  useHitTest((hitMatrix, hit) => {
    if (!ref) return

    if (hit) {
      ref.visible = true
      ref.matrix.copy(hitMatrix)
    } else {
      ref.visible = false
    }
  })
</script>

<T.Mesh bind:ref>
  <T.SphereGeometry args={[0.1]}>
  <T.MeshBasicMaterial />
</T.Mesh>
```

This hook can optionally specify one of three origins from which to cast the hit test ray: `viewer` (the default), `leftInput` or `rightInput`.

```ts
useHitTest(
  (hitMatrix, hit) => {
    // Perform a hit test from the left controller or hand.
  },
  { source: 'leftInput' }
)
```

In the following example, hit testing is set up from both controllers and hands.

<Example path="xr/use-hit-test" />

### Signature

```ts
useHitTest((hitMatrix: THREE.Matrix4, hit: XRHitTestResult | undefined) => {})
```


================================================
File: apps/docs/src/content/reference/xr/use-teleport.mdx
================================================
---
order: 17
category: '@threlte/xr'
name: 'useTeleport'
type: 'hook'
---

Provides a function to teleport the player to a reference frame.

```svelte
<script>
  import { useTeleport } from '@threlte/xr'

  const teleport = useTeleport()
  const vec3 = new THREE.Vector3()

  vec3.set(5, 0, 5)

  teleport(vec3)
</script>
```

This function can be used within `useTask` for smooth movement.

```ts
useTask((delta) => {
  vec3.z += delta
  teleport(vec3)
})
```


================================================
File: apps/docs/src/content/reference/xr/use-xr.mdx
================================================
---
order: 14
category: '@threlte/xr'
name: 'useXR'
type: 'hook'
---

Provides context about the current WebXR session.

```svelte
<script>
  import { useXR } from '@threlte/xr'

  const { isPresenting, isHandTracking, session, xrFrame } = useXR()
</script>
```

### Signature

```ts
const {
  isPresenting, // CurrentWritable<boolean> - Whether the XR device is presenting in an XR session
  isHandTracking, // CurrentWritable<boolean> - Whether hand tracking inputs are active
  session, // CurrentWritable<XRSession | undefined> - The active `XRSession`
  xrFrame // CurrentWritable<XRFrame> - The current XRFrame
} = useXR()
```


================================================
File: apps/docs/src/content/reference/xr/xr.mdx
================================================
---
category: '@threlte/xr'
name: '<XR>'
order: 0
type: 'component'
componentSignature:
  {
    props:
      [
        {
          name: 'foveation',
          type: 'number',
          default: '1',
          required: false,
          description: 'Enables foveated rendering. 0 represents no foveation, full resolution. 1 represents maximum foveation, with the edges rendered at a lower resolution.'
        },
        {
          name: 'frameRate',
          type: 'number',
          required: false,
          description: 'The target framerate for the XRSystem. Recommended range is 72-120. Default is unset and left to the device. Smaller rates give more CPU headroom at the cost of responsiveness. If your experience cannot effectively reach the target framerate, it will be subject to frame reprojection which will halve the effective framerate. Choose a conservative estimate that balances responsiveness and headroom based on your experience.'
        },
        {
          name: 'referenceSpace',
          type: 'string',
          required: false,
          default: "'local-floor'",
          description: 'Type of WebXR reference space to use.'
        }
      ],
    events:
      [
        {
          name: 'sessionstart',
          payload: 'THREE.Event & { target: XRSession }',
          description: 'Fired as an XRSession is requested.'
        },
        {
          name: 'sessionend',
          payload: 'THREE.Event & { target: XRSession }',
          description: 'Fired after an XRSession is terminated.'
        },
        {
          name: 'visibilitychange',
          payload: 'THREE.Event & { target: XRSession }',
          description: 'Fired when an XRSession is hidden or unfocused.'
        },
        {
          name: 'inputsourceschange',
          payload: 'THREE.Event & { target: XRSession }',
          description: 'Fired when available inputsources change.'
        }
      ]
  }
---

The `<XR>` component prepares your scene for a WebXR session. It sets up context that is provided by the [`useXR`](/docs/reference/xr/use-xr) hook.

## Usage

```svelte
<script>
  import { XR } from '@threlte/xr'
  import { Text } from '@threlte/extras'
</script>

<XR>
  <Text
    position={[0, 1.6, -1]}
    text="I have entered another realm!"
  />
</XR>
```

<Tip type="warning">
  The `<XR>` component will set the [`<Canvas>`](/docs/reference/core/canvas) property `renderMode="always"` when the user enters an XR session, due to being incompatible with `on-demand` or `manual`. It will set the original value once the session has ended.
</Tip>

Any children of the `<XR>` component will not mount until the user enters an immersive session. This is useful for adding controllers, hands, or entire scenes that should only start when the user has begun their session.

## Fallback

XR sessions have to be requested actively and you might want to show contents to the user before they have entered an immersive session. You can use the `fallback` snippet to show a fallback scene to the user.

```svelte
<script>
  import { T } from '@threlte/core'
  import { XR, Controller } from '@threlte/xr'
  import { OrbitControls } from '@threlte/extras'
  import Scene from './Scene.svelte'
</script>

<Scene />

<XR>
  <Controller left>
  <Controller right>

  {#snippet fallback()}
    <T.PerspectiveCamera makeDefault position.z={5}>
      <OrbitControls />
    </T.PerspectiveCamera>
  {/snippet}
</XR>
```


================================================
File: apps/docs/src/content/showcase/bridge copy 2.mdx
================================================
---
image: 'https://images.unsplash.com/photo-1675427541162-f38ef068d691?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80'
name: 'Sad bridge'
live: 'https://unsplash.com/t/street-photography'
repo: 'https://github.com/threlte/threlte/pulls?q=is%3Apr+is%3Aopen+sort%3Aupdated-desc'
description: 'New exciting project made with threlte'
size: 'regular'
---


================================================
File: apps/docs/src/content/showcase/bridge copy 3.mdx
================================================
---
image: 'https://images.unsplash.com/photo-1675427541162-f38ef068d691?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80'
name: 'Sad bridge'
live: 'https://unsplash.com/t/street-photography'
repo: 'https://github.com/threlte/threlte/pulls?q=is%3Apr+is%3Aopen+sort%3Aupdated-desc'
description: 'New exciting project made with threlte'
size: 'large'
---


================================================
File: apps/docs/src/content/showcase/bridge copy 4.mdx
================================================
---
image: 'https://images.unsplash.com/photo-1675427541162-f38ef068d691?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80'
name: 'Sad bridge'
live: 'https://unsplash.com/t/street-photography'
repo: 'https://github.com/threlte/threlte/pulls?q=is%3Apr+is%3Aopen+sort%3Aupdated-desc'
description: 'New exciting project made with threlte'
size: 'regular'
---


================================================
File: apps/docs/src/content/showcase/bridge copy 5.mdx
================================================
---
image: 'https://images.unsplash.com/photo-1675427541162-f38ef068d691?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80'
name: 'Sad bridge'
live: 'https://unsplash.com/t/street-photography'
repo: 'https://github.com/threlte/threlte/pulls?q=is%3Apr+is%3Aopen+sort%3Aupdated-desc'
description: 'New exciting project made with threlte'
size: 'regular'
---


================================================
File: apps/docs/src/content/showcase/bridge copy 6.mdx
================================================
---
image: 'https://images.unsplash.com/photo-1675427541162-f38ef068d691?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80'
name: 'Sad bridge'
live: 'https://unsplash.com/t/street-photography'
repo: 'https://github.com/threlte/threlte/pulls?q=is%3Apr+is%3Aopen+sort%3Aupdated-desc'
description: 'New exciting project made with threlte'
size: 'regular'
---


================================================
File: apps/docs/src/content/showcase/bridge copy.mdx
================================================
---
image: 'https://images.unsplash.com/photo-1675427541162-f38ef068d691?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80'
name: 'Sad bridge'
live: 'https://unsplash.com/t/street-photography'
repo: 'https://github.com/threlte/threlte/pulls?q=is%3Apr+is%3Aopen+sort%3Aupdated-desc'
description: 'New exciting project made with threlte'
size: 'regular'
---


================================================
File: apps/docs/src/content/showcase/bridge.mdx
================================================
---
image: 'https://images.unsplash.com/photo-1675427541162-f38ef068d691?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80'
name: 'Sad bridge'
live: 'https://unsplash.com/t/street-photography'
repo: 'https://github.com/threlte/threlte/pulls?q=is%3Apr+is%3Aopen+sort%3Aupdated-desc'
description: 'New exciting project made with threlte'
size: 'large'
---


================================================
File: apps/docs/src/content/showcase/horse-carriage.mdx
================================================
---
image: 'https://images.unsplash.com/photo-1676322721139-7e43cf46e2ec?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHx0b3BpYy1mZWVkfDExfHhIeFlUTUhMZ09jfHxlbnwwfHx8fA%3D%3D&auto=format&fit=crop&w=500&q=60'
name: 'Horse carriage'
live: 'https://unsplash.com/t/street-photography'
repo: 'https://github.com/threlte/threlte/pulls?q=is%3Apr+is%3Aopen+sort%3Aupdated-desc'
description: 'New exciting project made with threlte'
size: 'regular'
---


================================================
File: apps/docs/src/content/showcase/street-art copy 2.mdx
================================================
---
image: 'https://images.unsplash.com/photo-1619993083831-687eaf87c98e?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1632&q=80'
name: 'Street art'
live: 'https://unsplash.com/t/street-photography'
repo: 'https://github.com/threlte/threlte/pulls?q=is%3Apr+is%3Aopen+sort%3Aupdated-desc'
description: 'New exciting project made with threlte'
size: 'large'
---


================================================
File: apps/docs/src/content/showcase/street-art copy 3.mdx
================================================
---
image: 'https://images.unsplash.com/photo-1619993083831-687eaf87c98e?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1632&q=80'
name: 'Street art'
live: 'https://unsplash.com/t/street-photography'
repo: 'https://github.com/threlte/threlte/pulls?q=is%3Apr+is%3Aopen+sort%3Aupdated-desc'
description: 'New exciting project made with threlte'
size: 'regular'
---


================================================
File: apps/docs/src/content/showcase/street-art copy.mdx
================================================
---
image: 'https://images.unsplash.com/photo-1619993083831-687eaf87c98e?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1632&q=80'
name: 'Street art'
live: 'https://unsplash.com/t/street-photography'
repo: 'https://github.com/threlte/threlte/pulls?q=is%3Apr+is%3Aopen+sort%3Aupdated-desc'
description: 'New exciting project made with threlte'
size: 'regular'
---


================================================
File: apps/docs/src/content/showcase/street-art.mdx
================================================
---
image: 'https://images.unsplash.com/photo-1619993083831-687eaf87c98e?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1632&q=80'
name: 'Street art'
live: 'https://unsplash.com/t/street-photography'
repo: 'https://github.com/threlte/threlte/pulls?q=is%3Apr+is%3Aopen+sort%3Aupdated-desc'
description: 'New exciting project made with threlte'
size: 'regular'
---


================================================
File: apps/docs/src/content/testimonials/amr.mdx
================================================
---
image: 'https://www.a3k.me/favicon/apple-touch-icon.png?v=2.2.0'
name: 'Amr'
title: 'Freelancer web developer'
link: 'https://twitter.com/amr3k_/status/1580799004694089728'
contents: "I built 3 webGL apps using threlte and it's amazing <3"
---


================================================
File: apps/docs/src/content/testimonials/aria-minaei.mdx
================================================
---
image: 'https://avatars.githubusercontent.com/u/593118?v=4'
name: 'Aria Minaei'
title: 'Creator of Theatre.js'
link: 'https://discord.com/channels/870988717190426644/889485298575212604/1135589828327645274'
contents: "[Regarding Threlte] Absolutely the best API and devX for Theatre.js [...] I'm so excited for this!"
---


================================================
File: apps/docs/src/content/testimonials/matthias-stahl.mdx
================================================
---
image: 'https://www.higsch.com/img/me_coding.jpg'
name: 'Matthias Stahl 🇪🇺'
title: 'I am a designer creating knowledge through data visualization.'
link: 'https://twitter.com/h_i_g_s_c_h'
contents: "🧑‍💻 First experiments using threlte for Svelte. After I didn't succeed using svelte-cubed, threlte seems to be a rather well-documented and good working declarative THREE library for Svelte. Many thanks to @a_warnes and @Reyfenberg!"
---


================================================
File: apps/docs/src/content/testimonials/rich-harris.mdx
================================================
---
image: https://avatars.githubusercontent.com/u/1162160?v=4
name: 'Rich Harris'
title: 'Creator of Svelte.'
link: 'https://twitter.com/Rich_Harris/status/1599090054382596097'
contents: "indeed — threlte is where it's at. i should get round to updating the svelte cubed repo/site to make that clearer"
---


================================================
File: apps/docs/src/content/testimonials/shiva.mdx
================================================
---
image: 'https://avatars.githubusercontent.com/u/57304890?v=4'
name: 'shiva'
title: 'Computer Science + Art student @Carnegie Mellon'
link: 'https://twitter.com/shiva_peri/status/1541627317147009025'
contents: 'threlte, which combines threejs and svelte, is easily one of my new favorite libraries'
---


================================================
File: apps/docs/src/content/testimonials/shiyun.mdx
================================================
---
image: 'https://pbs.twimg.com/profile_images/1310066625786372096/3JEciuhC_400x400.jpg'
name: 'Shiyun 诗韵'
title: 'Globalist, learner, software engineer'
link: 'https://twitter.com/lu_shiyun/status/1598002293114540032'
contents: My first try at writing shaders in threejs .. used the FBO particles technique to explore Chinese characters that have "女" (woman) as a component in them.. OMG it's so challenging! The new @threlte, made it easier though 🤓
---


================================================
File: apps/docs/src/content/testimonials/vatroslav.mdx
================================================
---
image: 'https://avatars.githubusercontent.com/u/3778969?v=4'
name: 'Vatroslav Vrbanić'
title: 'Creator of svelthree and svelte-accmod'
link: 'https://twitter.com/vatro_vrbanic/status/1556947920171286528'
contents: "I'm impressed by all the features of threlte.xyz, it's well polished / feels complete. Still, svelthree is different in many ways, and I think it's good to have alternatives. After 1.0.0-next.1, I'll have to dive deeper into threlte and compare/test it extensively."
---


